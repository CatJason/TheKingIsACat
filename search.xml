<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/31/My-First-Blog/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="其他技术博客的链接"><a href="#其他技术博客的链接" class="headerlink" title="其他技术博客的链接"></a>其他技术博客的链接</h2><h3 id="『字节跳动』『android』"><a href="#『字节跳动』『android』" class="headerlink" title="『字节跳动』『android』"></a>『字节跳动』『android』</h3><p><a href="http://gityuan.com/" target="_blank" rel="noopener">http://gityuan.com/</a></p>
<h3 id="『西北工业大学』『硕士』"><a href="#『西北工业大学』『硕士』" class="headerlink" title="『西北工业大学』『硕士』"></a>『西北工业大学』『硕士』</h3><p><a href="https://qiming.info/" target="_blank" rel="noopener">https://qiming.info/</a></p>
]]></content>
  </entry>
  <entry>
    <title>chrome反注册</title>
    <url>/2020/04/24/chrome%E5%8F%8D%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>Windows 下 Chrome 反向注册（reg文件）</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">; WARNING, this file will remove Google Chrome registry entries </span><br><span class="line">; from your Windows Registry. Consider backing up your registry before</span><br><span class="line">; using this file: http://support.microsoft.com/kb/322756</span><br><span class="line"></span><br><span class="line">; To run this file, save it as 'remove.reg' on your desktop and double-click it.</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ChromeHTML]</span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Clients\StartMenuInternet\chrome.exe]</span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\RegisteredApplications]</span><br><span class="line">"Chrome"=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Classes\ChromeHTML]</span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Clients\StartMenuInternet\chrome.exe]</span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\RegisteredApplications]</span><br><span class="line">"Chrome"=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\Chrome]</span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientStateMedium\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode常用Java语言API与API用法</title>
    <url>/2020/04/20/LeetCode%E5%B8%B8%E7%94%A8Java%E8%AF%AD%E8%A8%80API%E4%B8%8EAPI%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>对leetcode刷题中常用的Java语言API进行总结，穿插一些经典的写法。</p>
<a id="more"></a>

<h2 id="Java获取二维数组行列长度"><a href="#Java获取二维数组行列长度" class="headerlink" title="Java获取二维数组行列长度"></a>Java获取二维数组行列长度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>];	<span class="comment">//二维数组定义</span></span><br><span class="line"><span class="keyword">int</span> rowLength = array.length;	<span class="comment">//获取行数</span></span><br><span class="line"><span class="keyword">int</span> colLength = array[<span class="number">0</span>].length;	<span class="comment">//获取列数</span></span><br></pre></td></tr></table></figure>

<h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++)&#123;</span><br><span class="line">			System.out.println(array[i][j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>Android基础知识梳理</title>
    <url>/2020/04/19/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>以下内容均有参考Android官法开发文档</p>
<p>Activity生命周期参考<a href="https://www.cnblogs.com/lwbqqyumidi/p/3769113.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwbqqyumidi/p/3769113.html</a></p>
<p>Activity启动模式（lauchMode）参考<a href="https://blog.csdn.net/liuhe688/java/article/details/6754323" target="_blank" rel="noopener">https://blog.csdn.net/liuhe688/java/article/details/6754323</a></p>
<a id="more"></a>

<h2 id="Android组件生命周期"><a href="#Android组件生命周期" class="headerlink" title="Android组件生命周期"></a>Android组件生命周期</h2><h3 id="正确实施Activity生命周期方法"><a href="#正确实施Activity生命周期方法" class="headerlink" title="正确实施Activity生命周期方法"></a>正确实施Activity生命周期方法</h3><ul>
<li>如果用户在使用您的应用程序时接到电话或切换到另一个应用程序，则不会崩溃。</li>
<li>当用户不积极使用它时，不会消耗宝贵的系统资源。</li>
<li>如果用户离开您的应用程序并在以后返回它，则不会丢失用户的进度。</li>
<li>当屏幕在横向和纵向之间旋转时，不会崩溃或丢失用户的进度。</li>
</ul>
<h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><p>Activity是由Activity栈进管理，当来到一个新的Activity后，此Activity将被加入到Activity栈顶，之前的Activity位于此Activity底部。Acitivity一般意义上有四种状态：</p>
<p>1.当Activity位于栈顶时，此时正好处于屏幕最前方，此时处于<strong>运行状态</strong>；</p>
<p>2.当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕），此时处于<strong>暂停状态</strong>；</p>
<p>3.当Activity被其他Activity完全遮挡，此时此Activity对用户不可见，此时处于<strong>停止状态</strong>；</p>
<p>4.当Activity由于人为或系统原因（如低内存等）被销毁，此时处于<strong>销毁状态；</strong></p>
<p>在每个不同的状态阶段，Adnroid系统对Activity内相应的方法进行了回调。因此，我们在程序中写Activity时，一般都是继承Activity类并重写相应的回调方法。</p>
<p>Activity类中定义了7种回调方法，覆盖了活动生命周期的每一个环节：</p>
<ul>
<li><code>onCreate()</code>：完成活动的初始化操作，比如加载布局，绑定事件。</li>
<li><code>onStart()</code>：在活动由不可见变为可见的时候调用。</li>
<li><code>onResume()</code>：在活动准备好和用户进行交互时调用。该活动一定处于返回栈栈顶，且处于运行状态。</li>
<li><code>onPause()</code>：系统准备去启动或者恢复另一个活动的时候调用。该方法的执行速度一定要快，否则会影响到新的栈顶活动的使用。</li>
<li><code>onStop()</code>：在活动完全不可见时调用，与前者的区别时启动的新活动是一个对话框式的活动，那<code>onPause()</code>方法会得到执行，而该方法不会。</li>
<li><code>onDestory()</code>：在活动被销毁之前调用，之后活动变为销毁状态。</li>
<li><code>onRestart()</code>：由停止状态变为运行时状态之前调用，活动被重新启动。</li>
</ul>
<p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。</p>
<ul>
<li><strong>entire lifetime（完整生存期）</strong>：一个最简单的完整的按照如下顺序回调的Activity生命周期：<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code> -&gt; <code>onPause()</code> -&gt; <code>onStop()</code> -&gt; <code>onDestroy()</code>。<strong>活动在<code>onCreate()</code>和<code>onDestrory()</code>之间经历的就是完整生存期</strong></li>
<li><strong>visible lifetime（可见生存期）</strong>当执行<code>onStart()</code>回调方法时，Activity开始被用户所见（也就是说，<code>onCreate()</code>时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到<code>onStop()</code>之前，此阶段Activity都是被用户可见。<strong>活动在<code>onStart()</code>和<code>onStop</code>之间经历的就是可见生存期。活动对于用户总是可见的，即便有可能无法和用户进行交互。</strong></li>
<li><strong>foreground lifetime（前台生存期）</strong>当执行到<code>onResume()</code>回调方法时，Activity可以响应用户交互，一直到<code>onPause()</code>方法之前。<strong>活动在<code>onResume()</code>和<code>onPause()</code>之间经历的就是前台生存期。活动总是处于运行状态，此时活动可以和用户进行交互</strong></li>
</ul>
<p>在实际应用场景中，假设A Activity位于栈顶，此时用户操作，点击A中按钮来到B时，假设B全部遮挡住了A，从A Activity跳转到B Activity。</p>
<p>依次执行A:<code>onPause()</code> -&gt; B:<code>onCreate()</code> -&gt; B:<code>onStart()</code> -&gt; B:<code>onResume()</code> -&gt; A:<code>onStop()</code>。</p>
<p>此时如果点击Back键</p>
<p>将依次执行B:<code>onPause()</code> -&gt; A:<code>onRestart()</code> -&gt; A:<code>onStart()</code> -&gt; A:<code>onResume()</code> -&gt; B:<code>onStop()</code> -&gt; B:<code>onDestroy()</code>。</p>
<p>至此，Activity栈中只有A。</p>
<h3 id="Back键和Home键对Activity生命周期的影响实验"><a href="#Back键和Home键对Activity生命周期的影响实验" class="headerlink" title="Back键和Home键对Activity生命周期的影响实验"></a>Back键和Home键对Activity生命周期的影响实验</h3><p>实验结果：</p>
<p>Back键：系统返回到桌面，并依次执行A:<code>onPause()</code> -&gt; A:<code>onStop()</code> -&gt; A:<code>onDestroy()</code>。</p>
<p>Home键（非长按）：系统返回到桌面，并依次执行A:<code>onPause()</code> -&gt; A:<code>onStop()</code>。</p>
<p><strong>由此可见，Back键和Home键主要区别在于是否会执行onDestroy。</strong></p>
<p>长按Home键：不同手机可能弹出不同内容，Activity生命周期未发生变化（由小米2s实测）。</p>
<p>由于Android本身的特性，使得现在不少应用都没有直接退出应用程序的功能，按照一般的逻辑，当Activity栈中有且只有一个Activity时，当按下Back键此Activity会执行<code>onDestroy()</code>，那么下次点击此应用程图标将从重新启动，因此，当前不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？</p>
<p>通过重写按下Back键的回调函数，转成Home键的效果即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent home = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">    home.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    startActivity(home);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。</p>
<p>或者，为达到此类效果，Activity实际上提供了直接的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> activity.moveTaskToBack(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>moveTaskToBack()</strong>此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。</p>
<h3 id="Activity启动模式（lauchMode）"><a href="#Activity启动模式（lauchMode）" class="headerlink" title="Activity启动模式（lauchMode）"></a>Activity启动模式（lauchMode）</h3><p>launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。</p>
<p>Activity一共有以下四种launchMode：</p>
<p>1.standard</p>
<p>2.singleTop</p>
<p>3.singleTask</p>
<p>4.singleInstance</p>
<p>我们可以在AndroidManifest.xml配置<activity>的android:launchMode属性为以上四种之一即可。</p>
<p>下面我们结合实例一一介绍这四种lanchMode：</p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a><strong>standard</strong></h4><p>standard模式是默认的启动模式，不用为<activity>配置android:launchMode属性即可，当然也可以指定值为standard。</p>
<p>我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。</p>
<p>FirstActivity代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scott.launchmode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="keyword">this</span>.toString());</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, FirstActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。</p>
<p>然后我们连续点击几次按钮，将会出现下面的现象：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-standard%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。</p>
<p>standard模式的原理如下图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-standard%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a><strong>singleTop</strong></h4><p>我们在上面的基础上为<activity>指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。</p>
<p>singleTop模式的原理如下图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<p>正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。</p>
<p>我们再新建一个Activity命名为SecondActivity，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.scott.launchmode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.second);</span><br><span class="line">		TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="keyword">this</span>.toString());</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent(SecondActivity.<span class="keyword">this</span>, FirstActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		    	startActivity(intent);				</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将之前的FirstActivity跳转代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。</p>
<p>演示结果如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C2.png" alt="success"></p>
<p>我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。</p>
<p>原理图如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%862.png" alt="success"></p>
<p>我们看到，当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。</p>
<p><strong>这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。</strong></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a><strong>singleTask</strong></h4><p>在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。</p>
<p>演示的结果如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTask%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。</p>
<p>singleTask模式的原理图如下图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTask%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<p>在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统<strong>发现有存在的FirstActivity实例</strong>，于是<strong>不再生成新的实例</strong>，而是<strong>将FirstActivity之上的Activity实例统统出栈</strong>，将FirstActivity变为栈顶对象，显示到幕前。</p>
<p>也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。</p>
<p><strong>这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</strong></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a><strong>singleInstance</strong></h4><p>这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。</p>
<p>修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextView taskIdView = (TextView) findViewById(R.id.taskIdView);</span><br><span class="line">taskIdView.setText(<span class="string">"current task id: "</span> + <span class="keyword">this</span>.getTaskId());</span><br></pre></td></tr></table></figure>

<p>然后我们再演示一下这个流程：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<p>我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。</p>
<p>如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%862.png" alt="success"></p>
<p>singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".ShareActivity"</span> android:launchMode=<span class="string">"singleInstance"</span>&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">              &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">              &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">          	&lt;action android:name=<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span> /&gt;</span><br><span class="line">              &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">      &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们在其他应用中这样启动该Activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%863.png" alt="success"></p>
<h2 id="Server组件"><a href="#Server组件" class="headerlink" title="Server组件"></a>Server组件</h2><p><code>Service</code>是一个应用程序组件，它能够在后台执行一些耗时较长的操作，并且不提供用户界面。</p>
<p>服务能被其它应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。</p>
<p>此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 服务可以处理：</p>
<ul>
<li><p>网络传输</p>
</li>
<li><p>音乐播放</p>
</li>
<li><p>执行文件I/O</p>
</li>
<li><p>与content provider进行交互</p>
<p>所有这些都是后台进行的。</p>
</li>
</ul>
<h4 id="服务有以下两种基本类型："><a href="#服务有以下两种基本类型：" class="headerlink" title="服务有以下两种基本类型："></a>服务有以下两种基本类型：</h4><ul>
<li><p>started </p>
<p>如果一个应用程序组件（比如一个activity）通过调用<code>startService()</code>来启动服务，则该服务就是被“started”了。一旦被启动，服务就能在后台一直运行下去，即使启动它的组件已经被销毁了。 通常，started的服务执行单一的操作并且不会向调用者返回结果。比如，它可以通过网络下载或上传文件。当操作完成后，服务应该自行终止。</p>
</li>
<li><p>bound </p>
<p>如果一个应用程序组件通过调用<code>bindService()</code>绑定到服务上，则该服务就是被“bound”了。bound服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至可以利用进程间通信（IPC）跨进程执行这些操作。绑定服务的生存期和被绑定的应用程序组件一致。 多个组件可以同时与一个服务绑定，不过所有的组件解除绑定后，服务也就会被销毁。</p>
</li>
</ul>
<p>虽然本文对这两种类型的服务是分别进行简要描述的，但是你的服务仍可以同时用两种方式工作——可以是started（一直运行下去），同时也能被绑定。 只会存在一点麻烦，是否两个回调方法都要实现：实现<code>onStartCommand()</code>以允许组件启动服务、实现<code>onBind()</code>以允许绑定。</p>
<p>无论你的应用程序是started、bound、还是两者都支持，任何应用程序组件都可以使用此服务（即使是从另一个独立的应用程序中）， 同样，任何组件都可以用这种方式使用一个activity——通过一个<code>Intent</code>启动。不过，也可以在manifest文件中把服务声明为私有private的，以便阻止其它应用程序的访问。 这将<a href="http://developer.android.com/guide/topics/fundamentals/services.html#Declaring" target="_blank" rel="noopener">在manifest中声明服务</a>文中详细论述。</p>
<p><strong>警告：</strong>如果不明确指明服务运行于新创建的进程/线程，服务将运行于宿主进程的主线程中。 这意味着，如果你的服务要执行一些很耗CPU的工作或者阻塞的操作（比如播放MP3或网络操作），你应该在服务中创建一个新的线程来执行这些工作。 利用单独的线程，将减少你的activity发生应用程序停止响应（ANR）错误的风险。</p>
<h3 id="Server概述"><a href="#Server概述" class="headerlink" title="Server概述"></a>Server概述</h3><hr>
<h4 id="使用服务还是使用线程？"><a href="#使用服务还是使用线程？" class="headerlink" title="使用服务还是使用线程？"></a>使用服务还是使用线程？</h4><p>服务仅仅是一个组件，即使用户不再与你的应用程序发生交互，它仍然能在后台运行。因此，应该只在需要时才创建一个服务。</p>
<p>如果你需要在主线程之外执行一些工作，但仅当用户与你的应用程序交互时才会用到，那你应该创建一个新的线程而不是创建服务。 比如，如果你需要播放一些音乐，但只是当你的activity在运行时才需要播放，你可以在<code>onCreate()</code>中创建一个线程，在<code>onStart()</code>中开始运行，然后在<code>onStop()</code>中终止运行。还可以考虑使用<code>AsyncTask</code>或<code>HandlerThread</code>来取代传统的<code>Thread</code>类。关于线程的详细信息，请参阅<a href="http://developer.android.com/guide/topics/fundamentals/processes-and-threads.html#Threads" target="_blank" rel="noopener">进程和线程</a>。</p>
<p>请记住，如果你使用了服务，它默认就运行于应用程序的主线程中。因此，如果服务执行密集计算或者阻塞操作，你仍然应该在服务中创建一个新的线程来完成。</p>
<p>为了创建一个服务，你必须新建一个<code>Service</code>的子类（或一个已有Service的子类）。在你的实现代码中，请按需重写一些回调方法，用于对服务生命周期中的关键节点进行处理，以及向组件提供绑定机制。 </p>
<h4 id="最重要的需要重写的回调方法："><a href="#最重要的需要重写的回调方法：" class="headerlink" title="最重要的需要重写的回调方法："></a>最重要的需要重写的回调方法：</h4><ul>
<li><p><code>onStartCommand()</code>当其它组件，比如一个activity，通过调用<code>startService()</code>请求started方式的服务时，系统将会调用本方法。 一旦本方法执行，服务就被启动，并在后台一直运行下去。 如果你的代码实现了本方法，你就有责任在完成工作后通过调用<code>stopSelf()</code>或<code>stopService()</code>终止服务。 （如果你只想提供bind方式，那就不需要实现本方法。）</p>
</li>
<li><p><code>onBind()</code></p>
</li>
</ul>
<p>当其它组件需要通过<code>bindService()</code>绑定服务时（比如执行RPC），系统会调用本方法。 在本方法的实现代码中，你必须返回IBinder来提供一个接口，客户端用它来和服务进行通信。 你必须确保实现本方法，不过假如你不需要提供绑定，那就返回null即可。</p>
<ul>
<li><code>onCreate()</code></li>
</ul>
<p>当服务第一次被创建时，系统会调用本方法，用于执行一次性的配置工作（之前已调用过<code>onStartCommand()</code>或<code>onBind()</code> 了。如果服务已经运行，则本方法就不会被调用。</p>
<ul>
<li><code>onDestroy()</code></li>
</ul>
<p>当服务用不上了并要被销毁时，系统会调用本方法。 你的服务应该实现本方法来进行资源的清理工作，诸如线程、已注册的侦听器listener和接收器receiver等等。 这将是服务收到的最后一个调用。</p>
<p>如果组件通过调用startService()<code>（这会导致</code>onStartCommand()<code>的调用）启动了服务，那么服务将一直保持运行，直至自行用</code>stopSelf()<code>终止或由其它组件调用stopService()</code>来终止它。</p>
<p>如果组件调用<code>bindService()</code>来创建服务（那<code>onStartCommand()</code>就不会被调用），则服务的生存期就与被绑定的组件一致。一旦所有客户端都对服务解除了绑定，系统就会销毁该服务。</p>
<p>仅当内存少得可怜、且必须覆盖拥有用户焦点的activity的系统资源时，Android系统才会强行终止一个服务。 如果服务被拥有用户焦点的activity绑定着，则它一般不会被杀死。 如果服务声明为<a href="https://www.android-doc.com/guide/components/services.html#.E5.9C.A8.E5.89.8D.E5.8F.B0.E8.BF.90.E8.A1.8C.E6.9C.8D.E5.8A.A1" target="_blank" rel="noopener">#在前台运行服务</a>（下文讨论），则它几乎永远不会被杀死。 否则，如果服务已被启动并且已运行了很长时间，那么系统将会随时间推移而降低它在后台任务列表中的级别， 此类服务将很有可能会被杀死——如果服务已经启动，那你必须好好设计代码，使其能完美地应付被系统重启的情况。 如果系统杀死了你的服务，只要资源再度够用，系统就会再次启动服务（当然这还取决于<code>onStartCommand()</code>的返回值，下文将会述及）。关于系统可能会在何时销毁服务的详细信息，请参阅<a href="http://developer.android.com/guide/topics/fundamentals/processes-and-threads.html" target="_blank" rel="noopener">进程和线程</a>。</p>
<p>在下节中，你将看到如何创建每种类型的服务，以及如何在应用程序组件中使用它们。</p>
<h3 id="在manifest中声明服务"><a href="#在manifest中声明服务" class="headerlink" title="在manifest中声明服务"></a>在manifest中声明服务</h3><p>与activity（及其它组件）类似，你必须在应用程序的manifest文件中对所有的服务进行声明。</p>
<p>要声明你的服务，把<service>元素作为子元素加入到<application>元素中去即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;application ... &gt;</span><br><span class="line">      &lt;service android:name&#x3D;&quot;.ExampleService&quot; &#x2F;&gt;</span><br><span class="line">      ...</span><br><span class="line">  &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>

<p>在<service>元素中可以包含很多其它属性，比如定义启动服务所需权限、服务运行的进程之类的属性。android:name是唯一必需的属性——它定义了服务的类名。应用程序一经发布，就不得再修改这个类名。因为这么做可能会破坏某些显式引用该服务的intent功能（参阅博客文章<a href="http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html" target="_blank" rel="noopener">Things That Cannot Change</a>）。</p>
<p>关于在manifest中声明服务的详情，请参阅<service>元素参考文档。</p>
<p>与activity一样，服务可以定义intent过滤器，使得其它组件能用隐式intent来调用服务。 通过声明intent过滤器，任何安装在用户设备上的应用程序组件都有能力来启动你的服务，只要你的服务所声明的intent过滤器与其它应用程序传递给<code>startService()</code>的intent相匹配即可。</p>
<p>如果你想让服务只能内部使用（其它应用程序无法调用），那么就不必（也不应该）提供任何intent过滤器。 如果不存在任何intent过滤器，那你就必须用精确指定服务类名的intent来启动服务。 关于<a href="https://www.android-doc.com/guide/components/services.html#.E5.90.AF.E5.8A.A8.E4.B8.80.E4.B8.AA.E6.9C.8D.E5.8A.A1" target="_blank" rel="noopener">#启动一个服务</a>的详细内容，将在下文讨论。</p>
<p>此外，如果包含了android:exported属性并且设置为”false”， 就可以确保该服务是你应用程序的私有服务。即使服务提供了intent过滤器，本属性依然生效。</p>
<p>关于为服务创建intent过滤器的详细信息，请参阅<a href="http://developer.android.com/guide/topics/intents/intents-filters.html" target="_blank" rel="noopener">Intent和Intent过滤器</a>文档。</p>
<h4 id="创建一个started服务"><a href="#创建一个started服务" class="headerlink" title="创建一个started服务"></a>创建一个started服务</h4><p>started服务是指其它组件通过调用<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>来启动的服务，这会引发对该服务[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))方法的调用。</p>
<p>一旦服务被启动started，它就拥有了自己的生命周期，这是独立于启动它的组件的。并且它能够在后台一直运行下去，即使启动它的组件已被销毁 也是如此。 因此，服务应该能够在完成工作后自行终止，通过调用<a href="http://developer.android.com/reference/android/app/Service.html#stopSelf()" target="_blank" rel="noopener">stopSelf()</a>即可，或者由其它组件通过调用<a href="http://developer.android.com/reference/android/content/Context.html#stopService(android.content.Intent)" target="_blank" rel="noopener">stopService()</a>也可以。</p>
<p>诸如activity之类的应用程序组件，可以通过调用<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>启动服务,并传入一个给出了服务和服务所需数据的<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>对象。服务将在[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))方法中接收到该<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>对象。</p>
<p>举个例子，假定某activity需要把一些数据保存到在线数据库中。此activity可以启动一个守护服务并通过传入<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>一个intent把需要保存的数据发送给该服务。该服务在[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))内接收intent，连接Internet，再进行数据库事务处理。当事务完成后，服务自行终止，并被系统销毁。</p>
<p><strong>警告：</strong>默认情况下，运行服务的进程与应用程序的相同，并且运行在应用程序的主线程中。 因此，如果你的服务要执行计算密集或阻塞的操作，而同时用户又需要与同一个应用程序中的activity进行交互，那么服务将会降低activity的性能。 为了避免对应用程序性能的影响，你应该在服务中启动一个新的线程。</p>
<p>传统做法，你可以扩展两个类来创建started服务：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="noopener">Service</a></li>
</ul>
<p>这是所有服务的基类。如果你要扩展该类，则很重要的一点是：请在其中创建一个新的线程来完成所有的服务工作。 因为服务默认是使用应用程序的主线程的，这会降低应用程序中activity的运行性能。</p>
<ul>
<li><a href="http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService</a></li>
</ul>
<p>这是<a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="noopener">Service</a>类的子类，它使用了工作（worker）线程来处理所有的启动请求，每次请求都会启动一个线程。 如果服务不需要同时处理多个请求的话，这是最佳的选择。 所有你要做的工作就是实现<a href="http://developer.android.com/reference/android/app/IntentService.html#onHandleIntent(android.content.Intent)" target="_blank" rel="noopener">onHandleIntent()</a>即可，它会接收每个启动请求的intent，然后就可在后台完成工作。</p>
<p>下一节描述了如何用这两个类来实现服务。</p>
<h4 id="扩展IntentService类"><a href="#扩展IntentService类" class="headerlink" title="扩展IntentService类"></a>扩展IntentService类</h4><p>因为<strong>大多数started服务都不需要同时处理多个请求</strong>（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。</p>
<p>IntentService将执行以下步骤：</p>
<p>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到<code>onStartCommand()</code>的intent。</p>
<p>创建一个工作队列，每次向你的<code>onHandleIntent()</code>传入一个intent，这样你就永远不必担心多线程问题了。</p>
<p>在处理完所有的启动请求后，终止服务，因此你就永远不需调用<code>stopSelf()</code>了。</p>
<p>提供缺省的<code>onBind()</code>实现代码，它返回null。</p>
<p>提供缺省的<code>onStartCommand()</code>实现代码，它把intent送入工作队列，稍后会再传给你的<code>onHandleIntent()</code>实现代码。</p>
<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现<code>onHandleIntent()</code>的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）</p>
<p>以下是个IntentService的实现例程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 构造方法是必需的，必须用工作线程名称作为参数</span></span><br><span class="line"><span class="comment">   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 </span></span><br><span class="line"><span class="comment">   * 本方法返回后，IntentService将适时终止这个服务。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 通常我们会在这里执行一些工作，比如下载文件。</span></span><br><span class="line">      <span class="comment">// 作为例子，我们只是睡5秒钟。</span></span><br><span class="line">      <span class="keyword">long</span> endTime = System.currentTimeMillis() + <span class="number">5</span>*<span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  wait(endTime - System.currentTimeMillis());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有你需要做的就是：一个构造方法和一个<code>onHandleIntent()</code>方法的实现。</p>
<p>如果你还决定重写其它的回调方法，比如<code>onCreate()</code>、<code>onStartCommand()</code>、<code>onDestroy()</code>， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>
<p>比如说，<code>onStartCommand()</code>必须返回缺省实现代码的结果（缺省代码实现了如何获取传给<code>onHandleIntent()</code>的intent）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">"service starting"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>onHandleIntent()</code>以外，唯一不需要调用父类实现代码的方法是<code>onBind()</code>（不过如果你的服务允许绑定，你还是需要实现它）。</p>
<p>在下一节中，你将看到如何扩展Service基类来实现同一服务，代码量会多一些，但可能适合处理多个同时发起的请求。</p>
<h4 id="扩展Service类"><a href="#扩展Service类" class="headerlink" title="扩展Service类"></a>扩展Service类</h4><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>
<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloService extends Service &#123;</span><br><span class="line">  private Looper mServiceLooper;</span><br><span class="line">  private ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 处理从线程接收的消息</span><br><span class="line">  private final class ServiceHandler extends Handler &#123;</span><br><span class="line">      public ServiceHandler(Looper looper) &#123;</span><br><span class="line">          super(looper);</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void handleMessage(Message msg) &#123;</span><br><span class="line">          &#x2F;&#x2F; 通常我们在这里执行一些工作，比如下载文件。</span><br><span class="line">          &#x2F;&#x2F; 作为例子，我们只是睡个5秒钟。</span><br><span class="line">          long endTime &#x3D; System.currentTimeMillis() + 5*1000;</span><br><span class="line">          while (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">              synchronized (this) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      wait(endTime - System.currentTimeMillis());</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动运行服务的线程。</span><br><span class="line">    &#x2F;&#x2F; 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span><br><span class="line">    &#x2F;&#x2F; 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span><br><span class="line">    HandlerThread thread &#x3D; new HandlerThread(&quot;ServiceStartArguments&quot;,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    thread.start();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获得HandlerThread的Looper队列并用于Handler</span><br><span class="line">    mServiceLooper &#x3D; thread.getLooper();</span><br><span class="line">    mServiceHandler &#x3D; new ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 对于每一个启动请求，都发送一个消息来启动一个处理</span><br><span class="line">      &#x2F;&#x2F; 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span><br><span class="line">      Message msg &#x3D; mServiceHandler.obtainMessage();</span><br><span class="line">      msg.arg1 &#x3D; startId;</span><br><span class="line">      mServiceHandler.sendMessage(msg);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果我们被杀死了，那从这里返回之后被重启</span><br><span class="line">      return START_STICKY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">      &#x2F;&#x2F; 我们不支持绑定，所以返回null</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，它要干的事情比用IntentService时多了很多。</p>
<p>不过，因为是自行处理每个<code>onStartCommand()</code>调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>
<p>请注意<code>onStartCommand()</code>方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。<code>onStartCommand()</code>的返回值必须是以下常量之一：</p>
<h5 id="onStartCommand-返回值"><a href="#onStartCommand-返回值" class="headerlink" title="onStartCommand()返回值"></a>onStartCommand()返回值</h5><ul>
<li><p>START_NOT_STICKY </p>
<p>如果系统在<code>onStartCommand()</code>返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。</p>
</li>
<li><p>START_STICKY </p>
<p>如果系统在<code>onStartCommand()</code>返回后杀死了服务，则将重建服务并调用<code>onStartCommand()</code>，但不会再次送入上一个intent， 而是用null intent来调用<code>onStartCommand()</code>。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。</p>
</li>
<li><p>START_REDELIVER_INTENT </p>
<p>如果系统在<code>onStartCommand()</code>返回后杀死了服务，则将重建服务并用上一个已送过的intent调用    <code>onStartCommand()</code>。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。</p>
</li>
</ul>
<p>关于这些返回值的详情，请参阅每个常量的参考文档链接。</p>
<h4 id="启动一个服务"><a href="#启动一个服务" class="headerlink" title="启动一个服务"></a>启动一个服务</h4><p>从activity或其它应用程序组件中可以启动一个服务，调用<code>startService()</code>并传入一个<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>（指定所需启动的服务）即可。Android系统将调用服务的<code>onStartCommand()</code>方法，并传入该<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>（你永远都不应该直接去调用<code>onStartCommand()</code>。）</p>
<p>例如，一个activity可以用一个显式的intent通过<code>startService()</code>启动上一节的示例服务（HelloSevice）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(this, HelloService.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>

<p><a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>方法会立即返回，Android系统会去调用服务的[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int)) 方法。如果服务还未运行，系统会首先调用<a href="http://developer.android.com/reference/android/app/Service.html#onCreate()" target="_blank" rel="noopener">onCreate()</a>，然后再去调用[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int)) 。</p>
<p>如果服务不同时支持绑定，那么通过<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>传入的intent将是应用程序组件与服务进行交互的唯一途径。 当然，如果你期望服务能返回结果，那启动服务的客户端可以创建一个<a href="http://developer.android.com/reference/android/app/PendingIntent.html" target="_blank" rel="noopener">PendingIntent</a>来获得一个广播broadcast（利用[getBroadcast()](<a href="http://developer.android.com/reference/android/app/PendingIntent.html#getBroadcast" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/PendingIntent.html#getBroadcast</a>(android.content.Context, int, android.content.Intent, int))），并把它放入启动服务的<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>并传到服务中去。然后服务就会用这个broadcast来传递结果。</p>
<p>多个启动服务的请求将会引发服务[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))方法的多次调用。不过，只有一个终止服务的请求（用<a href="http://developer.android.com/reference/android/app/Service.html#stopSelf()" target="_blank" rel="noopener">stopSelf()</a>或<a href="http://developer.android.com/reference/android/content/Context.html#stopService(android.content.Intent)" target="_blank" rel="noopener">stopService()</a>）会被接受并执行。</p>
<h4 id="终止一个服务"><a href="#终止一个服务" class="headerlink" title="终止一个服务"></a>终止一个服务</h4><p><strong>一个started服务必须自行管理生命周期</strong>。也就是说，<strong>系统不会终止或销毁这类服务，除非必须恢复系统内存并且服务返回后一直维持运行</strong>。 因此，服务必须通过<strong>调用</strong><code>stopSelf()</code><strong>自行终止</strong>，或者<strong>其它组件可通过**</strong>调用<code>stopService()</code>来终止它。</p>
<p>用<code>stopSelf()</code>或<code>stopService()</code>的<strong>终止请求一旦发出，系统就会尽快销毁服务</strong>。</p>
<p>不过，<strong>如果你的服务要同时处理多个</strong><code>onStartCommand()</code><strong>请求</strong>，<strong>那在处理启动请求的过程中，你就不应该去终止服务</strong>，因为你可能接收到了一个新的启动请求（在第一个请求处理完毕后终止服务将停止第二个请求的处理。 为了避免这个问题，你可以用<code>stopSelf(int)</code>来确保终止服务的请求总是根据最近一次的启动请求来完成。 也就是说，当你调用<code>stopSelf(int)</code>时，你把启动请求ID（发送给<code>onStartCommand()</code>, int, int))的startId）传给了对应的终止请求。这样，如果服务在你可以调用<code>stopSelf(int)</code>时接收到了新的启动请求，则ID将会不一样，服务将不会被终止。</p>
<p><strong>警告：</strong>当服务完成工作后，你的应用程序应该及时终止它，这点非常重要。这样可以<strong>避免系统资源的浪费，并能节省电池的电力</strong>。 必要时，其它组件可以通过调用<code>stopService()</code>来终止服务。即使你的服务允许绑定，你也必须保证它在收到对<code>onStartCommand()</code>的调用时能够自行终止。</p>
<p>关于服务生命周期的详细信息，请参阅下文的<a href="https://www.android-doc.com/guide/components/services.html#.E5.AF.B9.E6.9C.8D.E5.8A.A1.E7.9A.84.E7.94.9F.E5.91.BD.E5.91.A8.E6.9C.9F.E8.BF.9B.E8.A1.8C.E7.AE.A1.E7.90.86" target="_blank" rel="noopener">#对服务的生命周期进行管理</a>章节。</p>
<h3 id="创建一个bound服务"><a href="#创建一个bound服务" class="headerlink" title="创建一个bound服务"></a>创建一个bound服务</h3><hr>
<p>bound服务是指允许被应用程序组件绑定的服务，通过调用<code>bindService()</code>, android.content.ServiceConnection, int))可以完成绑定，用于创建一个长期存在的连接（并且一般不再允许组件通过调用<code>startService()</code>来start服务。</p>
<p>当应用程序中的activity或其它组件需要与服务进行交互，或者应用程序的某些功能需要暴露给其它应用程序时，你应该创建一个bound服务，并通过进程间通信（IPC）来完成。</p>
<p>要创建一个bound服务，你必须实现<a href="http://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent)" target="_blank" rel="noopener">onBind()</a>回调方法，并返回一个<a href="http://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a>对象，此对象定义了与服务进行通信的接口。 然后，其它应用程序组件可以调用[bindService()](<a href="http://developer.android.com/reference/android/content/Context.html#bindService" target="_blank" rel="noopener">http://developer.android.com/reference/android/content/Context.html#bindService</a>(android.content.Intent, android.content.ServiceConnection, int))来获得接口并调用服务中的方法。 服务只在为绑定的应用程序组件工作时才会存活，因此，只要没有组件绑定到服务，系统就会自动销毁服务（你不需要像started服务中那样通过[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))来终止一个bound服务）。</p>
<p>要创建一个bound服务，首先必须定义好接口，用于指明客户端如何与服务进行通信。 这个客户端与服务之间的接口必须是一个<a href="http://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a>对象的实现，并且你的服务必须在<a href="http://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent)" target="_blank" rel="noopener">onBind()</a>回调方法中返回这个对象。一旦客户端接收到这个<a href="http://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a>，它就可以通过这个接口来与服务进行交互。</p>
<p>同一个服务可以被多个客户端绑定。当客户端完成交互时，会调用<a href="http://developer.android.com/reference/android/content/Context.html#unbindService(android.content.ServiceConnection)" target="_blank" rel="noopener">unbindService()</a>来解除绑定。一旦不存在客户端与服务绑定时，系统就会销毁该服务。</p>
<p>实现bound服务的方式可以有很多种，实现的过程也比started类型的服务更为复杂，因此bound服务将在单独的<a href="https://www.android-doc.com/Bound服务" target="_blank" rel="noopener">bound服务</a>文档中讨论。</p>
<h3 id="向用户发送通知"><a href="#向用户发送通知" class="headerlink" title="向用户发送通知"></a>向用户发送通知</h3><hr>
<p>一旦开始运行，服务就能够利用<a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html" target="_blank" rel="noopener">toast通知</a>或<a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">状态栏通知</a>把事件通知给用户。</p>
<p>toast通知是一个显示在当前窗口之上的消息框，显示一会儿之后它会自行消失。 而状态栏通知则是在状态栏上显示一个附带消息的图标，用户可以选中它来执行一个action（比如启动一个activity）。</p>
<p>通常，当某些后台工作已经完成时（比如文件下载完毕），状态栏通知是最好的通知手段，用户这时可以在其上执行一些操作。</p>
<p>详情请参阅<a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html" target="_blank" rel="noopener">toast通知</a>或<a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">状态栏通知</a>开发指南。</p>
<h3 id="在前台运行服务"><a href="#在前台运行服务" class="headerlink" title="在前台运行服务"></a>在前台运行服务</h3><hr>
<p>前台服务是指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，并会置于“正在进行的”（“Ongoing”）组之下。这意味着只有在服务被终止或从前台移除之后，此通知才能被解除。</p>
<p>例如，用服务来播放音乐的播放器就应该运行在前台，因为用户会清楚地知晓它的运行情况。 状态栏通知可能会标明当前播放的歌曲，并允许用户启动一个activity来与播放器进行交互。</p>
<p>要把你的服务请求为前台运行，可以调用[startForeground()](<a href="http://developer.android.com/reference/android/app/Service.html#startForeground" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#startForeground</a>(int, android.app.Notification))方法。此方法有两个参数：唯一标识通知的整数值、状态栏通知<a href="http://developer.android.com/reference/android/app/Notification.html" target="_blank" rel="noopener">Notification</a>对象。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Notification notification &#x3D; new Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent &#x3D; new Intent(this, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent &#x3D; PendingIntent.getActivity(this, 0, notificationIntent, 0);</span><br><span class="line">notification.setLatestEventInfo(this, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line">startForeground(ONGOING_NOTIFICATION, notification);</span><br></pre></td></tr></table></figure>

<p>要从前台移除服务，请调用<a href="http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean)" target="_blank" rel="noopener">stopForeground()</a>方法，这个方法接受个布尔参数，表示是否同时移除状态栏通知。此方法不会终止服务。不过，如果服务在前台运行时被你终止了，那么通知也会同时被移除。</p>
<p><strong>注意：</strong>[startForeground()](<a href="http://developer.android.com/reference/android/app/Service.html#startForeground" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#startForeground</a>(int, android.app.Notification))和<a href="http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean)" target="_blank" rel="noopener">stopForeground()</a>方法是自Android 2.0 (API Level 5)开始引入的。 为了让服务能在更早版本的平台上实现前台运行，你必须使用以前的setForeground()方法——关于如何提供向后兼容性的详情，请参阅[startForeground()](<a href="http://developer.android.com/reference/android/app/Service.html#startForeground" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#startForeground</a>(int, android.app.Notification))。</p>
<p>有关通知的详细信息，请参阅<a href="https://www.android-doc.com/index.php?title=创建状态栏通知&action=edit&redlink=1" target="_blank" rel="noopener">创建状态栏通知</a>。</p>
<h3 id="对服务的生命周期进行管理"><a href="#对服务的生命周期进行管理" class="headerlink" title="对服务的生命周期进行管理"></a>对服务的生命周期进行管理</h3><hr>
<p>服务的生命周期与activity的非常类似。不过，更重要的是你需密切关注服务的创建和销毁环节，因为后台运行的服务是不会引起用户注意的。</p>
<h4 id="服务的生命周期从创建到销毁的两种路径："><a href="#服务的生命周期从创建到销毁的两种路径：" class="headerlink" title="服务的生命周期从创建到销毁的两种路径："></a>服务的生命周期从创建到销毁的两种路径：</h4><ul>
<li><p>一个started服务</p>
</li>
<li><p>一个bound服务</p>
</li>
</ul>
<p>这两条路径并不是完全隔离的。也就是说，你可以绑定到一个已经用<code>startService()</code>启动的服务上。例如，一个后台音乐服务可以通过调用<code>startService()</code>来启动，传入一个指明所需播放音乐的 Intent。 之后，用户也许需要用播放器进行一些控制，或者需要查看当前歌曲的信息，这时一个activity可以通过调用<code>bindService()</code>与此服务绑定。在类似这种情况下，<code>stopService()</code>或<code>stopSelf()</code>不会真的终止服务，除非所有的客户端都解除了绑定。</p>
<h4 id="实现生命周期回调方法"><a href="#实现生命周期回调方法" class="headerlink" title="实现生命周期回调方法"></a>实现生命周期回调方法</h4><p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Server%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="Server生命周期"></p>
<p>图 2.服务的生命周期。 左边的图展示了用<code>startService()</code>创建的服务的生命周期，右边的图展示了用<code>bindService()</code>创建的服务的生命周期。</p>
<p>与activity类似，服务也存在生命周期回调方法，你可以实现这些方法来监控服务的状态变化，并在适当的时机执行一些操作。 以下代码提纲展示了服务的每个生命周期回调方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExampleService extends Service &#123;</span><br><span class="line">    int mStartMode;       &#x2F;&#x2F; 标识服务被杀死后的处理方式</span><br><span class="line">    IBinder mBinder;      &#x2F;&#x2F; 用于客户端绑定的接口</span><br><span class="line">    boolean mAllowRebind; &#x2F;&#x2F; 标识是否使用onRebind</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务正被创建</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务正在启动，由startService()调用引发</span><br><span class="line">        return mStartMode;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 客户端用bindService()绑定服务</span><br><span class="line">        return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onUnbind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 所有的客户端都用unbindService()解除了绑定</span><br><span class="line">        return mAllowRebind;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onRebind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 某客户端正用bindService()绑定到服务,</span><br><span class="line">        &#x2F;&#x2F; 而onUnbind()已经被调用过了</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务用不上了，将被销毁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>与activity的生命周期回调方法不同，你不是一定要调用父类的回调方法。</p>
<p>通过实现这些方法，你能够监控服务中两个嵌套的生命周期循环</p>
<h5 id="服务的完整与活跃生命周期"><a href="#服务的完整与活跃生命周期" class="headerlink" title="服务的完整与活跃生命周期"></a>服务的完整与活跃生命周期</h5><ul>
<li><p>服务的<strong>完整生存期</strong>开始于<code>onCreate()</code>调用时，结束于<code>onDestroy()</code>返回时。与activity类似，服务在<code>onCreate()</code>中完成初始设置工作，并在<code>onDestroy()</code>中释放所有未释放的资源。例如，一个音乐播放服务可以在<code>onCreate()</code>中创建音乐播放线程，而在<code>onDestroy()</code>中终止该线程。 不管是用<code>startService()</code>创建的，还是用<code>bindService()</code>创建的，所有的服务都会调用<code>onCreate()</code>和<code>onDestroy()</code>方法。</p>
</li>
<li><p>服务的<strong>活跃生存期</strong>开始于<code>onStartCommand()</code>或<code>onBind()</code>的调用。这两个方法分别会传入传给<code>startService()</code>或<code>bindService()</code>的 Intent。 如果服务是started的，则活跃生存期与完整生存期同时结束（即使<code>onStartCommand()</code>返回后，服务仍然处于活跃期。）如果服务是bound的，则活跃生存期在 onUnbind() 返回后结束。</p>
</li>
</ul>
<p><strong>注意：</strong>虽然started的服务是用<code>stopSelf()</code>或<code>stopService()</code>调用来终止的，但是服务却没有相应的回调方法（不存在onStop()回调方法）。因此，除非服务与客户端绑定了，不然系统就会在服务终止时销毁它——<code>onDestroy()</code>是唯一会收到的回调方法。</p>
<p>图 2 标明了服务中典型的回调方法。尽管此图把<code>startService()</code>创建的服务和<code>bindService()</code>创建的分开描述了，但请记住，无论启动的方式如何，所有的服务实际上都允许被绑定。 因此，用<code>onStartCommand()</code>启动的服务（客户端调用<code>startService()</code>仍然可以接收<code>onBind()</code>调用（当客户端调用了<code>bindService()</code>时）。</p>
<p>有关创建支持绑定的服务，详情请参阅<a href="https://www.android-doc.com/Bound服务" target="_blank" rel="noopener">bound服务</a>文档，在其中的<a href="https://www.android-doc.com/Bound服务#.E7.AE.A1.E7.90.86bound.E6.9C.8D.E5.8A.A1.E7.9A.84.E7.94.9F.E5.91.BD.E5.91.A8.E6.9C.9F" target="_blank" rel="noopener">bound服务#管理bound服务的生命周期</a>章节中包含了有关<code>onRebind()</code>回调方法的详细信息。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>三色旗算法</title>
    <url>/2020/04/15/%E4%B8%89%E8%89%B2%E6%97%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>三色旗算法</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package a;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Main&#123;     </span><br><span class="line">    public static  void main(String[] args)  &#123;  </span><br><span class="line">        System.out.println(&quot;请输入旗子的颜色字符串&quot;);</span><br><span class="line">        Scanner cin &#x3D; new Scanner(System.in);       </span><br><span class="line">        while(cin.hasNext())&#123;</span><br><span class="line">          String n&#x3D;cin.next();</span><br><span class="line">            char[] a&#x3D;n.toCharArray();</span><br><span class="line">          int b&#x3D;0,w&#x3D;0,r&#x3D;a.length-1;</span><br><span class="line">          int count&#x3D;0;</span><br><span class="line">          while(w&lt;&#x3D;r) &#123;</span><br><span class="line">              if(a[w]&#x3D;&#x3D;&#39;白&#39;)</span><br><span class="line">              &#123;</span><br><span class="line">                  w++;</span><br><span class="line">              &#125;else if(a[w]&#x3D;&#x3D;&#39;篮&#39;)&#123;</span><br><span class="line">                  char m&#x3D;a[w];</span><br><span class="line">                  a[w]&#x3D;a[b];</span><br><span class="line">                  a[b]&#x3D;m;</span><br><span class="line">                  w++;</span><br><span class="line">                  b++;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;else if(a[w]&#x3D;&#x3D;&#39;红&#39;)&#123;</span><br><span class="line">                  char m&#x3D;a[w];</span><br><span class="line">                  a[w]&#x3D;a[r];</span><br><span class="line">                  a[r]&#x3D;m;</span><br><span class="line">                  r--;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          for(int i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">              System.out.print(a[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.print(&quot;共交换了&quot;+count+&quot;次&quot;);                 </span><br><span class="line"> &#125;</span><br><span class="line">        cin.close();      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>TCP和UDP详解</title>
    <url>/2020/04/08/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="success"></p>
<a id="more"></a>

<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="success"></p>
<h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层为运行在不同主机上的<strong>进程</strong>之间提供逻辑通信（网络层提供了主机之间的通信，即使网络层之间的通信时不可靠的，（分组丢失、混乱、重复），传输层同样也能为应用程序提供可靠的服务）。</p>
<p>传输层与应用层存在于主机的协议栈中，而不是路由器的通信子网中。（其实只要理解了传输层在是不同主机上的进程之间进行通信，就都好理解了。）</p>
<h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><ol>
<li><p>传输层提供应用<strong>进程</strong>之间的逻辑通信（即端到端的通信）。（逻辑通信：传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间没有一条水平方向的物理连接）。</p>
</li>
<li><p>传输层的复用和分用。</p>
<p>复用：发送方不同的应用进程都可以使用同一个传输层协议传送数据。</p>
<p>分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</p>
</li>
<li><p>传输层对收到的报文进行差错检测（首部和数据部分）。（网络层只检查IP数据报的部分）。</p>
</li>
<li><p>提供两种不同的传输协议。网络层无法同时存在这两种形式（要么提供无连接服务，要么提供面向连接的服务）。</p>
</li>
</ol>
<h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3><p>​        端口的作用：让应用层的各种应用进程将其数据通过端口号向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><ol>
<li>服务端使用的端口号<ul>
<li>熟知端口号0～1023</li>
<li>登记端口号1024～49151</li>
</ul>
</li>
<li>客户端使用的端口号49152～65535</li>
</ol>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>​        套接字=（主机IP地址，端口号）</p>
<p>​        唯一的标识了网络中的一个主机和其上的一个应用（进程）。</p>
<h3 id="无连接服务与面向连接的服务"><a href="#无连接服务与面向连接的服务" class="headerlink" title="无连接服务与面向连接的服务"></a>无连接服务与面向连接的服务</h3><p>​        面向连接的服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和监管。当通信结束，则应该释放这个连接。</p>
<p>​        无连接服务，两个实体之间的通信不需要先建立好连接，需要通信的时候，直接将信息发送到网络中，让该信息的传递早在网上尽力而为地往目的地传送。</p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3><h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><p>​        UDP只在IP的数据报服务之上增加了两个最基本的服务：复用和差错检查。常用于一次性传输比较少量数据的网络应用，如DNS、SNMP等。</p>
<p>​        UDP提供尽最大努力的交付，既不保证可靠交付，维护传输数据可靠性的工作需要用户在应用层完成。</p>
<p>​        UDP是面向报文的，直接将应用层交下来的报文交付给IP层。</p>
<ol>
<li>UDP无需建立连接（不会引入建立连接的时延）.</li>
<li>无连接状态(不维护连接状态)。</li>
<li>分组首部开销小（TCP20字节首部开销，UDP8字节）。</li>
<li>应用层能更好的控制要发送的数据和发送时间（没有拥塞控制）。</li>
</ol>
<p>UDP首部格式</p>
<p>​        8个字节，4个字段，每个字段2个字节</p>
<ul>
<li>源端口</li>
<li>目的端口</li>
<li>长度</li>
<li>校验和</li>
</ul>
<h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><p>​        计算校验和时，要在UDP数据之前增加12个字节的伪首部。既检查UDP数据报，又检查IP数据报的源IP地址和目的IP地址进行了校验。</p>
<p>校验方法：二进制反码运算求和再取反。</p>
<ol>
<li>校验时，若UDP数据报部分的长度不是偶数个数字，则需要填入一个全0字节。和所有伪首部一样，均不发送。</li>
<li>如果UDP校验和校验出的UDP数据报是错误的，可以丢弃，也可以交付给上层，但是需要附上错误报告。</li>
<li>通过伪首部，不仅可以检查端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。</li>
</ol>
<p>UDP检错能力不强，但处理速度快。</p>
<h2 id="TCP协议原理"><a href="#TCP协议原理" class="headerlink" title="TCP协议原理"></a>TCP协议原理</h2><p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/1.png" alt="success"></p>
<ul>
<li>TCP是一种精致的，可靠的字节流协议。</li>
<li>在TCP编程中，三路握手一般由客户端（Client）调用Connent函数发起。</li>
<li>TCP三次握手后数据收发通道即打开（即建立了连接）。</li>
</ul>
<h3 id="ack机制"><a href="#ack机制" class="headerlink" title="ack机制"></a>ack机制</h3><p>​        由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。<br>​        这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ack（回执）。如果发送方没接收到正确的ack，就会重新发送数据直到接收到ack为止。<br> 比如：发送方发送的数据序号是seq，那么接收方会发送ack=seq + 1，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。</p>
<h3 id="Tcp三次握手"><a href="#Tcp三次握手" class="headerlink" title="Tcp三次握手"></a>Tcp三次握手</h3><ul>
<li>SYN = 1，同步序列编号（即握手信号），SYN占用一个码位字段。</li>
<li>ACK = 1，确认字符，ACK占用一个码位字段。</li>
<li>seq:起始序号，即报文段首字节序号，给报文段首字节序号设置一个逻辑地址。</li>
<li>ack确认字段，值为下一次发送的报文段首字节序号，TCP将从ack数值指向的字节的逻辑位置开始传输。</li>
</ul>
<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/Tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="success"></p>
<ol>
<li><p>第一次握手</p>
<p>​        Client端的TCP向Server端的TCP发送一个连接请求报文段（不含应用层数据），将首部中的SYN标志位置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手</p>
<p>​        Server的TCP收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个起始序号seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手</p>
<p>​        Client收到确认报文段后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>​        在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<p>​        使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>​        所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>
<ul>
<li>FIN = 1，发送方字节流结束，FIN代表一个码位字段。</li>
<li>ACK = 1，确认字符，ACK占用一个码位字段。</li>
<li>seq，（结束）随机序列号 ，给报文段尾字节序号设置一个逻辑地址。</li>
<li>ack ，值为最后一次发送的报文段尾字节序号，TCP将从ack数值指向的字节的逻辑位置开结束传输。 </li>
</ul>
<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/Tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="success"></p>
<ol>
<li><p>第一次挥手</p>
<p>Client的TCP向Server的TCP发送一个连接释放报文段，首部中的FIN标志位被置为 1 ，seq = J，等于前面已经传送过的数据的最后一个字节的序号加 1 。Client进入FIN_WAIT_1状态，Client的TCP停止发送数据，（但仍然可以接收对方发送的数据，对方也可以发送数据）。</p>
</li>
<li><p>第二次挥手</p>
<p>Server的TCP收到连接释放报文段后，即发送确定报文给Client的TCP，报文的ACK标志位被置为 1 ，确认序号为收到序号加 1（seq = J + 1），Server进入CLOSE_WAIT状态，客户机到服务器方向的连接释放了，TCP连接处于半关闭状态。此时服务器仍可以向客户机发送数据。</p>
</li>
<li><p>第三次挥手</p>
<p>若服务器没有要向客户机发送的数据，Server的TCP发送一个FIN = 1 的连接释放报文，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手</p>
<p>客户机收到连接释放报文段后，必须发出确认。在确认报文段，ACK标志位被置为 1 ，Client进入TIME_WAIT状态，确认序号为收到序号加 1（seq = K + 1），Server进入CLOSED状态，完成四次挥手。</p>
</li>
</ol>
<h3 id="TCP连接建立和释放总结"><a href="#TCP连接建立和释放总结" class="headerlink" title="TCP连接建立和释放总结"></a>TCP连接建立和释放总结</h3><ul>
<li><p>连接建立</p>
<ol>
<li>SYN = 1，seq = x。</li>
<li>SYN = 1， ACK = 1，seq = y ，ack = x + 1。</li>
<li>ACK = 1，seq = x + 1， ack = y + 1。</li>
</ol>
</li>
<li><p>释放连接</p>
<ol>
<li>FIN = 1，seq = u。</li>
<li>ACK = 1，seq = v，ack = u + 1。</li>
<li>FIN = 1，ACK = 1，seq = w，ack = u +1。</li>
<li>ACK = 1，seq = u + 1，ack = w + 1。</li>
</ol>
<p>简化助记</p>
<p>TCP是全双工的，即可以想象成是一条TCP连接上有两条数据通路。</p>
<p>三次握手——C端请求连接，S端答应的同时请求连接，C端答应连接</p>
<p>四次挥手——C端主动关闭连接并通知S端，S端回复确认，TCP连接半关闭。S端主动关闭连接并通知C端，C端回复确认，TCP连接关闭。</p>
<p>（区别在于建立连接时是双向的必须得到另一端的同意，关闭连接的一端是单向的，只需要通知对方。）</p>
<p><strong>ACK，SYN，FIN = 1</strong></p>
<p>若为请求连接报文段，SYN字段置为 1 。</p>
<p>若为连接释放报文段，FIN字段置为 1 。</p>
<p>若为需要发回确认，ACK字段置为 1 。</p>
<p>seq 报文随机序号，设置一个逻辑地址。</p>
<p>ack确认号，为上一条seq加 1 ，将从ack数值指向的位置开始/结束接收数据（传输需要偏移量帮助）。</p>
</li>
</ul>
<h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><p>TCP把数据看成一个无结构但是有序的字节流，序号建立在字节流之上，而不是建立再报文段之上。</p>
<p>TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</p>
<h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储那些已经发送但未收到确认的报文段，以便在需要的时候重传。</p>
<h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><ol>
<li>超时</li>
<li>冗余</li>
</ol>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3>]]></content>
  </entry>
  <entry>
    <title>POM 标签大全详解</title>
    <url>/2020/04/05/POM-%E6%A0%87%E7%AD%BE%E5%A4%A7%E5%85%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>POM 标签大全详解</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">​                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">​            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">​        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">​            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">​        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">​                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">​                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">​                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">​                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                            ......</span><br><span class="line">​                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                        ......</span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">​                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">​                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">​                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                                    ......</span><br><span class="line">​                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">​                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                                ......</span><br><span class="line">​                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">​                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                    ......</span><br><span class="line">​                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">​                ......</span><br><span class="line">​            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">​                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                        ......</span><br><span class="line">​                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">​                ......</span><br><span class="line">​            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">​                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">​                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">​                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">​            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">​            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">​                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">​            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">​        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">​            ......</span><br><span class="line">​        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">            尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">            JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">     Path: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">         ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                 ......</span><br><span class="line">             <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                 scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">             <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">             Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>java中的四种引用（强、弱、软、虚）和GC的关系</title>
    <url>/2020/03/31/java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%88%E5%BC%BA%E3%80%81%E5%BC%B1%E3%80%81%E8%BD%AF%E3%80%81%E8%99%9A%EF%BC%89%E5%92%8CGC%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>转自：<a href="https://blog.csdn.net/qq_35580883/article/details/78698509" target="_blank" rel="noopener">https://blog.csdn.net/qq_35580883/article/details/78698509</a></p>
<a id="more"></a>

<h2 id="强引用Strong-References"><a href="#强引用Strong-References" class="headerlink" title="强引用Strong References"></a>强引用Strong References</h2><p>　　强引用是最常见的引用：</p>
<p>　　比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure>

<p>　　创建了一个StringBuffer类的对象，并用一个变量buffer存储对这个对象的引用。这就是个强引用。</p>
<p>　　变量持有的是这个对象的引用。通常，引用是一个对象的存储地址。</p>
<p>　　<strong>Java不像C或者C++一样，Java没有取地址符号&amp;，也没有解引用符号*或者-&gt;。</strong></p>
<p>　　<strong>引用不同于指针，引用不能与整形进行互相转换，也不能进行增减操作。</strong>　</p>
<p>　　<strong>强引用是和垃圾回收机制相关的。</strong></p>
<p>　　一般的，如果一个对象可以通过一系列的强引用引用到，那么就说明它是不会被垃圾回收机制（<strong>Garbage Collection</strong>）回收的。</p>
<p>　　因为垃圾回收是不会回收你正在使用的对象的。</p>
<h2 id="垃圾回收机制Garbage-Collection"><a href="#垃圾回收机制Garbage-Collection" class="headerlink" title="垃圾回收机制Garbage Collection"></a>垃圾回收机制Garbage Collection</h2><p>　　<strong>如果一个对象，没有一个引用指向它，那么它就被认为是一个垃圾。</strong></p>
<p>　　An object is considered garbage when there are no longer any references to it stored in any variables, the fields of any objects, or the elements of any arrays.</p>
<p>　　在某一个时间，garbage collector将会发现成为垃圾的对象，然后回收它所占用的内存。</p>
<h2 id="什么时候强引用会太强了？"><a href="#什么时候强引用会太强了？" class="headerlink" title="什么时候强引用会太强了？"></a>什么时候强引用会太强了？</h2><p>　　有时候应用会使用一些不能被继承的类，比如一个final的类，或者一个工厂方法返回的接口，并不知道有多少具体实现。</p>
<p>　　而我们想给这个类增加一个字段，比如给每一个对象一个序列号，于是我们用了<strong>HashMap</strong>，把这个类的对象作为key，一个序列号作为value。</p>
<p>　　这时候我们就必须100%确定地知道一个特定对象的序列号什么时候不再需要（比如对象的生命周期已经结束，就不再需要它的序列号属性），这样我们就可以从map中移除它的entry。 </p>
<p>　　如果我们在应当移除引用的时候没有移除，垃圾回收将一直不会回收这个对象，引起内存泄露。</p>
<p>　　而如果我们过早地移除了我们还在使用的对象的引用，又会发现自己丢失了信息。</p>
<p>　　强引用另一个常见的问题是缓存问题。</p>
<p>　　比方说，图像的缓存。图像缓存应当阻止我们重复载入图像。</p>
<p>　　所以图像缓存保存有内存中已有的所有图像的引用，<strong><em>\</em>如果使用通常的强引用，强引用本身会使得图像一直存留在内存中**</strong>，这样就使得程序员像上面一样，必须自己决定什么时候移除缓存中的引用，这样对象才能被垃圾回收机制回收。</p>
<p>　　这样你就又放弃了让GC自己管理垃圾回收的机制，而开始手动地管理内存。</p>
<h2 id="引用对象类"><a href="#引用对象类" class="headerlink" title="引用对象类"></a>引用对象类</h2><p>　　Java的引用对象类在包java.lang.ref下。</p>
<p>　　<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html#package_description" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html#package_description</a></p>
<p> 　　其中包含了三种显式的引用类型（也即是Reference类的三个子类）：</p>
<p>　　<strong>SoftReference</strong></p>
<p>　　<strong>WeakReference</strong></p>
<p>　　<strong>PhantomReference</strong></p>
<p>　　一个引用对象（reference object）（即以上三种引用类型的对象）封装了一个对其他对象的引用（称作<strong>referent</strong>）。</p>
<p>　　引用对象提供了对referent的clean和get操作，但是不提供set操作。</p>
<p>　　引用对象本身可以像其他一般的对象一样被检查和操纵。</p>
<p>　　<strong>三种类型的引用定义了三种不同层次的可达性级别，由强到弱排列如下：</strong></p>
<p>　　<strong>SoftReference &gt;***</strong>*WeakReference &gt;*<em>*</em>PhantomReference****</p>
<p>　　越弱表示对垃圾回收器的限制越少，对象越容易被回收。</p>
<h2 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h2><p>　　<strong>SoftReference</strong>用来实现一些内存敏感的缓存(Soft references are for implementing memory-sensitive caches)，只要内存空间足够，对象就会保持不被回收。</p>
<p>　　反之，当宿主进程的内存空间不足时，对象就会被GC回收。</p>
<p>　　所以SoftReference意味着：<strong>hold on until you can’t.</strong></p>
<h2 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h2><p>　　<strong>WeakReference</strong>可以用来实现一些规范化映射（<strong>WeakHashMap</strong>），其中key或者value当它们不再被引用时可以自动被回收。</p>
<p>　　当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p>
<p>　　这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</p>
<h2 id="虚引用PlantomReference"><a href="#虚引用PlantomReference" class="headerlink" title="虚引用PlantomReference"></a>虚引用PlantomReference</h2><p>　　<strong>PlantomReference</strong>和WeakReference一样，也不会介入引用对象的生命周期。</p>
<p>　　PhantomReference用来调度一些预验清理动作，提供比Java清理机制更灵活的处理方式。（Phantom references are for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism.）</p>
<p>　　PlantomReference比较特殊，它的get方法总是返回null，所以你得不到它引用的对象。</p>
<p>　　它保存<strong>ReferenceQueue</strong>中的轨迹。</p>
<p>　　它允许你知道对象何时从内存中移除。</p>
<p>示例，来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"sub"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Sub</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(Sub sub)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"parent"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        ReferenceQueue&lt;Parent&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;Parent&gt;();</span><br><span class="line">        WeakReference&lt;Parent&gt; wr = <span class="keyword">new</span> WeakReference&lt;Parent&gt;(<span class="keyword">new</span> Parent(sub),rq);</span><br><span class="line"><span class="comment">//        Parent wr = new Parent(sub);</span></span><br><span class="line">        sub = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(wr.get());<span class="comment">//null 因为被gc了</span></span><br><span class="line">        System.out.println((WeakReference&lt;Parent&gt;)rq.poll());<span class="comment">//java.lang.ref.WeakReference@15db9742</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有一个类Parent，有一个子类Sub，现在如果我们这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">Parent parent = <span class="keyword">new</span> Parent(sub);</span><br></pre></td></tr></table></figure>

<p>那这就是强引用，当我们写到</p>
<p>sub = null;<br>System.gc();</p>
<p>这样sub再去访问sub自然是null，但是sub指向的堆空间的对象是null吗，parent指向的堆空间的对象是null吗？不是的，想要parent也被gc怎么办呢？我们在sub=null;后面加上：</p>
<p>parent = null，sub指向的堆空间和parent指向的堆空间就会因为不可达而被gc。</p>
<p>那弱引用是怎么回事呢？</p>
<p>和上方代码一样，先创建一个引用队列ReferenceQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue&lt;Parent&gt; rq = <span class="keyword">new</span> ReferenceQueue rq&lt;Parent&gt;();</span><br></pre></td></tr></table></figure>

<p>再创建一个弱引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;Parent&gt; wr = <span class="keyword">new</span> WeakReference&lt;Parent&gt;(<span class="keyword">new</span> Parent(sub),rq);</span><br></pre></td></tr></table></figure>

<p>当sub=null时，弱引用就会被gc，然后出现在引用队列，所以rq.poll()就可以获取到已经被gc的弱引用类型。</p>
<p>那为什么这里wr会被gc呢？因为当sub=null时，sub之前指向的堆里的对象就只被一个弱引用wr依赖了，然而弱引用wr没有被引用，因此wr被gc，被wr依赖的sub之前指向的堆对象也被gc。这就是弱引用的好处，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。</p>
<p>最后附上一张图，四种引用与gc的关系：</p>
<p><img src="https://img-blog.csdn.net/20171203111540378?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU1ODA4ODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>彻底理解Android应用无响应机制</title>
    <url>/2020/03/31/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%E5%BA%94%E7%94%A8%E6%97%A0%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>转载自<a href="http://gityuan.com/2019/04/06/android-anr/" target="_blank" rel="noopener">http://gityuan.com/2019/04/06/android-anr/</a></p>
<a id="more"></a>

<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>不论从事安卓应用开发，还是安卓系统研发，应该都遇到应用无响应（ANR，Application Not Responding）问题，当应用程序一段时间无法及时响应，则会弹出ANR对话框，让用户选择继续等待，还是强制关闭。</p>
<p>绝大多数人对ANR的了解仅停留在主线程耗时或CPU繁忙会导致ANR。面试过无数的候选人，几乎没有人能真正从系统级去梳理清晰ANR的来龙去脉，比如有哪些路径会引发ANR? 有没有可能主线程不耗时也出现ANR？如何更好的调试ANR?</p>
<p>如果没有深入研究过Android Framework的源代码，是难以形成对ANR有一个全面、正确的理解。研究系统源码以及工作实践后提炼而来，以图文并茂的方式跟大家讲解，相信定能帮忙大家加深对ANR的理解。</p>
<h3 id="ANR触发机制"><a href="#ANR触发机制" class="headerlink" title="ANR触发机制"></a>ANR触发机制</h3><p>对于知识学习的过程，要知其然知其所以然，才能做到庖丁解牛般游刃有余。要深入理解ANR，就需要从根上去找寻答案，那就是ANR是如何触发的？</p>
<p>ANR是一套监控Android应用响应是否及时的机制，可以把发生ANR比作是引爆炸弹，那么整个流程包含三部分组成：</p>
<ol>
<li>埋定时炸弹：中控系统(system_server进程)启动倒计时，在规定时间内如果目标(应用进程)没有干完所有的活，则中控系统会定向炸毁(杀进程)目标。</li>
<li>拆炸弹：在规定的时间内干完工地的所有活，并及时向中控系统报告完成，请求解除定时炸弹，则幸免于难。</li>
<li>引爆炸弹：中控系统立即封装现场，抓取快照，搜集目标执行慢的罪证(traces)，便于后续的案件侦破(调试分析)，最后是炸毁目标。</li>
</ol>
<p>常见的ANR有service、broadcast、provider以及input，更多细节详见理解Android ANR的触发原理，<a href="http://gityuan.com/2016/07/02/android-anr，接下来本文以图文形式分别讲解。" target="_blank" rel="noopener">http://gityuan.com/2016/07/02/android-anr，接下来本文以图文形式分别讲解。</a></p>
<h4 id="service超时机制"><a href="#service超时机制" class="headerlink" title="service超时机制"></a>service超时机制</h4><p>下面来看看埋炸弹与拆炸弹在整个服务启动(startService)过程所处的环节。</p>
<p><img src="http://gityuan.com/images/android-anr/service_anr.jpg" alt="service_anr"></p>
<p>图解1：</p>
<ol>
<li>客户端(App进程)向中控系统(system_server进程)发起启动服务的请求</li>
<li>中控系统派出一名空闲的通信员(binder_1线程)接收该请求，紧接着向组件管家(ActivityManager线程)发送消息，埋下定时炸弹</li>
<li>通讯员1号(binder_1)通知工地(service所在进程)的通信员准备开始干活</li>
<li>通讯员3号(binder_3)收到任务后转交给包工头(main主线程)，加入包工头的任务队列(MessageQueue)</li>
<li>包工头经过一番努力干完活(完成service启动的生命周期)，然后等待SharedPreferences(简称SP)的持久化；</li>
<li>包工头在SP执行完成后，立刻向中控系统汇报工作已完成</li>
<li>中控系统的通讯员2号(binder_2)收到包工头的完工汇报后，立刻拆除炸弹。如果在炸弹倒计时结束前拆除炸弹则相安无事，否则会引发爆炸(触发ANR)</li>
</ol>
<p>更多细节详见startService启动过程分析，<a href="http://gityuan.com/2016/03/06/start-service" target="_blank" rel="noopener">http://gityuan.com/2016/03/06/start-service</a></p>
<h4 id="broadcast超时机制"><a href="#broadcast超时机制" class="headerlink" title="broadcast超时机制"></a>broadcast超时机制</h4><p>broadcast跟service超时机制大抵相同，对于静态注册的广播在超时检测过程需要检测SP，如下图所示。</p>
<p><img src="http://gityuan.com/images/android-anr/broadcast_anr.jpg" alt="broadcast_anr"></p>
<p>图解2：</p>
<ol>
<li>客户端(App进程)向中控系统(system_server进程)发起发送广播的请求</li>
<li>中控系统派出一名空闲的通信员(binder_1)接收该请求转交给组件管家(ActivityManager线程)</li>
<li>组件管家执行任务(processNextBroadcast方法)的过程埋下定时炸弹</li>
<li>组件管家通知工地(receiver所在进程)的通信员准备开始干活</li>
<li>通讯员3号(binder_3)收到任务后转交给包工头(main主线程)，加入包工头的任务队列(MessageQueue)</li>
<li>包工头经过一番努力干完活(完成receiver启动的生命周期)，发现当前进程还有SP正在执行写入文件的操作，便将向中控系统汇报的任务交给SP工人(queued-work-looper线程)</li>
<li>SP工人历经艰辛终于完成SP数据的持久化工作，便可以向中控系统汇报工作完成</li>
<li>中控系统的通讯员2号(binder_2)收到包工头的完工汇报后，立刻拆除炸弹。如果在倒计时结束前拆除炸弹则相安无事，否则会引发爆炸(触发ANR)</li>
</ol>
<p>（说明：SP从8.0开始采用名叫“queued-work-looper”的handler线程，在老版本采用newSingleThreadExecutor创建的单线程的线程池）</p>
<p>如果是动态广播，或者静态广播没有正在执行持久化操作的SP任务，则不需要经过“queued-work-looper”线程中转，而是直接向中控系统汇报，流程更为简单，如下图所示：</p>
<p><img src="http://gityuan.com/images/android-anr/broadcast_anr_2.jpg" alt="broadcast_anr_2"></p>
<p>可见，只有XML静态注册的广播超时检测过程会考虑是否有SP尚未完成，动态广播并不受其影响。SP的apply将修改的数据项更新到内存，然后再异步同步数据到磁盘文件，因此很多地方会推荐在主线程调用采用apply方式，避免阻塞主线程，但静态广播超时检测过程需要SP全部持久化到磁盘，如果过度使用apply会增大应用ANR的概率，更多细节详见<a href="http://gityuan.com/2017/06/18/SharedPreferences" target="_blank" rel="noopener">http://gityuan.com/2017/06/18/SharedPreferences</a></p>
<p>Google这样设计的初衷是针对静态广播的场景下，保障进程被杀之前一定能完成SP的数据持久化。因为在向中控系统汇报广播接收者工作执行完成前，该进程的优先级为Foreground级别，高优先级下进程不但不会被杀，而且能分配到更多的CPU时间片，加速完成SP持久化。</p>
<p>更多细节详见Android Broadcast广播机制分析，<a href="http://gityuan.com/2016/06/04/broadcast-receiver" target="_blank" rel="noopener">http://gityuan.com/2016/06/04/broadcast-receiver</a></p>
<h4 id="provider超时机制"><a href="#provider超时机制" class="headerlink" title="provider超时机制"></a>provider超时机制</h4><p>provider的超时是在provider进程首次启动的时候才会检测，当provider进程已启动的场景，再次请求provider并不会触发provider超时。</p>
<p><img src="http://gityuan.com/images/android-anr/provider_anr.jpg" alt="provider_anr"></p>
<p>图解3：</p>
<ol>
<li>客户端(App进程)向中控系统(system_server进程)发起获取内容提供者的请求</li>
<li>中控系统派出一名空闲的通信员(binder_1)接收该请求，检测到内容提供者尚未启动，则先通过zygote孵化新进程</li>
<li>新孵化的provider进程向中控系统注册自己的存在</li>
<li>中控系统的通信员2号接收到该信息后，向组件管家(ActivityManager线程)发送消息，埋下炸弹</li>
<li>通信员2号通知工地(provider进程)的通信员准备开始干活</li>
<li>通讯员4号(binder_4)收到任务后转交给包工头(main主线程)，加入包工头的任务队列(MessageQueue)</li>
<li>包工头经过一番努力干完活(完成provider的安装工作)后向中控系统汇报工作已完成</li>
<li>中控系统的通讯员3号(binder_3)收到包工头的完工汇报后，立刻拆除炸弹。如果在倒计时结束前拆除炸弹则相安无事，否则会引发爆炸(触发ANR)</li>
</ol>
<p>更多细节详见理解ContentProvider原理，<a href="http://gityuan.com/2016/07/30/content-provider" target="_blank" rel="noopener">http://gityuan.com/2016/07/30/content-provider</a></p>
<h4 id="input超时机制"><a href="#input超时机制" class="headerlink" title="input超时机制"></a>input超时机制</h4><p>input的超时检测机制跟service、broadcast、provider截然不同，为了更好的理解input过程先来介绍两个重要线程的相关工作：</p>
<ul>
<li>InputReader线程负责通过EventHub(监听目录/dev/input)读取输入事件，一旦监听到输入事件则放入到InputDispatcher的mInBoundQueue队列，并通知其处理该事件；</li>
<li>InputDispatcher线程负责将接收到的输入事件分发给目标应用窗口，分发过程使用到3个事件队列：<ul>
<li>mInBoundQueue用于记录InputReader发送过来的输入事件；</li>
<li>outBoundQueue用于记录即将分发给目标应用窗口的输入事件；</li>
<li>waitQueue用于记录已分发给目标应用，且应用尚未处理完成的输入事件；</li>
</ul>
</li>
</ul>
<p>input的超时机制并非时间到了一定就会爆炸，而是处理后续上报事件的过程才会去检测是否该爆炸，所以更像是扫雷的过程，具体如下图所示。</p>
<p><img src="http://gityuan.com/images/android-anr/input_anr.jpg" alt="input_anr"></p>
<p>图解4：</p>
<ol>
<li>InputReader线程通过EventHub监听底层上报的输入事件，一旦收到输入事件则将其放至mInBoundQueue队列，并唤醒InputDispatcher线程</li>
<li>InputDispatcher开始分发输入事件，设置埋雷的起点时间。先检测是否有正在处理的事件(mPendingEvent)，如果没有则取出mInBoundQueue队头的事件，并将其赋值给mPendingEvent，且重置ANR的timeout；否则不会从mInBoundQueue中取出事件，也不会重置timeout。然后检查窗口是否就绪(checkWindowReadyForMoreInputLocked)，满足以下任一情况，则会进入扫雷状态(检测前一个正在处理的事件是否超时)，终止本轮事件分发，否则继续执行步骤3。<ul>
<li>对于按键类型的输入事件，则outboundQueue或者waitQueue不为空，</li>
<li>对于非按键的输入事件，则waitQueue不为空，且等待队头时间超时500ms</li>
</ul>
</li>
<li>当应用窗口准备就绪，则将mPendingEvent转移到outBoundQueue队列</li>
<li>当outBoundQueue不为空，且应用管道对端连接状态正常，则将数据从outboundQueue中取出事件，放入waitQueue队列</li>
<li>InputDispatcher通过socket告知目标应用所在进程可以准备开始干活</li>
<li>App在初始化时默认已创建跟中控系统双向通信的socketpair，此时App的包工头(main线程)收到输入事件后，会层层转发到目标窗口来处理</li>
<li>包工头完成工作后，会通过socket向中控系统汇报工作完成，则中控系统会将该事件从waitQueue队列中移除。</li>
</ol>
<p>input超时机制为什么是扫雷，而非定时爆炸呢？是由于对于input来说即便某次事件执行时间超过timeout时长，只要用户后续在没有再生成输入事件，则不会触发ANR。 这里的扫雷是指当前输入系统中正在处理着某个耗时事件的前提下，后续的每一次input事件都会检测前一个正在处理的事件是否超时（进入扫雷状态），检测当前的时间距离上次输入事件分发时间点是否超过timeout时长。如果前一个输入事件，则会重置ANR的timeout，从而不会爆炸。</p>
<p>更多细节详见Input系统-ANR原理分析，<a href="http://gityuan.com/2017/01/01/input-anr" target="_blank" rel="noopener">http://gityuan.com/2017/01/01/input-anr</a></p>
<h3 id="ANR超时阈值"><a href="#ANR超时阈值" class="headerlink" title="ANR超时阈值"></a>ANR超时阈值</h3><p>不同组件的超时阈值各有不同，关于service、broadcast、contentprovider以及input的超时阈值如下表：</p>
<p><img src="http://gityuan.com/images/android-anr/anr_timeout.jpg" alt="anr_timeout"></p>
<h4 id="前台与后台服务的区别"><a href="#前台与后台服务的区别" class="headerlink" title="前台与后台服务的区别"></a>前台与后台服务的区别</h4><p>系统对前台服务启动的超时为20s，而后台服务超时为200s，那么系统是如何区别前台还是后台服务呢？来看看ActiveServices的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在startService过程根据发起方进程callerApp所属的进程调度组来决定被启动的服务是属于前台还是后台。当发起方进程不等于ProcessList.SCHED_GROUP_BACKGROUND(后台进程组)则认为是前台服务，否则为后台服务，并标记在ServiceRecord的成员变量createdFromFg。</p>
<p>什么进程属于SCHED_GROUP_BACKGROUND调度组呢？进程调度组大体可分为TOP、前台、后台，进程优先级（Adj）和进程调度组（SCHED_GROUP）算法较为复杂，其对应关系可粗略理解为Adj等于0的进程属于Top进程组，Adj等于100或者200的进程属于前台进程组，Adj大于200的进程属于后台进程组。关于Adj的含义见下表，简单来说就是Adj&gt;200的进程对用户来说基本是无感知，主要是做一些后台工作，故后台服务拥有更长的超时阈值，同时后台服务属于后台进程调度组，相比前台服务属于前台进程调度组，分配更少的CPU时间片。</p>
<p><img src="http://gityuan.com/images/android-anr/adj.png" alt="adj"></p>
<p>关于细节详见解读Android进程优先级ADJ算法，<a href="http://gityuan.com/2018/05/19/android-process-adj" target="_blank" rel="noopener">http://gityuan.com/2018/05/19/android-process-adj</a></p>
<p><code>前台服务准确来说，是指由处于前台进程调度组的进程发起的服务</code>。这跟常说的fg-service服务有所不同，fg-service是指挂有前台通知的服务。</p>
<h4 id="前台与后台广播超时"><a href="#前台与后台广播超时" class="headerlink" title="前台与后台广播超时"></a>前台与后台广播超时</h4><p>前台广播超时为10s，后台广播超时为60s，那么如何区分前台和后台广播呢？来看看AMS的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>根据发送广播sendBroadcast(Intent intent)中的intent的flags是否包含FLAG_RECEIVER_FOREGROUND来决定把该广播是放入前台广播队列或者后台广播队列，前台广播队列的超时为10s，后台广播队列的超时为60s，默认情况下广播是放入后台广播队列，除非指明加上FLAG_RECEIVER_FOREGROUND标识。</p>
<p>后台广播比前台广播拥有更长的超时阈值，同时在广播分发过程遇到后台service的启动(mDelayBehindServices)会延迟分发广播，等待service的完成，因为等待service而导致的广播ANR会被忽略掉；后台广播属于后台进程调度组，而前台广播属于前台进程调度组。简而言之，后台广播更不容易发生ANR，同时执行的速度也会更慢。</p>
<p>另外，只有串行处理的广播才有超时机制，因为接收者是串行处理的，前一个receiver处理慢，会影响后一个receiver；并行广播通过一个循环一次性向所有的receiver分发广播事件，所以不存在彼此影响的问题，则没有广播超时。</p>
<p><code>前台广播准确来说，是指位于前台广播队列的广播</code>。</p>
<h4 id="前台与后台ANR"><a href="#前台与后台ANR" class="headerlink" title="前台与后台ANR"></a>前台与后台ANR</h4><p>除了前台服务，前台广播，还有前台ANR可能会让你云里雾里的，来看看其中核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">appNotResponding</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        isSilentANR = !showBackground &amp;&amp; !isInterestingForBackgroundTraces(app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    File tracesFile = ActivityManagerService.dumpStackTraces(</span><br><span class="line">            <span class="keyword">true</span>, firstPids,</span><br><span class="line">            (isSilentANR) ? <span class="keyword">null</span> : processCpuTracker,</span><br><span class="line">            (isSilentANR) ? <span class="keyword">null</span> : lastPids,</span><br><span class="line">            nativePids);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSilentANR) &#123;</span><br><span class="line">            app.kill(<span class="string">"bg anr"</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出ANR选择的对话框</span></span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">        msg.obj = <span class="keyword">new</span> AppNotRespondingDialog.Data(app, activity, aboveSystem);</span><br><span class="line">        mService.mUiHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>决定是前台或者后台ANR取决于该应用发生ANR时对用户是否可感知，比如拥有当前前台可见的activity的进程，或者拥有前台通知的fg-service的进程，这些是用户可感知的场景，发生ANR对用户体验影响比较大，故需要弹框让用户决定是否退出还是等待，如果直接杀掉这类应用会给用户造成莫名其妙的闪退。</p>
<p>后台ANR相比前台ANR，只抓取发生无响应进程的trace，也不会收集CPU信息，并且会在后台直接杀掉该无响应的进程，不会弹框提示用户。</p>
<p><code>前台ANR准确来说，是指对用户可感知的进程发生的ANR</code>。</p>
<h3 id="ANR爆炸现场"><a href="#ANR爆炸现场" class="headerlink" title="ANR爆炸现场"></a>ANR爆炸现场</h3><p>对于service、broadcast、provider、input发生ANR后，中控系统会马上去抓取现场的信息，用于调试分析。收集的信息包括如下：</p>
<ul>
<li>将am_anr信息输出到EventLog，也就是说ANR触发的时间点最接近的就是EventLog中输出的am_anr信息</li>
<li>收集以下重要进程的各个线程调用栈trace信息，保存在data/anr/traces.txt文件<ul>
<li>当前发生ANR的进程，system_server进程以及所有persistent进程</li>
<li>audioserver, cameraserver, mediaserver, surfaceflinger等重要的native进程</li>
<li>CPU使用率排名前5的进程</li>
</ul>
</li>
<li>将发生ANR的reason以及CPU使用情况信息输出到main log</li>
<li>将traces文件和CPU使用情况信息保存到dropbox，即data/system/dropbox目录</li>
<li>对用户可感知的进程则弹出ANR对话框告知用户，对用户不可感知的进程发生ANR则直接杀掉</li>
</ul>
<p>整个ANR信息收集过程比较耗时，其中抓取进程的trace信息，每抓取一个等待200ms，可见persistent越多，等待时间越长。关于抓取trace命令，对于Java进程可通过在adb shell环境下执行kill -3 [pid]可抓取相应pid的调用栈；对于Native进程在adb shell环境下执行debuggerd -b [pid]可抓取相应pid的调用栈。对于ANR问题发生后的蛛丝马迹(trace)在traces.txt和dropbox目录中保存记录。更多细节详见理解Android ANR的信息收集过程，<a href="http://gityuan.com/2016/12/02/app-not-response。" target="_blank" rel="noopener">http://gityuan.com/2016/12/02/app-not-response。</a></p>
<p>有了现场信息，可以调试分析，先定位发生ANR时间点，然后查看trace信息，接着分析是否有耗时的message、binder调用，锁的竞争，CPU资源的抢占，以及结合具体场景的上下文来分析，调试手段就需要针对前面说到的message、binder、锁等资源从系统角度细化更多debug信息，这里不再展开，后续再以ANR案例来讲解。</p>
<p>作为应用开发者应让主线程尽量只做UI相关的操作，避免耗时操作，比如过度复杂的UI绘制，网络操作，文件IO操作；避免主线程跟工作线程发生锁的竞争，减少系统耗时binder的调用，谨慎使用sharePreference，注意主线程执行provider query操作。简而言之，尽可能减少主线程的负载，让其空闲待命，以期可随时响应用户的操作。</p>
<h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><p>最后，来回答文章开头的提问，有哪些路径会引发ANR? 答应是从埋下定时炸弹到拆炸弹之间的任何一个或多个路径执行慢都会导致ANR（以service为例），可以是service的生命周期的回调方法(比如onStartCommand)执行慢，可以是主线程的消息队列存在其他耗时消息让service回调方法迟迟得不到执行，可以是SP操作执行慢，可以是system_server进程的binder线程繁忙而导致没有及时收到拆炸弹的指令。另外ActivityManager线程也可能阻塞，出现的现象就是前台服务执行时间有可能超过10s，但并不会出现ANR。</p>
<p>发生ANR时从trace来看主线程却处于空闲状态或者停留在非耗时代码的原因有哪些？可以是抓取trace过于耗时而错过现场，可以是主线程消息队列堆积大量消息而最后抓取快照一刻只是瞬时状态，可以是广播的“queued-work-looper”一直在处理SP操作。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android内存分析命令</title>
    <url>/2020/03/31/Android%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用的内存调优分析命令"><a href="#常用的内存调优分析命令" class="headerlink" title="常用的内存调优分析命令"></a>常用的内存调优分析命令</h2><ol>
<li>dumpsys meminfo</li>
<li>procrank</li>
<li>cat /proc/meminfo</li>
<li>free</li>
<li>showmap</li>
<li>vmstat</li>
</ol>
<a id="more"></a>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><code>dumpsys meminfo</code>适用场景： 查看进程的oom adj，或者dalvik/native等区域内存情况，或者某个进程或apk的内存情况，功能非常强大；</li>
<li><code>procrank</code>适用场景： 查看进程的VSS/RSS/PSS/USS各个内存指标；</li>
<li><code>cat /proc/meminfo</code>适用场景： 查看系统的详尽内存信息，包含内核情况；</li>
<li><code>free</code>适用场景： 只查看系统的可用内存；</li>
<li><code>showmap</code>适用场景： 查看进程的虚拟地址空间的内存分配情况；</li>
<li><code>vmstat</code>适用场景： 周期性地打印出进程运行队列、系统切换、CPU时间占比等情况；</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>详解KMP算法</title>
    <url>/2020/03/25/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>因为发现网上缺少kmp算法的详细解析，大多解析又是从数学角度解释kmp算法的原理，让人云里雾里看不明白，故有了这篇文章，主要对kmp算法难点求next[]数组的算法进行详细解析。</p>
<a id="more"></a>

<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/1.jpeg" alt="success"></p>
<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/2.jpeg" alt="success"></p>
<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/3.jpeg" alt="success"></p>
<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/4.jpeg" alt="success"></p>
]]></content>
  </entry>
  <entry>
    <title>算法分析步骤</title>
    <url>/2020/03/23/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<ol>
<li>首先说明采用哪些数据结构，分别做什么操作</li>
<li>对采用的数据结构中的变量、指针和参数加以说明</li>
<li>对程序整体的初始状态、运行状态、结束状态依次加以说明</li>
</ol>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
  </entry>
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <url>/2020/03/23/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的<strong>有序</strong>数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<a id="more"></a>

<p>示例 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0<br>示例 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / <span class="number">2</span></span><br><span class="line">        j = half_len - i</span><br><span class="line">        <span class="keyword">if</span> i &lt; m <span class="keyword">and</span> B[j<span class="number">-1</span>] &gt; A[i]:</span><br><span class="line">            <span class="comment"># i is too small, must increase it</span></span><br><span class="line">            imin = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] &gt; B[j]:</span><br><span class="line">            <span class="comment"># i is too big, must decrease it</span></span><br><span class="line">            imax = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># i is perfect</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: max_of_left = B[j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: max_of_left = A[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>: max_of_left = max(A[i<span class="number">-1</span>], B[j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> max_of_left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == m: min_of_right = B[j]</span><br><span class="line">            <span class="keyword">elif</span> j == n: min_of_right = A[i]</span><br><span class="line">            <span class="keyword">else</span>: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>​        O(log(min(m,n)))</p>
<p>​        首先，查找的区间是 [0, m]。而该区间的长度在每次循环之后都会减少为原来的一半。所以，我们只需要执行 log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m))。由于 m≤nm≤n，所以时间复杂度是 O(log(min(m,n)))。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>​        O(1)</p>
<p>​        我们只需要恒定的内存来存储 99 个局部变量， 所以空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>LeedCode</category>
      </categories>
  </entry>
  <entry>
    <title>Semaphore类源码探究</title>
    <url>/2020/03/23/Semaphore%E7%B1%BB%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>对java中Semaphore类的源码进行探究</p>
<a id="more"></a>

<!--more-->

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore.Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Semaphore.NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (Semaphore.Sync)(fair ? <span class="keyword">new</span> Semaphore.FairSync(permits) : <span class="keyword">new</span> Semaphore.NonfairSync(permits));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.sync.acquireSharedInterruptibly(permits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.sync.acquireShared(permits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sync.nonfairTryAcquireShared(permits) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.sync.releaseShared(permits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.getPermits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.drainPermits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reduction &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.sync.reducePermits(reduction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync <span class="keyword">instanceof</span> Semaphore.FairSync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.getQueueLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.getQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Permits = "</span> + <span class="keyword">this</span>.sync.getPermits() + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Semaphore</span>.<span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> available;</span><br><span class="line">            <span class="keyword">int</span> remaining;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.hasQueuedPredecessors()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                available = <span class="keyword">this</span>.getState();</span><br><span class="line">                remaining = available - acquires;</span><br><span class="line">            &#125; <span class="keyword">while</span>(remaining &gt;= <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.compareAndSetState(available, remaining));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Semaphore</span>.<span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> available;</span><br><span class="line">            <span class="keyword">int</span> remaining;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                available = <span class="keyword">this</span>.getState();</span><br><span class="line">                remaining = available - acquires;</span><br><span class="line">            &#125; <span class="keyword">while</span>(remaining &gt;= <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.compareAndSetState(available, remaining));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> current;</span><br><span class="line">            <span class="keyword">int</span> next;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                current = <span class="keyword">this</span>.getState();</span><br><span class="line">                next = current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSetState(current, next));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> current;</span><br><span class="line">            <span class="keyword">int</span> next;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                current = <span class="keyword">this</span>.getState();</span><br><span class="line">                next = current - reductions;</span><br><span class="line">                <span class="keyword">if</span> (next &gt; current) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSetState(current, next));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> current;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                current = <span class="keyword">this</span>.getState();</span><br><span class="line">            &#125; <span class="keyword">while</span>(current != <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.compareAndSetState(current, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java类源代码</category>
      </categories>
  </entry>
  <entry>
    <title>AtomicInteger类源码探究</title>
    <url>/2020/03/23/AtomicInteger%E7%B1%BB%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>对AtomicInteger类源码进行探究</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntUnaryOperator;</span><br><span class="line"><span class="keyword">import</span> jdk.internal.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        U.putIntRelease(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndSetInt(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span>(</span><br><span class="line">        since = <span class="string">"9"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.weakCompareAndSetIntPlain(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetPlain</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.weakCompareAndSetIntPlain(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> haveNext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveNext) &#123;</span><br><span class="line">                next = updateFunction.applyAsInt(prev);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.weakCompareAndSetVolatile(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            haveNext = prev == (prev = <span class="keyword">this</span>.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> haveNext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveNext) &#123;</span><br><span class="line">                next = updateFunction.applyAsInt(prev);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.weakCompareAndSetVolatile(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            haveNext = prev == (prev = <span class="keyword">this</span>.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> haveNext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveNext) &#123;</span><br><span class="line">                next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.weakCompareAndSetVolatile(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            haveNext = prev == (prev = <span class="keyword">this</span>.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x, IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> haveNext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveNext) &#123;</span><br><span class="line">                next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.weakCompareAndSetVolatile(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            haveNext = prev == (prev = <span class="keyword">this</span>.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//多态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(<span class="keyword">this</span>.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)<span class="keyword">this</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)<span class="keyword">this</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="keyword">this</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPlain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getInt(<span class="keyword">this</span>, VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPlain</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        U.putInt(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getOpaque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getIntOpaque(<span class="keyword">this</span>, VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setOpaque</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        U.putIntOpaque(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getIntAcquire(<span class="keyword">this</span>, VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRelease</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        U.putIntRelease(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareAndExchange</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndExchangeInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareAndExchangeAcquire</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndExchangeIntAcquire(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareAndExchangeRelease</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndExchangeIntRelease(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    weakCompareAndSetIntRelease以原子的方式更新这个更新器所管理的对象(obj)的成员变量，</span></span><br><span class="line"><span class="comment">    并且将这个成员变量更新为给定的更新后的值(update)如果当前值等于期望值(expect)时。</span></span><br><span class="line"><span class="comment">    当存在其他使用‘compareAndSet’或者’set’的情况下，</span></span><br><span class="line"><span class="comment">    这个方法可以确保是原子的，</span></span><br><span class="line"><span class="comment">    但如果你用其他的方式去改变这个成员变量时(如：使用直接赋值的方式 field=newField)，</span></span><br><span class="line"><span class="comment">    那么它是不会遵循这个原子性的。</span></span><br><span class="line"><span class="comment">    该方法可能可能虚假的失败并且不会提供一个排序的保证，</span></span><br><span class="line"><span class="comment">    所以它在极少的情况下用于代替compareAndSet方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetVolatile</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.weakCompareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetAcquire</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.weakCompareAndSetIntAcquire(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetRelease</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.weakCompareAndSetIntRelease(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        VALUE = U.objectFieldOffset(AtomicInteger.class, "value");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java类源代码</category>
      </categories>
  </entry>
  <entry>
    <title>形象描述实现临界区互斥的基本方法</title>
    <url>/2020/03/23/%E5%BD%A2%E8%B1%A1%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>用四个例子形象说明实现临界区互斥的基本方法</p>
<a id="more"></a>

<h2 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h2><p>是轮流请客吃饭，有可能出现有吝啬鬼进程一直拖延请客——违背空闲让进。</p>
<h2 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h2><p>对手之间抢资源，进程先检查资源有无主，无主就声明资源是自己的，有可能发生进程为了争夺无主资源打群架（是我先看见的）——违背忙则等待。</p>
<h2 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h2><p>队友之间抢资源，大家先声明谁需要这个资源，然后找到之后就给谁，有可能大家互相谦让，没完没了——违背有限等待，造成饥饿。</p>
<h2 id="Peterson’s-Algorithm"><a href="#Peterson’s-Algorithm" class="headerlink" title="Peterson’s Algorithm"></a>Peterson’s Algorithm</h2><p>丐帮传位，首先声明自己要当帮主，并得到大家的认可，再抢到帮会信物打狗棒证明自己——完美算法。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 JVM</title>
    <url>/2020/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    <content><![CDATA[<p>本文是《深入理解 JVM 》一书的笔记，将对书中知识做出提炼与总结。</p>
<a id="more"></a>

<h2 id="JVM-amp-amp-GC-深入知识"><a href="#JVM-amp-amp-GC-深入知识" class="headerlink" title="JVM &amp;&amp; GC 深入知识"></a>JVM &amp;&amp; GC 深入知识</h2><ul>
<li>了解 JVM 和内存相关的知识 。</li>
<li>了解常见的垃圾收集算法，这是 GC 实现的根本目标 。</li>
<li>了解 GC 的基本概念。</li>
<li>了解各类 GC 的特性 。</li>
<li>为深入了解 G1 GC 做好知识储备 。</li>
<li>Java 虚拟机内存模型。</li>
</ul>
<p>根据受访权限的不同设置，将 Java 虚拟机内存模型几个区域分为：</p>
<ul>
<li>线程共享类：可以允许被所有的线程共享访问的一类内存区域（包括堆内存区、方法区、运行时常量池）</li>
<li>线程私有类：非线程共享类。</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>一块很小的内存空间</li>
<li>存储速度最快</li>
<li>位于处理器内部（不同于其他存储区的地方）</li>
<li>数量有限</li>
<li>寄存器由编译器根据需求进行分配</li>
<li>在 Java 应用程序内部透明</li>
<li>字节码解释器的工作依赖计数器来完成</li>
</ul>
<p>Java线程数量超过 CPU 数量时，线程之间采用时间片轮转调度算法实现并发执行，为此，每一个线程都必须有一个独立的程序计数器，它被用来记录下一条需要执行的计算机指令 ，是线程独有的一块内存空间。</p>
<p>如果当前线程正在执行一个 Java 方法，则程序计数器记录正在执行的 Java 字节码地址，如果当前线程正在执行 一个本地方法，则程序计数器为空。</p>
<p>简单概括，即在多线程环境下，为了让线程切换后能恢复到正确的执行位置，每个钱程都需要有一个独立的程序计数器，各个线程之间互不影响、独立存储,因此这块内存是线程私有的。 JVM 中的寄存器类似于物理寄存器的一种抽象模拟，它是线程私有的，所以生命周期与线程的生命周期保持一致。</p>
<p>根据 Java 虚拟机定义来看，程序寄存器区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOtMemoryError情况的区域。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>JVM 的架构是基于栈。</p>
<p>虚拟机栈是一种可以被用来快速访问的存储区域，访问速度仅次于寄存器，堆战指针若向下移动，则分配新的内存，若向上移动，则释放那些内存。位于通用 RAM 里面,通过使用它的所谓的“核指针”可以访问处理器。</p>
<p>Java 虚拟机需要预先去生成相应的内存空间，所以当我们尝试运行程序的时候，Java 虚拟机必须知道被存储在栈内的所有数据的确切大小和生命周期，以便按照上面陈述的分配存储方法通过上下移动堆栈指针来动态调整内存空间。故只有某些 Java 数据，特别是对象引用，它被存储在校里面，而应用程序内部数量庞大的 Java 对象没有被存储在虚拟机技里面。</p>
<p>JVM 中存放在战内的数据可以共享。</p>
<p>与程序计数器一样， Java 虚拟机技也是线程私有的内存空间，它和 Java 线程在同一时间创建，它保存方法的局部变量、部分结果,井参与方法的调用和返回。</p>
<p>Java 虚拟机规范允许 Java 枝的大小是动态的或者是固定不变的 。</p>
<h4 id="两种与栈空间有关的异常"><a href="#两种与栈空间有关的异常" class="headerlink" title="两种与栈空间有关的异常"></a>两种与栈空间有关的异常</h4><ul>
<li>StackoverFlowError：线程在计算过程中，请求的战深度大于最大可用的战深度。</li>
<li>OutofMemoryError ：如果 Java 栈可以动态扩展，而在扩展的过程中没有足够的内存空间。</li>
</ul>
<p>设置虚拟机栈的大小：-XSS</p>
<h4 id="虚拟机栈的内部结构"><a href="#虚拟机栈的内部结构" class="headerlink" title="虚拟机栈的内部结构"></a>虚拟机栈的内部结构</h4><p>虚拟机栈在运行时使用 一种叫做栈帧的数据结构保存上下文数据。</p>
<p>栈帧里面存放了方法的</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接方法（指向运行时常量池的引用）</li>
<li>返回地址</li>
<li>附加信息</li>
</ul>
<p>方法的调用 =&gt; 栈帧的入栈操作</p>
<p>方法的返回 =&gt; 栈帧的出栈操作 </p>
<p> 如果方法调用时，方法的参数和局部变量相对较多，那么栈帧中的局部变量表就会比较大，栈帧会不断膨胀以满足方法调用所需传递的信息增大需求。因此，单个方法调用所需的栈空间也会比较多。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><em>局部变量</em></h4><ul>
<li><p><em>定义在函数内部的变量称为局部变量(函数的形参也是局部变量)</em></p>
</li>
<li><p><em>局部变量只能在函数内部使用</em></p>
<p><em>局部变量在函数调用时才能够被创建，在函数调用结束之后会自动销毁</em></p>
</li>
</ul>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><em>全局变量</em></h5><ul>
<li><em>定义在函数外部，模块内部的变量称为全局变量</em></li>
<li><em>所有的函数都可以直接访问”全局”变量，但函数内部不能直接通过赋值语句来改变全局变量</em></li>
</ul>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a><em>局部变量表</em></h5><ul>
<li><em>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量（包含各类基本数据类型、对象引用（ reference ），以及r eturnAddress 类型。）</em></li>
<li><em>最基本的存储单元是slot（变量槽）。</em></li>
<li><em>建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</em></li>
<li><em>局部变量表所需的容量大小是在编译期固定下来的，保存在Code属性的maximum local variables数据项中。</em></li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>虚拟机实现本地方法：传递给函数的参数以某个确定的顺序入栈，也以确定的方式返回值。</p>
<p>线程会保存本地方法栈的状态并进入到另一个 Java 栈 。</p>
<p>本地方法栈的内存区允许动态扩展收缩，某些 JVM 也允许用户或者程序员指定该内存区的初始大小以及最大、最小值。</p>
<p>Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈用于管理本地方法的调用。</p>
<p>本地方法并不是用 Java 实现的，而是使用 C 实现的。本质上是依赖于实现的。Can do anything you want,even register operation.</p>
<p><em>在 SUN 的 Hotspot 虚拟机中，不区分本地方法械和虚拟机栈。因此，和虚拟机栈一样，它也会抛出 <code>STACKOVERFLOWERROR</code> 和<code>OUTOFMEMORYERROR</code> 。</em></p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>堆在 JVM 规范里是一种通用性的内存池(也存在于 RAM 中)，用于存放所有的 Java 对象。</p>
<p>堆是一个运行时数据区，类的对象从中分配空间，这些对象通过 <code>New</code> 关键字建立，不需要程序代码来显式地释放。大多数的虚拟机里，Java 中的对象和数组都存放在堆中 。</p>
<h4 id="堆相对于栈的优缺点："><a href="#堆相对于栈的优缺点：" class="headerlink" title="堆相对于栈的优缺点："></a>堆相对于栈的优缺点：</h4><ul>
<li>优点：由垃圾回收负责，可以在运行时动态地分配内存大小，生存周期不需要事先告诉编译器。Java 的垃圾收集器会自动收走那些不再使用的数据。</li>
<li>缺点：要在运行时动态分配内存，数据访问速度较慢。</li>
</ul>
<p>Java 堆区在 NM 启动的时候即被创建，它只要求逻辑上是连续的，在物理空间上可以是不连续。所有的线程共享 Java 堆，在这里可以划分钱程私有的缓冲区 ( Thread Local Allocation Buffer, TLAB ) 。</p>
<p>Java 堆是 GC ( Garbage Collection）执行垃圾回收的重点区域，GC 极有可能会在<u>大内存的使用</u>和<u>频繁进行垃圾回收</u>过程上成为系统性能瓶颈。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li><p>类的类型信息</p>
<ul>
<li>类的完整名称</li>
<li>父类的完整名称</li>
<li>类型修饰符( pubIic/protected/private )</li>
<li>类型的直接接口类表</li>
</ul>
</li>
<li><p>常量池</p>
<p>类方法、域等信息所引用的常量信息。</p>
</li>
<li><p>域信息</p>
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符</li>
</ul>
</li>
<li><p>方法信息</p>
<ul>
<li>方法名称</li>
<li>返回类型</li>
<li>方法参数</li>
<li>方法修饰符表</li>
<li>方法字节码</li>
<li>操作数栈</li>
<li>方法栈帧的局部变量区大小</li>
<li>异常表</li>
</ul>
</li>
</ul>
<p>方法区是线程间共享的（与堆空间类似）：当两个线程同时需要加载一个类型时，只有一个类会请求 ClassLoader 加载，另一个线程则会等待。方法区内保存的信息大部分来自于 Class 文件（类的元数据）。</p>
<p>GC 针对方法区的回收：</p>
<ul>
<li><p>GC 对方法区常量池的回收</p>
</li>
<li><p>方法区对类元数据的回收</p>
</li>
</ul>
<p><em>HotSpot 虚拟机对常量池的回收策略：只要常量池中的常量没有被任何地方引用，就可以被回收。</em></p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>垃圾标记阶段：区分出内存中哪些是存活对象，哪些是已经死亡的对象。</p>
<p>实现：为每个对象配置一个整形的计数器。</p>
<p>对于一个对象 A，只要有任何 一个对象引用了 A ，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1，只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。</p>
<p>存活对象：计数器中的值不为0。</p>
<p>引用计数器算法的一大优势就是不用等待内存不够用的时候，才进行垃圾的回收，完全可以在赋值操作的同时检查计数器是否为 0 ，如果是的话就可以立即回收。</p>
<p>需要单独的字段存储计数器 =&gt; 增加存储空间的开销。</p>
<p>每次赋值都需要更新计数器 =&gt; 这增加了时间开销。</p>
<h4 id="一个严重的问题：无法处理循环引用"><a href="#一个严重的问题：无法处理循环引用" class="headerlink" title="一个严重的问题：无法处理循环引用"></a>一个严重的问题：无法处理循环引用</h4><p>垃圾对象间相互引用形成死锁，从而使垃圾回收器无法识别，引起内存泄漏。导致在 Java 的垃圾回收器中没有使用这类算法 。</p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>Hotspot 和大部分 JVM 都是使用根搜索算法作为垃圾标记的算法实现。</p>
<p>使用根搜索算法后，内存中的存活对象都会被根对象集合直接或间接连接着。</p>
<p>根搜索算法是以根对象集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达，如果目标对象不可达，就意味着该对象己经死亡，便可以在 instanceOopDesc 的 Mark World 中将其标记为垃圾对象。</p>
<p>存活对象：能够被根对象集合直接或者间接连接的对象。</p>
<p>在 Hotspot 中，根对象集合中</p>
<ul>
<li>Java 栈内的对象引用</li>
<li>本地方法栈内的对象引用</li>
<li>运行时常量池中的对象引用</li>
<li>方法区中类静态属性的对象引用</li>
<li>与一个类对应的唯一数据类型的 Class 对象</li>
</ul>
<p><strong>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告 一个对象死亡，至少要经历两次标记过程。如果对象在进行根搜索后发现没有与 GCRoots 相连接的引用链，那它将会被第一次标记井且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖<code>finalize()</code>方法,或者 <code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行。如果这个对象被判定有必要执行 <code>finalize()</code>方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 <code>finalize()</code>方法中执行缓慢，或者发生了死循环(更极端的情况)，很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 <code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在<code>finalize()</code>中成功拯救自己一一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合。如果对象这时候还没有逃脱，那它就真的离死不远了 。</strong></p>
<p><em>任何一个对象的 finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize()方法不会被再次执行。</em></p>
<h3 id="三种常用GC算法的比较"><a href="#三种常用GC算法的比较" class="headerlink" title="三种常用GC算法的比较"></a>三种常用GC算法的比较</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td align="left">中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td align="left">少（会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的两倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td align="left">否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>collector ：垃圾收集器</p>
<p>mutator ：除了垃圾收集器之外的部分。</p>
<p>mutator 的职责</p>
<ul>
<li>NEW（分配内存）</li>
<li>RAD（从内存中读取内容）</li>
<li>WRITE（将内容写入内存）</li>
</ul>
<p>collector 就是回收不再使用的内存来供 mutator 进行 NEW 操作的使用。</p>
<p>mutator 根对象一般指的是分配在堆内存之外，可以直接被 mutator 直接访问到的对象，一般是指静态/全局变量以及 ThreadLocal 变量。</p>
<h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法 ( Mark-Sweep )"></a>标记-清除算法 ( Mark-Sweep )</h3><ol>
<li><p>标记阶段：collector 从 mutator 根对象开始进行遍历，对从 mutator 根对象可以访问到的对象都打上一个标识，一般是在对象的 header 中，将其记录为可达对象。</p>
</li>
<li><p>清除阶段：collector 对堆内存( heap memory )从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象，通过读取对象的 header 信息，则将其回收。</p>
<p>一种可行的实现是：</p>
<ol>
<li>在标记阶段首先通过根节点，标记所有从根节点开始的可达对象。</li>
<li>在清除阶段，清除所有未被标记的对象。</li>
</ol>
</li>
</ol>
<p>这种分步执行的思路奠定了现代垃圾收集算法的思想基础。</p>
<p><em>与引用计数算法不同，标记-清除算法不需要运行环境监测每一次内存分配和指针操作,而只要在“标记”阶段中跟踪每一个指针变量的指向，用类似思路实现的垃圾收集器也常被后人统称为跟踪收集器( Tracing Collector )。</em></p>
<h4 id="标记-清除算法缺点"><a href="#标记-清除算法缺点" class="headerlink" title="标记-清除算法缺点"></a>标记-清除算法缺点</h4><ul>
<li>产生碎片：回收后的空间是不连续的。</li>
<li>效率低下：在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</li>
</ul>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法 ( Copying )"></a>复制算法 ( Copying )</h4><p><em>为了解决标记-清除算法在垃圾收集效率方面的缺陷， M.L.Minsky 于 1963 年发表了著名的</em><br><em>论文，“ 一利使用双存储区的 Lisp 语 言垃圾收集器 CA LISP Garbage Collector Algorithm Using</em><br><em>Serial Secondary Storage )”。</em></p>
<ol>
<li>将活着的内存空间分为两块，每次只使用其中一块</li>
<li>在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中</li>
<li>清除正在使用的内存块中的所有对象</li>
<li>交换两个内存的角色</li>
<li>最后完成垃圾回收</li>
</ol>
<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻,复制算法的效率是很高的。</p>
<p>又由于对象在垃圾回收过程中统一被复制到新的内存空间中，回收后的内存空间是没有碎片的。</p>
<p>缺点：系统内存折半。</p>
<h3 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记-压缩算法 ( Mark-Compact)"></a>标记-压缩算法 ( Mark-Compact)</h3><p>标记-压缩算法是标记-清除算法和复制算法的有机结合。</p>
<ol>
<li><p>标记出内存中的垃圾对象</p>
</li>
<li><p>将所有的存活对象都移动到一个规整且连续的内存空间中（内存的一端）</p>
</li>
<li><p>然后执行 Full GC (老年代的垃圾回收 )回收无用对象所占用的内存空间 </p>
<p><em>执行压缩之后，已用和未用的内存都各自一边，彼此之间维系着一个记录下一 次分配起始点的标记指针</em></p>
</li>
<li><p>为新对象分配内存（使用指针碰撞( Bump the Pointer )技术修改指针的偏移量将新对象分配在第 一个空闲内存位置上，为新对象分配内存带来便捷）</p>
</li>
</ol>
<p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自<br>的特点。针对不同的代空间，结合使用不同的垃圾收集算法：</p>
<ul>
<li><p>年轻代通常是以速度优先</p>
<ul>
<li>存储的瞬时对象生命周期非常短暂 =&gt; 可以有针对性地使用复制算法，执行 Minor GC 时, 一 定要保持高效和快速</li>
<li>生存空间通常都比较小 =&gt; 回收年轻代时一定会非常频繁</li>
</ul>
</li>
<li><p>老年代通常使用更节省内存的回收算法</p>
<p>老年代中所存储的对象生命周期都非常长，并且老年代占据了大部分的堆空间，所以老年代的 Full GC 并不会跟年轻代的 Minor GC 一样频繁，不过一旦程序中发生一次 Full GC ，将会耗费更长的时间来完成，那么在老年代中使用标记-清除算法或者标记-压缩算法执行垃圾回收将会是不错的选择。</p>
</li>
</ul>
<p><em>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</em></p>
<p>既避免了碎片的产生，又不需要两块相同的内存空间，性价比比较高。</p>
<h3 id="增量算法-Incremental-Collecting"><a href="#增量算法-Incremental-Collecting" class="headerlink" title="增量算法 ( Incremental Collecting )"></a>增量算法 ( Incremental Collecting )</h3><h4 id="Stop-the-World状态"><a href="#Stop-the-World状态" class="headerlink" title="Stop the World状态"></a>Stop the World状态</h4><p>垃圾回收Stop the World 状态：应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。</p>
<p>如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p>
<p>为了进行实时垃圾收集，可以设计一个多进程的运行环境，比如用一个进程执行垃圾收集工作，另一个进程执行程序代码。垃圾收集工作看上去就仿佛是在后台悄悄完成的，不会打断程序代码的运行。</p>
<h4 id="多进程的运行环境面临的问题"><a href="#多进程的运行环境面临的问题" class="headerlink" title="多进程的运行环境面临的问题"></a>多进程的运行环境面临的问题</h4><p>如果垃圾收集进程包括标记和清除两个工作阶段，垃圾收集器在第一阶段中辛辛苦苦标记出的结果很可能被另 一个进程中的内存操作代码修改得面目全非，以至于第二阶段的工作没有办法开展。</p>
<p><em>M. L. Minsky 和 D. E. Knuth 对实时垃圾收集过程中的技术难点进行了早期的研究, G. L.Steele 于 1975 年发表了题为“多进程整理的垃圾收集 ( Multiprocessing Compactifying Garbage Collection ) ”的论文,描述了一种被后人称为“ Minsky-Knuth-Steele 算法”的实时垃圾收集算法。 E.W.Dijkstra、 L.Lamport 、 R.R.Fenichel 和 J.C.Yochelson 等人也相继在此领域做出了各自的贡献。 1978 年，H.G .Baker 发表了“串行计算机上的实时表处理技术 ( List Processing in Real Time on a Serial Computer ) ” 一文，系统阐述了多进程环境下用于垃圾收集的增量收集算法。</em></p>
<h4 id="增量算法的基本思想"><a href="#增量算法的基本思想" class="headerlink" title="增量算法的基本思想"></a>增量算法的基本思想</h4><p>如果一次性将所有的垃圾进行处理,需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<ul>
<li>间断性地还执行了应用程序代码 =&gt; 所以能减少系统的停顿时间</li>
<li>线程切换和上下文转换的消耗 =&gt; 垃圾回收的总体成本上升 =&gt; 系统吞吐量下降</li>
</ul>
<p>增量收集算法的基础仍是传统的标记-清除和复制算法。</p>
<p>增量收集算法通过对进程间冲突的妥善处理，允许垃圾收集进程以分阶段的方式完成标记、清理或复制工作。</p>
<h3 id="分代收集算法-GenerationalCollecting"><a href="#分代收集算法-GenerationalCollecting" class="headerlink" title="分代收集算法( GenerationalCollecting )"></a>分代收集算法( GenerationalCollecting )</h3><p>大多数内存块的生存周期都比较短，垃圾收集器应当把更多的精力放在检查和清理新分配的内存块上。</p>
<p><em>D E. Knuth, T. Knight、 G. Sussman 和 R. Stallman 等人对内存垃圾的分类处理做了最早的研究。 1983 年， H. Lieberman 和 C. Hewitt 发表了题为“基于对象寿命的一种实时垃圾收集器( A Real-Time Garbage Collector Based on the Lifetimes of Object ) ”的论文。这篇著名的论文标志着分代收集算法的正式诞生。此后，在 H. G. Baker 、 R. L. Hudson 、 J.E. B. Moss 等人的共同努力下，分代收集算法逐渐成为了垃圾收集领域里的主流技术</em>。</p>
<h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><p>将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法以提高垃圾回收的效率 。</p>
<p>以Hotspot 虚拟机为例：</p>
<ul>
<li><p>年轻代：所有的新建对象所在区域。</p>
<p>对象会很快回收，选择效率较高的复制算法。</p>
</li>
<li><p>老年代：经过几次回收后依然存活的对象所在区域。</p>
<p><em>可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老年代，将需要复制大量对象。再加上老年代的回收性价比也要低于年轻代，因此这种做法也是不可取的。</em></p>
<p>使用标记-压缩算法，提高垃圾回收效率。</p>
</li>
</ul>
<p>总的来说，分代收集算法是基于对对象生命周期分析后得出的垃圾回收算法。它把对象分为年轻代、老年代、持久代，对不同生命周期的对象使用不同的算法(上述方式中的一个)进行回收。</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><h3 id="GC概念"><a href="#GC概念" class="headerlink" title="GC概念"></a>GC概念</h3><h4 id="HotSpot中GC划分的两大块"><a href="#HotSpot中GC划分的两大块" class="headerlink" title="HotSpot中GC划分的两大块"></a>HotSpot中GC划分的两大块</h4><ul>
<li>内存的动态分配</li>
<li>垃圾回收</li>
</ul>
<p>在内存执行分配之前 GC 首先会对内存空间进行分代划分</p>
<p>当内存空间中的内存消耗达到了一定阔值的时候，GC 就会执行垃圾回收。</p>
<h4 id="回收算法四个要求"><a href="#回收算法四个要求" class="headerlink" title="回收算法四个要求"></a>回收算法四个要求</h4><ol>
<li>不能造成内存中存活的对象被错误地回收掉</li>
<li>不能造成已经死亡的对象没有被及时地回收掉</li>
<li>高效，不应该导致应用程序出现长时间的暂停</li>
<li>避免产生内存碎片</li>
</ol>
<h4 id="GC性能标准"><a href="#GC性能标准" class="headerlink" title="GC性能标准"></a>GC性能标准</h4><ul>
<li>吞吐量：程序的运行时间(程序的运行时间+内存回收的时间)。</li>
<li>垃圾收集开销：吞吐量的补数,垃圾收集器所占时间与总时间的比例。</li>
<li>暂停时间：执行垃圾收集时,程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行,收集操作发生的频率。</li>
<li>堆空间：Java 堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><p>基于分代 的概念,不同的分代空间中均活动着不同的 GC 。</p>
<p>JVM 在实际运行过程中，年轻代和老年代中各自的 GC 需要组合在一起共同执行垃圾回收任务。</p>
<p>在实际开发过程中，年轻代和老年代的 GC 的组合方式还需要结合具体的应用场景进行分析后得到。</p>
<h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h4><ul>
<li><p>串行垃圾回收器</p>
<p>在同一时间段内只允许一件事情发生。当多个 CPU 可用时，也只能有一个 CPU 用于执行垃圾回收操作，井且在执行垃圾回收时，程序中的工作线程将会被暂停，当垃圾收集工作完成后才会恢复之前被暂停的工作线程。</p>
</li>
<li><p>并行垃圾回收器</p>
<p>在收集过程中，应用程序会全部暂停 。 但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者井发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差 。</p>
</li>
</ul>
<h4 id="按照工作模式分"><a href="#按照工作模式分" class="headerlink" title="按照工作模式分"></a>按照工作模式分</h4><ul>
<li><p>井发式垃坡回收器</p>
<p>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</p>
</li>
<li><p>独占式垃圾回收器</p>
<p>独占式垃圾回收器( S top the world)一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</p>
</li>
</ul>
<h4 id="按碎片处理方式"><a href="#按碎片处理方式" class="headerlink" title="按碎片处理方式"></a>按碎片处理方式</h4><ul>
<li><p>压缩式垃圾回收器</p>
<p>压缩式垃圾回收器会在<br>回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p>
</li>
<li><p>非压缩式垃圾回收器</p>
<p>非压缩式的垃圾回收器不进行这步操作。</p>
</li>
</ul>
<h4 id="按工作的内存区间"><a href="#按工作的内存区间" class="headerlink" title="按工作的内存区间"></a>按工作的内存区间</h4><ul>
<li>年轻代垃圾回收器</li>
<li>老年代垃圾回收器</li>
</ul>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>它采用复制算法、串行回收和“Stop-the-World”机制的方式执行内存回收 。</p>
<p><em>在早期的 JDK 版本中，由于那个年代的 CPU 速度并没有这么快,所以在 CPU 受限于单个 CPU 的情况下，使用 Serial 收集器执行年轻代垃圾收集几乎是唯一 的选择。Serial 收集器默认也作为 HotSpot 中 Client 模式下的年轻代垃圾收集器。</em></p>
<p>Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。同样也采用了串行回收和“Stop the-World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<p><em>如果在 JVM 受限于单个 CPU 的环境下，使用 Serial 收集器加上 Serial Old 收集器的组合执行 Client 模式下的内存回收将会是不错的选择——基于串行回收的垃圾收集器适用于大多数对暂停时间要求不高的 Client 模式下的 JVM，由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销，虽然执行串行回收会降低程序的吞吐量，但是回收质量还是不错的。在程序中，开发人员可以通过选项 “-XX:+UseSerialGC” 手动指定使用 Serial 收集器执行内存回收任务。</em></p>
<ol>
<li>该算法的第一步是在老年代标记存活的对象。</li>
<li>从头开始检查堆内存空间，并且只留下依然幸存的对象（清除）。</li>
<li>最后一步，从头开始，顺序地填满堆内存空间，将存活的对象连续存放在一起，这样堆<br>分成两部分，一边有存放的对象，一边没有对象（整理）。</li>
<li>Serial 收集器应用于小的存储器和少量的 CPU 。</li>
</ol>
<ul>
<li><h4 id="年轻代串行收集器"><a href="#年轻代串行收集器" class="headerlink" title="年轻代串行收集器"></a>年轻代串行收集器</h4><p>在 HotSpot 虚拟机中，使用-XX: +UseSerialGC 参数可以指定使用年轻代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。</p>
</li>
<li><h4 id="老年代串行收集器"><a href="#老年代串行收集器" class="headerlink" title="老年代串行收集器"></a>老年代串行收集器</h4><p>老年代串行收集器使用的是标记-压缩算法。</p>
<p>是串行的、独占式的垃圾回收器（和年轻代收集器相同）。</p>
<p><em>由于老年代垃圾回收通常会使用比年轻代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以和多种年轻代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。</em></p>
<p>启用老年代串行回收器：</p>
<ul>
<li>-XX :+UseSerialGC：年轻代、老年代都使用串行回收器</li>
<li>-XX:+UseParNewGC：指定年轻代使用井行收集器，老年代使用串行收集器</li>
</ul>
</li>
</ul>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>如果说 Serial 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。</p>
<p>ParNew 收集器除了采用井行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别，因为 ParNew 收集器在年轻代中同样也是采用复制算法和“Stop-the-World”机制。</p>
<p>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU 、多核心等物理硬件资源优势，确实可以更快速地完成垃圾收集，提升程序的吞吐量，但是如果是在单个 CPU 的环境下，ParNew 收集器不见得比 Serial 收集器更高效。</p>
<p><em>虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换,因此可以有效避免多线程交互过程中产生的一 些额外开销 。所以从理论上来说， Serial 收集器的优势是在 JVM 受限于单 CPU 环境中，而 ParNew 收集器的优势则是体现在多 CPU 、多核心的环境中，并且在某些注重低延迟的应用场景下，ParNew 收集器和 CMS (Concurrent-Mark-Sweep )收集器的组合模式，在 Sever 模式下的内存回收效果很好。在程序中，开发人员可以通过选项“-XX:+UseParNewGC ”手动指定使用 ParNew 收集器执行内存回收任务。</em></p>
<ul>
<li><p>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。</p>
</li>
<li><p>-XX:+UseParNewGC：年轻代使用井行收集器，老年代使用串行收集器。</p>
</li>
</ul>
<h3 id="Parallel-收集器"><a href="#Parallel-收集器" class="headerlink" title="Parallel 收集器"></a>Parallel 收集器</h3><h4 id="与ParNew收集器的相同之处"><a href="#与ParNew收集器的相同之处" class="headerlink" title="与ParNew收集器的相同之处"></a>与ParNew收集器的相同之处</h4><p>Parallel 收集器同样也采用了复制算法、并行回收和“ Stop-the-World ”机制。</p>
<h4 id="和ParNew-收集器不同之处"><a href="#和ParNew-收集器不同之处" class="headerlink" title="和ParNew 收集器不同之处"></a>和ParNew 收集器不同之处</h4><p>Parallel 收集器可以控制程序的吞吐量大小，因此它也被称为吞吐量优先的垃圾收集器。</p>
<p>-XX:GCTimeRatio：设置执行内存回收的时间所占 JVM 运行总时间的比例，即控制 GC 的执行频率（公式为 l /(l+N)，默认值为 99，也就是说，将只有 1 %的时间用于执行垃圾回收）。</p>
<p>-XX:MaxGCPauseMills：设置执行内存回收时“ Stop-the-World ”机制的暂停时间阀值（如果指定了该选项，Parallel 收集器将会尽可能地在设定的时间范围内完成内存回收）。</p>
<p>需要注意的是，<strong>垃圾收集器中吞吐量和低延迟这两个目标本身是相互矛盾的，因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</strong></p>
<p>-XX:UseAdaptiveSizePolicy：设置 GC 的自动分代大小调节策略（开发人员将不再需要显式地设置年轻代中的一些细节参数，JVM 会根据自身当前的运行情况动态调整这些相关参数）</p>
<p>Parallel 收集器提供用于执行老年代垃圾收集的 Parallel Old 收集器（和Serial 收集器一样），Parallel Old 收集器采用了标记-压缩算法，但同样也是基于并行回收和“ Stop-the-World ”机制 。</p>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。-XX:+UseParallelGC：手动指定使用 Parallel 收集器执行内存回收任务。 </p>
<h4 id="年轻代并行回收-Parallel-Scavenge-收集器"><a href="#年轻代并行回收-Parallel-Scavenge-收集器" class="headerlink" title="年轻代并行回收( Parallel Scavenge )收集器"></a>年轻代并行回收( Parallel Scavenge )收集器</h4><p>年轻代井行回收收集器也是使用复制算法的收集器。从表面上看,它和并行收集器一样都<br>是多线程、独占式的收集器。但是,并行回收收集器有 一个重要的特点,它非常关注系统的吞<br>吐量。<br>年轻代并行回收收集器可以使用以下选项启用。</p>
<ul>
<li>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。</li>
<li>-XX:+UseParallelOldGC：年轻代和老年代都是用井行回收收集器。</li>
</ul>
<p>年轻代井行回收收集器可以使用以下选项启用</p>
<ul>
<li><p>-XX:+MaxGCPauseMills：设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。</p>
<p><em>收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。如果希望减少停顿时间，而把这个值设置得很小，为了达到预期的停顿时间，JVM 可能会使用一个较小的堆（一个小堆比一个大堆回收快），而这将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，减少了吞吐量 。</em></p>
</li>
<li><p>-XX:+GCTimeRatio：设置吞吐量大小。</p>
<p><em>它的值是一个 0 ~ 100 的整数。假设 GCTimeRatio的值为 n，那么系统将花费不超过 l/(l+n) 的时间用于垃圾收集。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/( 1 + 19)=5% 。默认情况下，它的取值是 99，即不超过 1% 的时间用于垃圾收集。</em></p>
</li>
</ul>
<h5 id="并行回收收集器与并行收集器不同之处"><a href="#并行回收收集器与并行收集器不同之处" class="headerlink" title="并行回收收集器与并行收集器不同之处"></a>并行回收收集器与并行收集器不同之处</h5><p>支持一种自适应的 GC调节策略。</p>
<p>-XX:+UseAdaptiveSizePolicy：打开自适应 GC 策略。</p>
<p><em>在这种模式下 , 年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量( GCTimeRatio )和停顿时间( MaxGCPauseMills )，让虚拟机自己完成调优工作。</em></p>
<h4 id="老年代并行回收收集器"><a href="#老年代并行回收收集器" class="headerlink" title="老年代并行回收收集器"></a>老年代并行回收收集器</h4><p>一种多线程并发的收集器。</p>
<p>一种关注吞吐量的收集器（和年轻代一样）。</p>
<p>使用标记.压缩算法，JDK1.6 之后开始启用。</p>
<p>XX:+UseParallelOldGC：在年轻代和老年代都使用并行回收收集器。（这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用）。</p>
<p>-XX:ParallelGCThreads：设置垃圾回收时的线程数量。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent-Mark-Sweep</p>
<p>在程序吞吐量优先的应用场最中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错 。 但是在某些对系统响应速度要求比较高的项目中，大家总是希望系统能够快速做出响应，而不愿意看到过多的延迟。</p>
<p>基于低延迟的考虑，JVM 的设计者们提供了基于井行回收的 CMS ( Concurrent-Marking-Sweep )收集器，它是一款优秀的老年代垃圾收集器，也可以被称作 Mostly-Concurrent 收集器。</p>
<p> CMS 天生为并发而生，低延迟是它的优势，不过垃圾收集算法却并没有采用标记-复制算法，而是采用标记-清除算法，并且也会因为“ Stop-the-world ”机制而出现短暂的暂停。</p>
<h4 id="CMS-的执行过程"><a href="#CMS-的执行过程" class="headerlink" title="CMS 的执行过程"></a>CMS 的执行过程</h4><ul>
<li><p>初始标记( Initial-Mark )阶段</p>
<p>程序中所有的工作线程都将会因为“ Stop-the-World ”机制而出现短暂的暂停，这个阶段的主要任务就是标记出内存中那些被根对象集合所连接的目标对象是否可达，一旦标记完成之后就会恢复之前被暂停的所有应用线程。</p>
</li>
<li><p>并发标记( Concurrent-Mark )阶段</p>
<p>这个阶段的主要任务就是将之前的不可达对象标记为垃圾对象。</p>
</li>
</ul>
<p><em>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此在并发标记阶段将无法有效确保之前被标记为垃圾的无用对象的引用关系遭到更改，为了解决这个问题，CMS 会进入到再次标记阶段。</em></p>
<ul>
<li><p>标记 ( Remark ) 阶段</p>
<p>程序会因为“ Stop-the-World ”机制而再次出现短暂的暂停，以确保这些垃圾对象都能够被成功且正确地标记 。</p>
</li>
<li><p>并发清除 ( Concurrent-Sweep ) 阶段</p>
<p>CMS 最终将会进入到并发清除阶段执行内存回收，释放掉无用对象所占用的内存空间。</p>
</li>
</ul>
<p><em>尽管 CMS 收集器采用的是并行回收，但是在其初始化标记和再次标记这两个阶段中仍然需要执行“ Stop-the-World ”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“ Stop-the-World ”，只是尽可能地缩短暂停时间。</em></p>
<p><em>Serial Old 收集器 、 Parallel Old 老年代垃圾收集器的垃圾收集算法都是采用标记-压缩来避免执行 Full GC 后产生内存碎片，而 CMS 收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间后，将无法使用指针碰撞( Bump the Pointer )技术，而只能选择空闲列表( Free List )执行内存分配。</em></p>
<p>在 HotSpot 中，当垃圾收集器执行完内存回收后，如果内存空间中产生内存碎片，那么只能选择空闲列表作为内存分配算法为新对象分配内存空间。简单来说，会有 JVM 负责维护一个列表，其中所记录的内容就是当前内存空间中可用内存块的坐标，当执行内存分配时，会从列表中定位到一个与新对象所需内存大小一致的连续内存块用于存储生成的对象实例。</p>
<h4 id="解决内存碎片的弊端"><a href="#解决内存碎片的弊端" class="headerlink" title="解决内存碎片的弊端"></a>解决内存碎片的弊端</h4><p>-XX: +UseCMS-CompactAtFullCollection：指定在执行完 Full GC 后是否对内存空间进行压缩整理，以此避免内存碎片的产生 。（不过由于内存压缩整理过程无法井发执行，所带来的问题就是停顿时间变得更长了。）</p>
<h4 id="解决停顿时间变长的弊端"><a href="#解决停顿时间变长的弊端" class="headerlink" title="解决停顿时间变长的弊端"></a>解决停顿时间变长的弊端</h4><p>-XX:CMSFullGCs-BeforeCompaction：用于设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
<p>除了会产生内存碎片外，CMS 收集器还存在一个不容忽视的问题，那就是在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。尽管 Full GC 大多数时候只会发生在老年代垃圾回收阶段，但是实际上 Full GC 的 回收范围却不单单仅限于老年代中，从严格意义上来说, Full GC 的回收范围 几乎覆盖了整个堆空间 , 因此 Full GC 将会比 Minor GC 耗费更长的时间来完成垃圾收集。在 HotSpot 中，除了 CMS 收集器之外的任何老年代垃圾收集器在执行内存回收时，都将会执行 Full GC ，只有 GI 收集器较为特殊。</p>
<h4 id="解决新产生的垃圾对象无法标记的弊端"><a href="#解决新产生的垃圾对象无法标记的弊端" class="headerlink" title="解决新产生的垃圾对象无法标记的弊端"></a>解决新产生的垃圾对象无法标记的弊端</h4><p>-XX:CMSlnitiatingOccupanyFraction：用于设置当老年代中的内存使用率达到多少百分比的时候执行内存回收( 低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92 %，内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 的执行次数）。</p>
<p>一旦 CMS 在执行过程中出现“ Promotion Failed ”或“ Concurrent Mode Failure ”时，仍然有可能会触发 Full GC 操作。</p>
<p>-XX:+UseConcMarkSweepGC：手动指定使用 CMS 收集器执行内存回收任务。</p>
<p>CMS 收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占 CPU ，所以在 CMS 执行期内会对应用程序吞吐量造成一定的影响。</p>
<h4 id="设定-CMS-的线程数量"><a href="#设定-CMS-的线程数量" class="headerlink" title="设定 CMS 的线程数量"></a>设定 CMS 的线程数量</h4><p> CMS 默认启动的线程数是(ParallelGCThreads+ 3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。</p>
<p>-:XX:ParallelCMSThreads：手工设定 CMS 的线程数量。</p>
<p>当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟<br>糕。</p>
<p>由于 CMS 收集器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当堆内存使用率达到某一阀值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</p>
<h4 id="指定回收阔值"><a href="#指定回收阔值" class="headerlink" title="指定回收阔值"></a>指定回收阔值</h4><p>-:XX:CMSinitiatingOccupancyFraction：指定回收阔值。（默认是 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。）</p>
<p>如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阔值，以避免频繁触发老年代串行收集器。</p>
<p>标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。</p>
<h4 id="内存碎片整理"><a href="#内存碎片整理" class="headerlink" title="内存碎片整理"></a>内存碎片整理</h4><p>-:XX:+UseCMSCompactAtFullCollection：使 CMS 在垃圾收集完成后，进行一次内存碎片整理（内存碎片的整理并不是并发进行的）。</p>
<h4 id="内存压缩"><a href="#内存压缩" class="headerlink" title="内存压缩"></a>内存压缩</h4><p>-:XX:CMSFullGCsBeforeCompaction：用于设定进行多少次 CMS 回收后，进行一次内存压缩。</p>
]]></content>
  </entry>
  <entry>
    <title>Java面试题</title>
    <url>/2020/03/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>作者：Zz_maker<br><a href="https://www.cnblogs.com/Zz-maker/p/11193930.html" target="_blank" rel="noopener">https://www.cnblogs.com/Zz-maker/p/11193930.html</a><br>包含的模块：</p>
<p>本文分为十九个模块，分别是：Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM</p>
<p>共包含 208 道面试题，本文的宗旨是为读者朋友们整理一份详实而又权威的面试清单，下面一起进入主题吧。</p>
<a id="more"></a>

<h2 id="一-Java-基础模块"><a href="#一-Java-基础模块" class="headerlink" title="一. Java 基础模块"></a>一. Java 基础模块</h2><h3 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h3><p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h3 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2.== 和 equals 的区别是什么？"></a>2.== 和 equals 的区别是什么？</h3><p>== 解读:<br>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<p>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p>equals 解读:<br>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String anotherString = (String)anObject;</span><br><span class="line"><span class="keyword">int</span> n = value.length;</span><br><span class="line"><span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"><span class="keyword">char</span> v1[] = value;</span><br><span class="line"><span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h3 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h3><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。<br>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"精彩"</span>;</span><br><span class="line">String str2 = <span class="string">"笔记"</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>, str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行的结果：<br><code>str1：1179395 | str2：1179395</code><br><code>false</code></p>
<p>代码解读：很显然“精彩”和“笔记”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h3 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4.final 在 Java 中有什么作用？"></a>4.final 在 Java 中有什么作用？</h3><p>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h3 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5.Java 中的 Math. round(-1. 5) 等于多少？"></a>5.Java 中的 Math. round(-1. 5) 等于多少？</h3><p>等于 -1。round()是四舍五入，注意负数5是舍的，例如：Math.round(1.5)值是2，Math.round(-1.5)值是-1。</p>
<h3 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6.String 属于基础的数据类型吗？"></a>6.String 属于基础的数据类型吗？</h3><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h3 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7.Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7.Java 中操作字符串都有哪些类？它们之间有什么区别？</h3><p>操作字符串的类有：String、StringBuffer、StringBuilder。<br>三者区别：</p>
<p>StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。<br>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 存储数据的字符数组没有被final修饰，说明值可以改变，抽象类AbstractStringBuilder内部都提供了一个自动扩容机制，当发现长度不够的时候(初始默认长度是16)，会自动进行扩容工作，扩展为原数组长度的2倍加2，创建一个新的数组，并将数组的数据复制到新数组，所以对于拼接字符串效率要比String要高。<br>线程安全性：StringBuffer由于很多方法都被 synchronized 修饰了所以线程安全，但是当多线程访问时，加锁和释放锁的过程很平凡，所以效率相比StringBuilder要低。StringBuilder相反执行效率高，但是线程不安全。所以单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br>执行速度:StringBuilder &gt; StringBuffer &gt; String。</p>
<h3 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8.String str=”i”与 String str=new String(“i”)一样吗？"></a>8.String str=”i”与 String str=new String(“i”)一样吗？</h3><p>不一样，因为内存的分配方式不一样。String str=“i”的方式，Java 虚拟机会将其分配到常量池中，如果常量池中有”i”，就返回”i”的地址，如果没有就创建”i”，然后返回”i”的地址；而 String str=new String(“i”) 则会被分到堆内存中新开辟一块空间。</p>
<h3 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h3><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>



<h3 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10.String 类的常用方法都有那些？"></a>10.String 类的常用方法都有那些？</h3><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>
<h3 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11.抽象类必须要有抽象方法吗？"></a>11.抽象类必须要有抽象方法吗？</h3><p>不需要，抽象类不一定非要有抽象方法；但是包含一个抽象方法的类一定是抽象类。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System. out. println(<span class="string">"hi~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h3 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12.普通类和抽象类有哪些区别？"></a>12.普通类和抽象类有哪些区别？</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类是不能被实例化的，就是不能用new调出构造方法创建对象，普通类可以直接实例化。<br>如果一个类继承于抽象类，则该子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。</p>
<h3 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13.抽象类能使用 final 修饰吗？"></a>13.抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<h3 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14.接口和抽象类有什么区别？"></a>14.接口和抽象类有什么区别？</h3><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>实现数量：类可以实现很多个接口；但只能继承一个抽象类【java只支持单继承】。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的抽象方法可以使用Public和Protected修饰，如果抽象方法修饰符为Private，则报错：The abstract method 方法名 in type Test can only set a visibility modifier, one of public or protected。</p>
<h3 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15.Java 中 IO 流分为几种？"></a>15.Java 中 IO 流分为几种？</h3><p>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h3 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16.BIO、NIO、AIO 有什么区别？"></a>16.BIO、NIO、AIO 有什么区别？</h3><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h3 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17.Files的常用方法都有哪些？"></a>17.Files的常用方法都有哪些？</h3><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。<br>···</p>
<p>====================================================================</p>
<h2 id="二-Java-容器模块"><a href="#二-Java-容器模块" class="headerlink" title="二. Java 容器模块"></a>二. Java 容器模块</h2><h3 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18.Java 容器都有哪些？"></a>18.Java 容器都有哪些？</h3><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>Collection<br>List<br>ArrayList<br>LinkedList<br>Vector<br>Stack<br>Set<br>HashSet<br>LinkedHashSet<br>TreeSet<br>Map<br>HashMap<br>LinkedHashMap<br>TreeMap<br>ConcurrentHashMap<br>Hashtable</p>
<h3 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19.Collection 和 Collections 有什么区别？"></a>19.Collection 和 Collections 有什么区别？</h3><p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。</p>
<h3 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20.List、Set、Map 之间的区别是什么？"></a>20.List、Set、Map 之间的区别是什么？</h3><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：</p>
<h3 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21.HashMap 和 Hashtable 有什么区别？"></a>21.HashMap 和 Hashtable 有什么区别？</h3><p>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>HashMap的key-value支持key-value，null-null，key-null，null-value四种。而Hashtable只支持key-value一种（即key和value都不为null这种形式）。既然HashMap支持带有null的形式，那么在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断，因为使用get的时候，当返回null时，你无法判断到底是不存在这个key，还是这个key就是null，还是key存在但value是null。<br>线程安全性不同：HashMap的方法都没有使用synchronized关键字修饰，都是非线程安全的，而Hashtable的方法几乎都是被synchronized关键字修饰的。但是，当我们需要HashMap是线程安全的时，怎么办呢？我们可以通过Collections.synchronizedMap(hashMap)来进行处理，亦或者我们使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br>初始容量大小和每次扩充容量大小的不同：Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br>计算hash值的方法不同：为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p>
<h3 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22.如何决定使用 HashMap 还是 TreeMap？"></a>22.如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h3 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23.说一下 HashMap 的实现原理？"></a>23.说一下 HashMap 的实现原理？</h3><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h3 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24.说一下 HashSet 的实现原理？"></a>24.说一下 HashSet 的实现原理？</h3><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h3 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25.ArrayList 和 LinkedList 的区别是什么？"></a>25.ArrayList 和 LinkedList 的区别是什么？</h3><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h3 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26.如何实现数组和 List 之间的转换？"></a>26.如何实现数组和 List 之间的转换？</h3><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">"☞精◈彩◈猿◈笔◈记☜"</span>);</span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"☞精◈彩◈猿◈笔◈记☜"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>



<h3 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27.ArrayList 和 Vector 的区别是什么？"></a>27.ArrayList 和 Vector 的区别是什么？</h3><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>
<h3 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28.Array 和 ArrayList 有何区别？"></a>28.Array 和 ArrayList 有何区别？</h3><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p>
<h3 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29.在 Queue 中 poll()和 remove()有什么区别？"></a>29.在 Queue 中 poll()和 remove()有什么区别？</h3><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 remove()会直接抛出NoSuchElementException 异常，而 poll()会返回 null。<br>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">"string"</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>



<h3 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30.哪些集合类是线程安全的？"></a>30.哪些集合类是线程安全的？</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h3 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31.迭代器 Iterator 是什么？"></a>31.迭代器 Iterator 是什么？</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h3 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32.Iterator 怎么使用？有什么特点？"></a>32.Iterator 怎么使用？有什么特点？</h3><p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">String obj = it. next();</span><br><span class="line">System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h3 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33.Iterator 和 ListIterator 有什么区别？"></a>33.Iterator 和 ListIterator 有什么区别？</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<h3 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34.怎么确保一个集合不能被修改？"></a>34.怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

<p>====================================================================</p>
<p>三. Java 多线程模块</p>
<h3 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35.并行和并发有什么区别？"></a>35.并行和并发有什么区别？</h3><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>如下图：【并发 = 两个队列和一台咖啡机】 【并行 = 两个队列和两台咖啡机】</p>
<h3 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36.线程和进程的区别？"></a>36.线程和进程的区别？</h3><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h3 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37.守护线程是什么？"></a>37.守护线程是什么？</h3><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h3 id="38-多线程有几种实现方式？"><a href="#38-多线程有几种实现方式？" class="headerlink" title="38.多线程有几种实现方式？"></a>38.多线程有几种实现方式？</h3><p>有4种，分别是：</p>
<p>继承Thread类<br>实现Runnable接口<br>实现Callable接口通过FutureTask包装器来创建Thread线程<br>通过线程池创建线程，使用线程池接口ExecutorService结合Callable、Future实现有返回结果的多线程。<br>前面两种【无返回值】原因：通过重写run方法，run方法的返回值是void，所以没有办法返回结果。<br>后面两种【有返回值】原因：通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。</p>
<h3 id="39-说一下-Runnable和-Callable有什么区别？"><a href="#39-说一下-Runnable和-Callable有什么区别？" class="headerlink" title="39.说一下 Runnable和 Callable有什么区别？"></a>39.说一下 Runnable和 Callable有什么区别？</h3><p>Runnable没有返回值，Callable可以拿到有返回值，Callable可以看作是 Runnable的补充。</p>
<h3 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40.线程有哪些状态？"></a>40.线程有哪些状态？</h3><p>线程的6种状态：</p>
<p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。<br>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。<br>阻塞(BLOCKED)：表示线程阻塞于锁。<br>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。<br>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。<br>终止(TERMINATED)：表示该线程已经执行完毕。</p>
<h3 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41.sleep() 和 wait() 有什么区别？"></a>41.sleep() 和 wait() 有什么区别？</h3><p>类的不同：sleep() 来自 Thread，wait() 来自 Object。<br>释放锁：sleep() 不释放锁；wait() 释放锁。<br>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</p>
<h3 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42.notify()和 notifyAll()有什么区别？"></a>42.notify()和 notifyAll()有什么区别？</h3><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h3 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43.线程的 run() 和 start() 有什么区别？"></a>43.线程的 run() 和 start() 有什么区别？</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<h3 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44.创建线程池有哪几种方式？"></a>44.创建线程池有哪几种方式？</h3><p>线程池创建有七种方式，最核心的是最后一种：</p>
<p>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；<br>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；<br>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；<br>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；<br>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；<br>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；<br>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p>
<h3 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45.线程池都有哪些状态？"></a>45.线程池都有哪些状态？</h3><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。<br>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。<br>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。<br>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。<br>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p>
<h3 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46.线程池中 submit() 和 execute() 方法有什么区别？"></a>46.线程池中 submit() 和 execute() 方法有什么区别？</h3><p>execute()：只能执行 Runnable 类型的任务。<br>submit()：可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h3 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47.在 Java 程序中怎么保证多线程的运行安全？"></a>47.在 Java 程序中怎么保证多线程的运行安全？</h3><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System. out. println(<span class="string">"获得锁"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System. out. println(<span class="string">"释放锁"</span>);</span><br><span class="line">lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48.多线程中 synchronized 锁升级的原理是什么？"></a>48.多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49.什么是死锁？"></a>49.什么是死锁？</h3><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h3 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50.怎么防止死锁？"></a>50.怎么防止死锁？</h3><p>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。<br>尽量使用 Java. util. concurrent 并发类代替自己手写锁。<br>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。<br>尽量减少同步的代码块。</p>
<h3 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51.ThreadLocal 是什么？有哪些使用场景？"></a>51.ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h3 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52.说一下 synchronized 底层实现原理？"></a>52.说一下 synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<h3 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53.synchronized 和 volatile 的区别是什么？"></a>53.synchronized 和 volatile 的区别是什么？</h3><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p>
<h3 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54.synchronized 和 Lock 有什么区别？"></a>54.synchronized 和 Lock 有什么区别？</h3><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h3 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55.synchronized 和 ReentrantLock 区别是什么？"></a>55.synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。<br>主要区别如下：</p>
<p>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。<br>ReentrantLock 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p>
<h3 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56.说一下 atomic 的原理？"></a>56.说一下 atomic 的原理？</h3><p>atomic 主要利用 CAS (Compare And Swap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="四-Java-反射模块"><a href="#四-Java-反射模块" class="headerlink" title="四. Java 反射模块"></a>四. Java 反射模块</h2><h3 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57.什么是反射？"></a>57.什么是反射？</h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h3 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58.什么是 Java 序列化？什么情况下需要序列化？"></a>58.什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p>
<p>想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>想用套接字在网络上传送对象的时候；<br>想通过RMI（远程方法调用）传输对象的时候。</p>
<h3 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59.动态代理是什么？有哪些应用？"></a>59.动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<h3 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60.怎么实现动态代理？"></a>60.怎么实现动态代理？</h3><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="五-Java-对象拷贝模块"><a href="#五-Java-对象拷贝模块" class="headerlink" title="五. Java 对象拷贝模块"></a>五. Java 对象拷贝模块</h2><h3 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61.为什么要使用克隆？"></a>61.为什么要使用克隆？</h3><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h3 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62.如何实现对象克隆？"></a>62.如何实现对象克隆？</h3><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
<h3 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63.深拷贝和浅拷贝区别是什么？"></a>63.深拷贝和浅拷贝区别是什么？</h3><p>浅拷贝：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深拷贝：除了对象本身被复制外，对象所包含的所有成员变量也将复制。<br>···</p>
<p>====================================================================</p>
<h2 id="六-Java-Web模块"><a href="#六-Java-Web模块" class="headerlink" title="六. Java Web模块"></a>六. Java Web模块</h2><h3 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64.JSP 和 servlet 有什么区别？"></a>64.JSP 和 servlet 有什么区别？</h3><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>
<h3 id="65-JSP-有哪些内置对象？作用分别是什么？"><a href="#65-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="65.JSP 有哪些内置对象？作用分别是什么？"></a>65.JSP 有哪些内置对象？作用分别是什么？</h3><p>JSP 有 9 大内置对象：</p>
<p>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web 应用的配置对象；<br>page：JSP 页面本身（相当于 Java 程序中的 this）；<br>exception：封装页面抛出异常的对象。</p>
<h3 id="66-说一下-JSP-的-4-种作用域？"><a href="#66-说一下-JSP-的-4-种作用域？" class="headerlink" title="66.说一下 JSP 的 4 种作用域？"></a>66.说一下 JSP 的 4 种作用域？</h3><p>page：代表与一个页面相关的对象和属性。<br>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。<br>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。<br>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p>
<h3 id="67-session-和-cookie-有什么区别？"><a href="#67-session-和-cookie-有什么区别？" class="headerlink" title="67.session 和 cookie 有什么区别？"></a>67.session 和 cookie 有什么区别？</h3><p>session：是一种将会话状态保存在服务器端的技术。<br>Cookie ：是在 HTTP 协议下， Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息 。</p>
<p>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。<br>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。<br>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。<br>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p>
<h3 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68.说一下 session 的工作原理？"></a>68.说一下 session 的工作原理？</h3><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h3 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69.如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69.如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<h3 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70.spring mvc 和 struts 的区别是什么？"></a>70.spring mvc 和 struts 的区别是什么？</h3><p>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。<br>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。<br>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。<br>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p>
<h3 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71.如何避免 SQL 注入？"></a>71.如何避免 SQL 注入？</h3><p>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。</p>
<h3 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72.什么是 XSS 攻击，如何避免？"></a>72.什么是 XSS 攻击，如何避免？</h3><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h3 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73.什么是 CSRF 攻击，如何避免？"></a>73.什么是 CSRF 攻击，如何避免？</h3><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：</p>
<p>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。<br>···</p>
<p>====================================================================</p>
<h2 id="七-Java-异常模块"><a href="#七-Java-异常模块" class="headerlink" title="七. Java 异常模块"></a>七. Java 异常模块</h2><h3 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74.throw 和 throws 的区别？"></a>74.throw 和 throws 的区别？</h3><p>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</p>
<h3 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75.final、finally、finalize 有什么区别？"></a>75.final、finally、finalize 有什么区别？</h3><p>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。<br>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。<br>finalize：是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<h3 id="76-try-catch-finally-中哪个部分可以省略？"><a href="#76-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="76.try-catch-finally 中哪个部分可以省略？"></a>76.try-catch-finally 中哪个部分可以省略？</h3><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h3 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h3 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78.常见的异常类有哪些？"></a>78.常见的异常类有哪些？</h3><p>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常<br>···</p>
<p>====================================================================</p>
<h2 id="八-网络模块"><a href="#八-网络模块" class="headerlink" title="八. 网络模块"></a>八. 网络模块</h2><h3 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79.http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79.http 响应码 301 和 302 代表的是什么？有什么区别？</h3><p>301：永久重定向；302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
<h3 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80.forward 和 redirect 的区别？"></a>80.forward 和 redirect 的区别？</h3><p>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</p>
<h3 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81.简述 tcp 和 udp的区别？"></a>81.简述 tcp 和 udp的区别？</h3><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：</p>
<p>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；</p>
<h3 id="82-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82.tcp 为什么要三次握手，两次不行吗？为什么？"></a>82.tcp 为什么要三次握手，两次不行吗？为什么？</h3><p>　我们假设A和B是通信的双方。我理解的握手实际上就是通信，发一次信息就是进行一次握手。</p>
<p>第一次握手：A给B打电话说，你可以听到我说话吗？<br>第二次握手：B收到了A的信息，然后对A说：我可以听得到你说话啊，你能听得到我说话吗？<br>第三次握手：A收到了B的信息，然后说可以的，我要给你发信息啦！<br>在三次握手之后，A和B都能确定这么一件事：我说的话，你能听到；你说的话，我也能听到。这样，就可以开始正常通信了。<br>注意：HTTP是基于TCP协议的，所以每次都是客户端发送请求，服务器应答，但是TCP还可以给其他应用层提供服务，即可能A、B在建立链接之后，谁都可能先开始通信。</p>
<p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>
<h3 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83.说一下 tcp 粘包是怎么产生的？"></a>83.说一下 tcp 粘包是怎么产生的？</h3><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<p>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p>
<h3 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84.OSI 的七层模型都有哪些？"></a>84.OSI 的七层模型都有哪些？</h3><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p>
<h3 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85.get 和 post 请求有哪些区别？"></a>85.get 和 post 请求有哪些区别？</h3><p>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p>
<h3 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86.如何实现跨域？"></a>86.如何实现跨域？</h3><p>实现跨域有以下几种方案：</p>
<p>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</p>
<h3 id="87-说一下-JSONP-实现原理？"><a href="#87-说一下-JSONP-实现原理？" class="headerlink" title="87.说一下 JSONP 实现原理？"></a>87.说一下 JSONP 实现原理？</h3><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="九-设计模式模块"><a href="#九-设计模式模块" class="headerlink" title="九. 设计模式模块"></a>九. 设计模式模块</h2><h3 id="88-说一下你熟悉的设计模式？"><a href="#88-说一下你熟悉的设计模式？" class="headerlink" title="88.说一下你熟悉的设计模式？"></a>88.说一下你熟悉的设计模式？</h3><p>单例模式：保证被创建一次，节省系统开销。<br>工厂模式（简单工厂、抽象工厂）：解耦代码。<br>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。<br>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。<br>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。<br>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<h3 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89.简单工厂和抽象工厂有什么区别？"></a>89.简单工厂和抽象工厂有什么区别？</h3><p>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。<br>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。<br>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。<br>···</p>
<p>====================================================================</p>
<h2 id="十-Spring-Spring-MVC模块"><a href="#十-Spring-Spring-MVC模块" class="headerlink" title="十. Spring/Spring MVC模块"></a>十. Spring/Spring MVC模块</h2><h3 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90.为什么要使用 spring？"></a>90.为什么要使用 spring？</h3><p>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p>
<h3 id="91-解释一下什么是-aop？"><a href="#91-解释一下什么是-aop？" class="headerlink" title="91.解释一下什么是 aop？"></a>91.解释一下什么是 aop？</h3><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>
<h3 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92.解释一下什么是 ioc？"></a>92.解释一下什么是 ioc？</h3><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。<br>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>
<h3 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93.spring 有哪些主要模块？"></a>93.spring 有哪些主要模块？</h3><p>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。<br>spring dao：Data Access Object 提供了JDBC的抽象层。<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。<br>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。<br>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p>
<h3 id="94-spring-常用的注入方式有哪些？"><a href="#94-spring-常用的注入方式有哪些？" class="headerlink" title="94.spring 常用的注入方式有哪些？"></a>94.spring 常用的注入方式有哪些？</h3><p>setter 属性注入<br>构造方法注入<br>注解方式注入</p>
<h3 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95.spring 中的 bean 是线程安全的吗？"></a>95.spring 中的 bean 是线程安全的吗？</h3><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<p>有状态就是有数据存储功能。<br>无状态就是不会保存数据。</p>
<h3 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96.spring 支持几种 bean 的作用域？"></a>96.spring 支持几种 bean 的作用域？</h3><p>spring 支持 5 种作用域，如下：</p>
<p>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；<br>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；<br>request：每次 http 请求都会创建一个 bean；<br>session：同一个 http session 共享一个 bean 实例；<br>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。<br>注意：使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h3 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97.spring 自动装配 bean 有哪些方式？"></a>97.spring 自动装配 bean 有哪些方式？</h3><p>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。<br>byName：它根据 bean 的名称注入对象依赖项。<br>byType：它根据类型注入对象依赖项。<br>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。<br>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</p>
<h3 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98.spring 事务实现方式有哪些？"></a>98.spring 事务实现方式有哪些？</h3><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。<br>编码方式：提供编码的形式管理和维护事务。</p>
<h3 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99.说一下 spring 的事务隔离？"></a>99.说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；<br>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；<br>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；<br>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；<br>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100.说一下 spring mvc 运行流程？"></a>100.说一下 spring mvc 运行流程？</h3><p>spring mvc 先将请求发送给 DispatcherServlet。<br>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。<br>DispatcherServlet 再把请求提交到对应的 Controller。<br>Controller 进行业务逻辑处理后，会返回一个ModelAndView。<br>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。<br>视图对象负责渲染返回给客户端。</p>
<h3 id="101-spring-mvc-有哪些组件？"><a href="#101-spring-mvc-有哪些组件？" class="headerlink" title="101.spring mvc 有哪些组件？"></a>101.spring mvc 有哪些组件？</h3><p>前置控制器 DispatcherServlet。<br>映射控制器 HandlerMapping。<br>处理器 Controller。<br>模型和视图 ModelAndView。<br>视图解析器 ViewResolver。</p>
<h3 id="102-RequestMapping-的作用是什么？"><a href="#102-RequestMapping-的作用是什么？" class="headerlink" title="102.@RequestMapping 的作用是什么？"></a>102.@RequestMapping 的作用是什么？</h3><p>将 http 请求映射到相应的类/方法上。</p>
<h3 id="103-Autowired-的作用是什么？"><a href="#103-Autowired-的作用是什么？" class="headerlink" title="103.@Autowired 的作用是什么？"></a>103.@Autowired 的作用是什么？</h3><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="十一-Spring-Boot-Spring-Cloud模块"><a href="#十一-Spring-Boot-Spring-Cloud模块" class="headerlink" title="十一. Spring Boot/Spring Cloud模块"></a>十一. Spring Boot/Spring Cloud模块</h2><h3 id="104-什么是-spring-boot？"><a href="#104-什么是-spring-boot？" class="headerlink" title="104.什么是 spring boot？"></a>104.什么是 spring boot？</h3><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>
<h3 id="105-为什么要用-spring-boot？"><a href="#105-为什么要用-spring-boot？" class="headerlink" title="105.为什么要用 spring boot？"></a>105.为什么要用 spring boot？</h3><p>配置简单<br>独立运行<br>自动装配<br>无代码生成和 xml 配置<br>提供应用监控<br>易上手<br>提升开发效率</p>
<h3 id="106-spring-boot-核心配置文件是什么？"><a href="#106-spring-boot-核心配置文件是什么？" class="headerlink" title="106.spring boot 核心配置文件是什么？"></a>106.spring boot 核心配置文件是什么？</h3><p>spring boot 核心的两个配置文件：</p>
<p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</p>
<h3 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#107-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="107.spring boot 配置文件有哪几种类型？它们有什么区别？"></a>107.spring boot 配置文件有哪几种类型？它们有什么区别？</h3><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>properties 配置如下：</p>
<p>spring. RabbitMQ. port=5672<br>yml 配置如下：</p>
<p>spring:<br>RabbitMQ:<br>port: 5672</p>
<p>yml 格式不支持 @PropertySource 注解导入。</p>
<h3 id="108-spring-boot-有哪些方式可以实现热部署？"><a href="#108-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="108.spring boot 有哪些方式可以实现热部署？"></a>108.spring boot 有哪些方式可以实现热部署？</h3><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p>
<h3 id="109-jpa-和-hibernate-有什么区别？"><a href="#109-jpa-和-hibernate-有什么区别？" class="headerlink" title="109.jpa 和 hibernate 有什么区别？"></a>109.jpa 和 hibernate 有什么区别？</h3><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>
<h3 id="110-什么是-spring-cloud？"><a href="#110-什么是-spring-cloud？" class="headerlink" title="110.什么是 spring cloud？"></a>110.什么是 spring cloud？</h3><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
<h3 id="111-spring-cloud-断路器的作用是什么？"><a href="#111-spring-cloud-断路器的作用是什么？" class="headerlink" title="111.spring cloud 断路器的作用是什么？"></a>111.spring cloud 断路器的作用是什么？</h3><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h3 id="112-spring-cloud-的核心组件有哪些？"><a href="#112-spring-cloud-的核心组件有哪些？" class="headerlink" title="112.spring cloud 的核心组件有哪些？"></a>112.spring cloud 的核心组件有哪些？</h3><p>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。<br>···</p>
<p>====================================================================</p>
<h2 id="十二-Hibernate模块"><a href="#十二-Hibernate模块" class="headerlink" title="十二. Hibernate模块"></a>十二. Hibernate模块</h2><h3 id="113-为什么要使用-hibernate？"><a href="#113-为什么要使用-hibernate？" class="headerlink" title="113.为什么要使用 hibernate？"></a>113.为什么要使用 hibernate？</h3><p>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。</p>
<h3 id="114-什么是-ORM-框架？"><a href="#114-什么是-ORM-框架？" class="headerlink" title="114.什么是 ORM 框架？"></a>114.什么是 ORM 框架？</h3><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>
<h3 id="115-hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="115.hibernate 中如何在控制台查看打印的 SQL 语句？"></a>115.hibernate 中如何在控制台查看打印的 SQL 语句？</h3><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>
<h3 id="116-hibernate-有几种查询方式？"><a href="#116-hibernate-有几种查询方式？" class="headerlink" title="116.hibernate 有几种查询方式？"></a>116.hibernate 有几种查询方式？</h3><p>三种：hql、原生 SQL、条件查询 Criteria。</p>
<h3 id="117-hibernate-实体类可以被定义为-final-吗？"><a href="#117-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="117.hibernate 实体类可以被定义为 final 吗？"></a>117.hibernate 实体类可以被定义为 final 吗？</h3><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>
<h3 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h3><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>
<h3 id="119-hibernate-是如何工作的？"><a href="#119-hibernate-是如何工作的？" class="headerlink" title="119.hibernate 是如何工作的？"></a>119.hibernate 是如何工作的？</h3><p>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。</p>
<h3 id="120-get-和-load-的区别？"><a href="#120-get-和-load-的区别？" class="headerlink" title="120.get()和 load()的区别？"></a>120.get()和 load()的区别？</h3><p>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。</p>
<h3 id="121-说一下-hibernate-的缓存机制？"><a href="#121-说一下-hibernate-的缓存机制？" class="headerlink" title="121.说一下 hibernate 的缓存机制？"></a>121.说一下 hibernate 的缓存机制？</h3><p>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p>
<h3 id="122-hibernate-对象有哪些状态？"><a href="#122-hibernate-对象有哪些状态？" class="headerlink" title="122.hibernate 对象有哪些状态？"></a>122.hibernate 对象有哪些状态？</h3><p>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。</p>
<h3 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h3><p>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p>
<h3 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="124.hibernate 实体类必须要有无参构造函数吗？为什么？"></a>124.hibernate 实体类必须要有无参构造函数吗？为什么？</h3><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="十三-MyBatis模块"><a href="#十三-MyBatis模块" class="headerlink" title="十三. MyBatis模块"></a>十三. MyBatis模块</h2><h3 id="125-MyBatis-中-和-的区别是什么？"><a href="#125-MyBatis-中-和-的区别是什么？" class="headerlink" title="125.MyBatis 中 #{}和 ${}的区别是什么？"></a>125.MyBatis 中 #{}和 ${}的区别是什么？</h3><p>#{}是预编译处理，${}是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p>
<h3 id="126-MyBatis-有几种分页方式？"><a href="#126-MyBatis-有几种分页方式？" class="headerlink" title="126.MyBatis 有几种分页方式？"></a>126.MyBatis 有几种分页方式？</h3><p>分页方式：逻辑分页和物理分页。<br>逻辑分页：使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页：自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
<h3 id="127-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="127.RowBounds 是一次性查询全部结果吗？为什么？"></a>127.RowBounds 是一次性查询全部结果吗？为什么？</h3><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a href="http://t" target="_blank" rel="noopener">http://t</a>. cn/EfSE2g3</p>
<h3 id="128-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#128-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="128.MyBatis 逻辑分页和物理分页的区别是什么？"></a>128.MyBatis 逻辑分页和物理分页的区别是什么？</h3><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p>
<h3 id="129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h3><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>
<h3 id="130-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="130.说一下 MyBatis 的一级缓存和二级缓存？"></a>130.说一下 MyBatis 的一级缓存和二级缓存？</h3><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h3 id="131-MyBatis-和-hibernate-的区别有哪些？"><a href="#131-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="131.MyBatis 和 hibernate 的区别有哪些？"></a>131.MyBatis 和 hibernate 的区别有哪些？</h3><p>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。<br>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。<br>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p>
<h3 id="132-MyBatis-有哪些执行器（Executor）？"><a href="#132-MyBatis-有哪些执行器（Executor）？" class="headerlink" title="132.MyBatis 有哪些执行器（Executor）？"></a>132.MyBatis 有哪些执行器（Executor）？</h3><p>MyBatis 有三种基本的Executor执行器：</p>
<p>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p>
<h3 id="133-MyBatis-分页插件的实现原理是什么？"><a href="#133-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="133.MyBatis 分页插件的实现原理是什么？"></a>133.MyBatis 分页插件的实现原理是什么？</h3><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h3 id="134-MyBatis-如何编写一个自定义插件？"><a href="#134-MyBatis-如何编写一个自定义插件？" class="headerlink" title="134.MyBatis 如何编写一个自定义插件？"></a>134.MyBatis 如何编写一个自定义插件？</h3><p>自定义插件实现原理：</p>
<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键：<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"><span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例：<br>官方插件实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor. <span class="class"><span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>,</span><br><span class="line">args = &#123;MappedStatement. <span class="class"><span class="keyword">class</span>, <span class="title">Object</span>. <span class="title">class</span>, <span class="title">RowBounds</span>. <span class="title">class</span>, <span class="title">ResultHandler</span>. <span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line"><span class="comment">// do something . . . . . . 方法拦截前执行代码块</span></span><br><span class="line">Object result = invocation. proceed();</span><br><span class="line"><span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>====================================================================</p>
<h2 id="十四-RabbitMQ模块"><a href="#十四-RabbitMQ模块" class="headerlink" title="十四. RabbitMQ模块"></a>十四. RabbitMQ模块</h2><h3 id="135-RabbitMQ-的使用场景有哪些？"><a href="#135-RabbitMQ-的使用场景有哪些？" class="headerlink" title="135.RabbitMQ 的使用场景有哪些？"></a>135.RabbitMQ 的使用场景有哪些？</h3><p>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p>
<h3 id="136-RabbitMQ-有哪些重要的角色？"><a href="#136-RabbitMQ-有哪些重要的角色？" class="headerlink" title="136.RabbitMQ 有哪些重要的角色？"></a>136.RabbitMQ 有哪些重要的角色？</h3><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<p>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p>
<h3 id="137-RabbitMQ-有哪些重要的组件？"><a href="#137-RabbitMQ-有哪些重要的组件？" class="headerlink" title="137.RabbitMQ 有哪些重要的组件？"></a>137.RabbitMQ 有哪些重要的组件？</h3><p>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</p>
<p>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</p>
<h3 id="138-RabbitMQ-中-vhost-的作用是什么？"><a href="#138-RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="138.RabbitMQ 中 vhost 的作用是什么？"></a>138.RabbitMQ 中 vhost 的作用是什么？</h3><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>
<h3 id="139-RabbitMQ-的消息是怎么发送的？"><a href="#139-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="139.RabbitMQ 的消息是怎么发送的？"></a>139.RabbitMQ 的消息是怎么发送的？</h3><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h3 id="140-RabbitMQ-怎么保证消息的稳定性？"><a href="#140-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="140.RabbitMQ 怎么保证消息的稳定性？"></a>140.RabbitMQ 怎么保证消息的稳定性？</h3><p>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。</p>
<h3 id="141-RabbitMQ-怎么避免消息丢失？"><a href="#141-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="141.RabbitMQ 怎么避免消息丢失？"></a>141.RabbitMQ 怎么避免消息丢失？</h3><p>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p>
<h3 id="142-要保证消息持久化成功的条件有哪些？"><a href="#142-要保证消息持久化成功的条件有哪些？" class="headerlink" title="142.要保证消息持久化成功的条件有哪些？"></a>142.要保证消息持久化成功的条件有哪些？</h3><p>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</p>
<h3 id="143-RabbitMQ-持久化有什么缺点？"><a href="#143-RabbitMQ-持久化有什么缺点？" class="headerlink" title="143.RabbitMQ 持久化有什么缺点？"></a>143.RabbitMQ 持久化有什么缺点？</h3><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
<h3 id="144-RabbitMQ-有几种广播类型？"><a href="#144-RabbitMQ-有几种广播类型？" class="headerlink" title="144.RabbitMQ 有几种广播类型？"></a>144.RabbitMQ 有几种广播类型？</h3><p>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p>
<h3 id="145-RabbitMQ-怎么实现延迟消息队列？"><a href="#145-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="145.RabbitMQ 怎么实现延迟消息队列？"></a>145.RabbitMQ 怎么实现延迟消息队列？</h3><p>延迟队列的实现有两种方式：</p>
<p>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p>
<h3 id="146-RabbitMQ-集群有什么用？"><a href="#146-RabbitMQ-集群有什么用？" class="headerlink" title="146.RabbitMQ 集群有什么用？"></a>146.RabbitMQ 集群有什么用？</h3><p>集群主要有以下两个用途：</p>
<p>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。</p>
<h3 id="147-RabbitMQ-节点的类型有哪些？"><a href="#147-RabbitMQ-节点的类型有哪些？" class="headerlink" title="147.RabbitMQ 节点的类型有哪些？"></a>147.RabbitMQ 节点的类型有哪些？</h3><p>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p>
<h3 id="148-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="148.RabbitMQ 集群搭建需要注意哪些问题？"></a>148.RabbitMQ 集群搭建需要注意哪些问题？</h3><p>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。</p>
<h3 id="149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="149.RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>149.RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h3><p>不是，原因有以下两个：</p>
<p>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p>
<h3 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h3><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<p>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<h3 id="151-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="151.RabbitMQ 对集群节点停止顺序有要求吗？"></a>151.RabbitMQ 对集群节点停止顺序有要求吗？</h3><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="十五-Kafka"><a href="#十五-Kafka" class="headerlink" title="十五. Kafka"></a>十五. Kafka</h2><h3 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152.kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152.kafka 可以脱离 zookeeper 单独使用吗？为什么？</h3><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
<h3 id="153-kafka-有几种数据保留的策略？"><a href="#153-kafka-有几种数据保留的策略？" class="headerlink" title="153.kafka 有几种数据保留的策略？"></a>153.kafka 有几种数据保留的策略？</h3><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
<h3 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h3><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
<h3 id="155-什么情况会导致-kafka-运行变慢？"><a href="#155-什么情况会导致-kafka-运行变慢？" class="headerlink" title="155.什么情况会导致 kafka 运行变慢？"></a>155.什么情况会导致 kafka 运行变慢？</h3><p>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈</p>
<h3 id="156-使用-kafka-集群需要注意什么？"><a href="#156-使用-kafka-集群需要注意什么？" class="headerlink" title="156.使用 kafka 集群需要注意什么？"></a>156.使用 kafka 集群需要注意什么？</h3><p>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="十六-Zookeeper模块"><a href="#十六-Zookeeper模块" class="headerlink" title="十六. Zookeeper模块"></a>十六. Zookeeper模块</h2><h3 id="157-zookeeper-是什么？"><a href="#157-zookeeper-是什么？" class="headerlink" title="157.zookeeper 是什么？"></a>157.zookeeper 是什么？</h3><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h3 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158.zookeeper 都有哪些功能？"></a>158.zookeeper 都有哪些功能？</h3><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p>
<h3 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159.zookeeper 有几种部署模式？"></a>159.zookeeper 有几种部署模式？</h3><p>zookeeper 有三种部署模式：</p>
<p>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p>
<h3 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160.zookeeper 怎么保证主从节点的状态同步？"></a>160.zookeeper 怎么保证主从节点的状态同步？</h3><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h3 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161.集群中为什么要有主节点？"></a>161.集群中为什么要有主节点？</h3><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
<h3 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h3><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
<h3 id="163-说一下-zookeeper-的通知机制？"><a href="#163-说一下-zookeeper-的通知机制？" class="headerlink" title="163.说一下 zookeeper 的通知机制？"></a>163.说一下 zookeeper 的通知机制？</h3><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="十七-MySQL模块"><a href="#十七-MySQL模块" class="headerlink" title="十七. MySQL模块"></a>十七. MySQL模块</h2><h3 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164.数据库的三范式是什么？"></a>164.数据库的三范式是什么？</h3><p>第一范式（1NF）：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式（2NF）：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。（在1NF基础上消除非主属性对主键的部分函数依赖）<br>第三范式（3NF）：任何非主属性不依赖于其它非主属性。（在2NF基础上消除传递依赖）</p>
<h3 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h3><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h3 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166.如何获取当前数据库版本？"></a>166.如何获取当前数据库版本？</h3><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h3 id="167-说一下-ACID-是什么？"><a href="#167-说一下-ACID-是什么？" class="headerlink" title="167.说一下 ACID 是什么？"></a>167.说一下 ACID 是什么？</h3><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h3 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168.char 和 varchar 的区别是什么？"></a>168.char 和 varchar 的区别是什么？</h3><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h3 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169.float 和 double 的区别是什么？"></a>169.float 和 double 的区别是什么？</h3><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。<br>170.MySQL 的内连接、左连接、右连接有什么区别？<br>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h3 id="171-MySQL-索引是怎么实现的？"><a href="#171-MySQL-索引是怎么实现的？" class="headerlink" title="171.MySQL 索引是怎么实现的？"></a>171.MySQL 索引是怎么实现的？</h3><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h3 id="172-怎么验证-MySQL-的索引是否满足需求？"><a href="#172-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="172.怎么验证 MySQL 的索引是否满足需求？"></a>172.怎么验证 MySQL 的索引是否满足需求？</h3><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type=1。</p>
<h3 id="173-说一下数据库的事务隔离？"><a href="#173-说一下数据库的事务隔离？" class="headerlink" title="173.说一下数据库的事务隔离？"></a>173.说一下数据库的事务隔离？</h3><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p>
<p>transaction-isolation = REPEATABLE-READ<br>1<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="174-说一下-MySQL-常用的引擎？"><a href="#174-说一下-MySQL-常用的引擎？" class="headerlink" title="174.说一下 MySQL 常用的引擎？"></a>174.说一下 MySQL 常用的引擎？</h3><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(<em>) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。<br>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(</em>) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h3 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175.说一下 MySQL 的行锁和表锁？"></a>175.说一下 MySQL 的行锁和表锁？</h3><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<h3 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176.说一下乐观锁和悲观锁？"></a>176.说一下乐观锁和悲观锁？</h3><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h3 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177.MySQL 问题排查都有哪些手段？"></a>177.MySQL 问题排查都有哪些手段？</h3><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p>
<h3 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178.如何做 MySQL 的性能优化？"></a>178.如何做 MySQL 的性能优化？</h3><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。<br>选择正确的存储引擎。<br>···</p>
<p>====================================================================</p>
<h2 id="十八-Redis模块"><a href="#十八-Redis模块" class="headerlink" title="十八. Redis模块"></a>十八. Redis模块</h2><h3 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179.Redis 是什么？都有哪些使用场景？"></a>179.Redis 是什么？都有哪些使用场景？</h3><p>Redis 是一个使用 C 语言开发的高速缓存数据库。<br>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave主从同步【主从同步：数据可以从主服务器向任意数量的从服务器上同步】。<br>Redis 是一个高性能的key-value数据库。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。<br>Redis 使用场景：</p>
<p>记录帖子点赞数、点击数、评论数；<br>缓存近期热帖；<br>缓存文章详情信息；<br>记录用户会话信息。</p>
<h3 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180.Redis 有哪些功能？"></a>180.Redis 有哪些功能？</h3><p>数据缓存功能<br>分布式锁的功能<br>支持数据持久化<br>支持事务<br>支持消息队列</p>
<h3 id="181-Redis-和-memcache-有什么区别？"><a href="#181-Redis-和-memcache-有什么区别？" class="headerlink" title="181.Redis 和 memcache 有什么区别？"></a>181.Redis 和 memcache 有什么区别？</h3><p>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。<br>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。<br>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p>
<h3 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182.Redis 为什么是单线程的？"></a>182.Redis 为什么是单线程的？</h3><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。而且单线程并不代表就慢， nginx 和 node.js 也都是高性能单线程的代表。</p>
<h3 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183.什么是缓存穿透？怎么解决？"></a>183.什么是缓存穿透？怎么解决？</h3><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。<br>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h3 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184.Redis 支持的数据类型有哪些？"></a>184.Redis 支持的数据类型有哪些？</h3><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>
<h3 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185.Redis 支持的 Java 客户端都有哪些？"></a>185.Redis 支持的 Java 客户端都有哪些？</h3><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>
<h3 id="186-jedis-和-Redisson-有哪些区别？"><a href="#186-jedis-和-Redisson-有哪些区别？" class="headerlink" title="186.jedis 和 Redisson 有哪些区别？"></a>186.jedis 和 Redisson 有哪些区别？</h3><p>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p>
<h3 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187.怎么保证缓存和数据库数据的一致性？"></a>187.怎么保证缓存和数据库数据的一致性？</h3><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p>
<h3 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188.Redis 持久化有几种方式？"></a>188.Redis 持久化有几种方式？</h3><p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<p>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。<br>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p>
<h3 id="189-Redis-怎么实现分布式锁？"><a href="#189-Redis-怎么实现分布式锁？" class="headerlink" title="189.Redis 怎么实现分布式锁？"></a>189.Redis 怎么实现分布式锁？</h3><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。<br>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
<h3 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190.Redis 分布式锁有什么缺陷？"></a>190.Redis 分布式锁有什么缺陷？</h3><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h3 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191.Redis 如何做内存优化？"></a>191.Redis 如何做内存优化？</h3><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>
<h3 id="192-Redis-淘汰策略有哪些？"><a href="#192-Redis-淘汰策略有哪些？" class="headerlink" title="192.Redis 淘汰策略有哪些？"></a>192.Redis 淘汰策略有哪些？</h3><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。</p>
<h3 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193.Redis 常见的性能问题有哪些？该如何解决？"></a>193.Redis 常见的性能问题有哪些？该如何解决？</h3><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>
<p>···</p>
<p>====================================================================</p>
<h2 id="十九-JVM模块"><a href="#十九-JVM模块" class="headerlink" title="十九. JVM模块"></a>十九. JVM模块</h2><h3 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194.说一下 JVM 的主要组成部分？及其作用？"></a>194.说一下 JVM 的主要组成部分？及其作用？</h3><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用：首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h3 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195.说一下 JVM 运行时数据区？"></a>195.说一下 JVM 运行时数据区？</h3><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
<h3 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196.说一下堆栈的区别？"></a>196.说一下堆栈的区别？</h3><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。</p>
<h3 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197.队列和栈是什么？有什么区别？"></a>197.队列和栈是什么？有什么区别？</h3><p>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
<h3 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198.什么是双亲委派模型？"></a>198.什么是双亲委派模型？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身统一确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：</p>
<p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载libext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h3 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199.说一下类装载的执行过程？"></a>199.说一下类装载的执行过程？</h3><p>类装载分为以下 5 个步骤：</p>
<p>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p>
<h3 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200.怎么判断对象是否可以被回收？"></a>200.怎么判断对象是否可以被回收？</h3><p>一般有两种方法来判断：</p>
<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
<h3 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201.Java 中都有哪些引用类型？"></a>201.Java 中都有哪些引用类型？</h3><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
<h3 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202.说一下 JVM 有哪些垃圾回收算法？"></a>202.说一下 JVM 有哪些垃圾回收算法？</h3><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<br>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。<br>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p>
<h3 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203.说一下 JVM 有哪些垃圾回收器？"></a>203.说一下 JVM 有哪些垃圾回收器？</h3><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>
<h3 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204.详细介绍一下 CMS 垃圾回收器？"></a>204.详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。<br>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h3 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206.简述分代垃圾回收器是怎么工作的？"></a>206.简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。<br>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。<br>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h3 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207.说一下 JVM 调优的工具？"></a>207.说一下 JVM 调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h3 id="208-常用的-JVM-调优的参数都有哪些？"><a href="#208-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="208.常用的 JVM 调优的参数都有哪些？"></a>208.常用的 JVM 调优的参数都有哪些？</h3><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>本文是《大话数据结构》一书的总结笔记，将不断完善。</p>
<p>感谢我的大学C++老师，推荐给我的《大话…》系列书籍，寓教于乐，深入浅出。</p>
<a id="more"></a>

<h2 id="代码无错便是优？"><a href="#代码无错便是优？" class="headerlink" title="代码无错便是优？"></a>代码无错便是优？</h2><p>代码规范</p>
<p>面向对象</p>
<p>复制VS复用</p>
<p>业务的封装</p>
<p>高内聚低耦合</p>
<p>UML类图</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>Q：在实例化问题中，到底应该实例化谁，将来会不会增加实例化对象</p>
<p>将容易变化的地方，用一个单独的类来做这个创造实例的过程，这就是工厂。</p>
<p>工厂通过多态实例化出合适的对象，返回父类的方法实现需要的函数。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>Q：如何解决算法时常变动的情况</p>
<p>策略模式定义并封装了算法家族，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
<p>策略模式类，作为定义所有算法的公共接口与具体策略类的父类，并在上下文类中被调用。不同的算法被封装在具体策略类中。</p>
<h3 id="策略模式与简单工厂模式结合"><a href="#策略模式与简单工厂模式结合" class="headerlink" title="策略模式与简单工厂模式结合"></a>策略模式与简单工厂模式结合</h3><p>Q：如何在策略模式的基础上避免在客户端判断使用哪一个算法</p>
<p>简单工厂模式中，客户端由工厂类实例化出父类的一个具体的子类，既要知道父类，又要知道工厂类。</p>
<p>而策略模式与简单工厂模式结合，由上下文类调用策略算法（接口）类并实例化具体的策略算法类，客户端只需要知道上下文类即可。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p>
<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离</p>
<p>判断是否应该分离出类：多于一个动机去改变一个类，这个类就有多于一个的职责，就应该考虑类的职责分离。</p>
<h2 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h2><p>软件实体（类、模块和函数等等）应允许扩展禁止修改。</p>
<p>开放扩展，封闭修改。</p>
<p>Q：怎样的设计才能面对需求的改变可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本。</p>
<p>无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全的封闭，设计人员必须对他设计的模块应该对哪种变化封闭做出选择。他们必须先猜出最有可能发生的变化种类，然后构造抽象隔离那些变化。</p>
<p>在我们最初编码时，假设不会发生变化。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。</p>
<p>面对需求，对程序的改动是增加新代码进行的，而不是更改现有的代码。</p>
<p>开发人员应该仅对程序中出现频繁变化的那些部分做出抽象，不应对于应用程序中的每一个部分都刻意地进行抽象。拒绝不成熟的抽象和抽象本身同样重要。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><ul>
<li>高层模块不应该依赖低层模块，两个都应该依赖抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
</ul>
<p>依赖倒转是面向对象设计的标志，面向抽象而不是面向细节编程，程序中所有依赖关系都终止于抽象类或者接口，反之则为面向过程。</p>
<h3 id="里世代换原则-LSP"><a href="#里世代换原则-LSP" class="headerlink" title="里世代换原则(LSP)"></a>里世代换原则(LSP)</h3><p>子类型必须能够替换掉他们的父类型。</p>
<p>一个软件实体如果使用的是一个父类的话，那么一定适用与其子类，而且它察觉不出父类对象与子类对象的区别，在软件中，如果把父类替换成它的子类，程序行为没有变化。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰类是为已有功能动态的添加更多功能的一种方式，当系统需要新的功能的时候，是向旧的类中添加新的代码，这些装饰的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度。这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，他把每个装饰类的功能放在单独的类中，并让这个类包装他所要装饰的对象，因此，在执行特殊行为时，客户代码就可以在运行时，根据需要有选择地、按顺序地选择装饰功能包装对象了。</p>
<p>动态地给一些对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<ul>
<li>接口对象类，给这些对象动态的添加职责。</li>
<li>具体的对象类，这个对象本身可以具有一些职责。</li>
<li>抽象装饰类，继承于对象接口类，以达到从外部扩展对象接口类的目的。</li>
<li>具体的装饰对象类，给对象接口类添加职责。</li>
</ul>
<p>装饰模式利用抽象装饰类中的装饰函数来对对象进行包装，这样每个对象的实现就和如何使用这个对象分开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p>
<p>如果只有一个具体的对象类，而没有抽象的接口对象类，那么抽象装饰类可以改成具体的对象类的子类。如果只有一个具体的装饰对象类，那么就没有必要建立一个单独的抽象装饰类，可以把二者的责任合并成一个类。</p>
<p>装饰模式的优点：把类中的装饰功能从类中搬移除去，这样可以简化原有的类。有效的把类的核心功能和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一种代理以控制这个对象的访问</p>
<ul>
<li>抽象实体类，定义了真实实体类和代理类的共用接口，这样就在任何使用真实实体的地方都可以使用代理。</li>
<li>真实实体类，定义了代理类所代表的真实实体。</li>
<li>代理类，继承于抽象实体类，保存一个引用使得代理可以访问真实实体类，并提供一个与实体类（抽象实体类和真实实体类的接口也相同，故这里是实体类）的接口相同的接口，这样代理就可以用来代替实体。</li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>定义一个用来创建对象的接口，让子类用来决定实例化哪一个类。工厂方法使一个类的实例化延伸到其子类。</p>
<ul>
<li>抽象产品接口类，定义工厂方法所创建的对象。</li>
<li>工厂方法类，该方法返回一个产品类类型对象</li>
<li>具体产品类，继承抽象产品接口类，实现了产品接口类的接口</li>
<li>具体重唱方法类，重定义工厂方法以返回一个工厂方法实例</li>
</ul>
<h3 id="简单工厂模式VS工厂方法模式"><a href="#简单工厂模式VS工厂方法模式" class="headerlink" title="简单工厂模式VS工厂方法模式"></a>简单工厂模式VS工厂方法模式</h3><p>简单工厂模式的最大优点在于工厂类中包含的了必要的逻辑判断，根据客户端的选择，动态的实例化相关的类，对于客户端来说，去除对具体产品的依赖。</p>
<p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现类，选择判断的问题还是存在的，也就是说工厂方法把简单的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是该工厂类，而现在是改客户端。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>原型模式其实就是从一个对象再创建另一个可定制的对象，而不需要知道任何创建的细节。</p>
<ul>
<li>原型类，声明一个克隆自身的接口。</li>
<li>具体原型类，继承于原型类，实现一个克隆自身的操作。</li>
</ul>
<p>一般在初始化的信息不发生变化的情况下，克隆是最好的方法。这既隐藏了对象创建的细节，又对性能是大大的提高。不用重新初始化对象，而是动态地获得对象运行时的状态。</p>
<h3 id="浅复制与深复制"><a href="#浅复制与深复制" class="headerlink" title="浅复制与深复制"></a>浅复制与深复制</h3><p><strong>浅复制</strong>：被复制的对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。</p>
<p><strong>深复制</strong>：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以不改变一个算法的结构即可定义该算法的某些特定步骤。</p>
<ul>
<li>抽象模板类，定义了一些抽象行为和实现一个模板方法定义了算法的逻辑骨架，逻辑的组成是一些相应的抽象操作，他们都推迟到子类中实现，具体子类将重定义模板方法中的函数以实现一个算法的步骤。</li>
<li>模板类，继承于抽象模板类，实现抽象模板类中模板方法中的函数以完成算法中与特定子类相关的步骤。</li>
</ul>
<p>模板类，实现抽象模板类所定义的一个或多个抽象方法，每一个抽象模板类都可以有任意多个模板类与之对应，而每一个模板类都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<p>模板方法模式是通过把不变的行为搬移到超类，去除子类中的重复代码来体现他的优势，模板方法模式就是提供了一个很好的代码复用平台。当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复实现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p>
<h2 id="迪米特法则（最少知识原则）"><a href="#迪米特法则（最少知识原则）" class="headerlink" title="迪米特法则（最少知识原则）"></a>迪米特法则（最少知识原则）</h2><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
<p>在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p>
<p>迪米特法则其根本思想，是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这一接口使得这一子系统更加容易使用。</p>
<ul>
<li>外观类，知道哪些子系统类负责处理请求，将客户的请求代理给适当的子系统对象。</li>
<li>子系统类集合，实现子系统的功能，处理外观类对象指派的任务，注意子类中没有外观类的任何信息，即没有对外观类对象的引用。</li>
</ul>
<p>在设计的初期阶段，要有意识的将两不同的两个类分离。</p>
<p>层与层之间建立外观外观类，为复杂的子系统提供一个简单的接口，使得耦合大大降低。</p>
<p>子系统的重构演化越来越复杂时，调用过多的接口会使得程序响应缓慢，增加外观类可以提供一个简单的接口，减少他们之间的依赖。在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但它包含着新系统必须依赖的重要功能，此时可以为系统开发一个外观类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与外观类对象交互，外观类与遗留代码交互所有复杂的工作。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>Q：如何将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式下，用户只需指定需要建造的类型就可以得到它们，而具体的建造细节就不需要知道了。主要用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但内部对象的构建通常面临着复杂的变化。</p>
<p>建造者模式的好处就是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。</p>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<ul>
<li>建造者接口类，作为创建一个产品对象的各个部件指定的抽象接口。</li>
<li>指挥者类，构建一个使用创建者接口的对象。</li>
<li>具体建造者类，实现建造者接口类的接口，构造和装配各个部件。</li>
<li>具体产品类</li>
</ul>
<p>建造设模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式又叫发布-订阅模式</p>
<p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<ul>
<li>抽象主题类：把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>抽象观察者类，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。通常包含一个更新方法。</li>
<li>具体主题类，继承于抽象主题类，将有关状态存入具体观察者对象，在具体主题的内部状态改变时。给所有登记过的观察者发出通知。具体的主题角色通常用一个具体子类实现。</li>
<li>具体观察者，继承于抽象观察者类，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状体相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体的子类实现。</li>
</ul>
<p>将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者模式的关键对象是主题类和观察者类，一个主题类可以有任意数目的依赖它的观察者类，一旦主题类的状态发生了改变，所有的观察者类都可以得到通知，具体观察者是谁，它根本不要知道，而任何一个具体观察者不知道也不需要知道其他观察者的存在。</p>
<p>Q：什么时候应该使用观察者模式？</p>
<p>当一个对象的改变需要同时改变其他对象而且它不知道具体有多少对象有待改变的时候。</p>
<p>一个抽象模式有两个方面，其中一方面依赖于令一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>
<p>观察者模式所作的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。（是依赖倒转原则的最佳体现。）</p>
<p>Q：抽象观察者是否可以用接口来定义？</p>
<p>具体的观察者可能是完全不相及的类，但他们都需要根据通知者的通知来做出更新的操作，让他们实现一个相同的接口就可以实现这个想法了。</p>
<p>Q：如何让每个控件实现一个观察者接口？</p>
<p>没办法，这些控件早已被他们的制造商给封装了，尽管程序已经用了依赖倒转原则，但是“抽象通知者”还是依赖“抽象观察者”，也就是说，万一没有了抽象观察者这样的接口，我这通知功能就完不成了。另外就是每个具体观察者，不一定调用的是同一种更新方法。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>通知者和观察者之间互相不知道，由客户端来决定通知谁。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>如何在github上为开源项目贡献</title>
    <url>/2020/03/03/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%B8%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE/</url>
    <content><![CDATA[<p>以<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">tensorflow</a>为例子介绍如何在<a href="https://github.com/" target="_blank" rel="noopener">github</a>上为一个开源项目做出贡献，进行多人协作编程</p>
<a id="more"></a>

<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>在你需要的项目主页，点击右上角的fork：</p>
<p><img src="/images/pictures/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%B8%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE/1.jpeg" alt="success"></p>
<p>选择你要保存到自己的哪一个仓库：</p>
<p><img src="/images/pictures/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%B8%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE/2.jpeg" alt="success"></p>
<p>稍等fork完成：</p>
<p><img src="/images/pictures/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%B8%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE/3.jpeg" alt="success"></p>
<p>这里This branch is even with xiyouLinuxJavaWeb15:master，表示我们与主分支目前没有任何的差异。</p>
<p>这样我们创建了一个新的<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">tensorflow</a>项目的分支。</p>
<h2 id="把Fork后的远程仓库拉到本地"><a href="#把Fork后的远程仓库拉到本地" class="headerlink" title="把Fork后的远程仓库拉到本地"></a>把Fork后的远程仓库拉到本地</h2><p>利用SSH将仓库克隆至本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:CatJason&#x2F;tensorflow.git</span><br></pre></td></tr></table></figure>

<p>就可以在本地进行编辑改动。</p>
<h2 id="提交Issue"><a href="#提交Issue" class="headerlink" title="提交Issue"></a>提交Issue</h2><p>当我们在本地使用项目时发现了任何问题，提交到分支仓库下Issue中，或邮件致电他人进行沟通。</p>
<p>Issue板块在项目的主分支仓库才有</p>
<p><img src="/images/pictures/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%B8%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE/4.jpeg" alt="success"></p>
<h2 id="提交PR"><a href="#提交PR" class="headerlink" title="提交PR"></a>提交PR</h2><p>等待项目的开发者review你的PR，进行讨论，修改直到符合之后，merge进主分支。</p>
<p>PR板块在我们自己的项目的分支仓库</p>
<p><img src="/images/pictures/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%B8%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE/5.jpeg" alt="success"></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解Javabean的意义</title>
    <url>/2020/03/02/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3Javabean%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>作者：杨博<br>链接：<a href="https://www.zhihu.com/question/19773379/answer/31625054" target="_blank" rel="noopener">https://www.zhihu.com/question/19773379/answer/31625054</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。</p>
<a id="more"></a>

<p>举个例子，假如有人要用Java实现一个单向链表类，可能会这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 java-int-list_1.0.jar</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Node head;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现为了能够快速获取链表的大小，把链表大小缓存在size变量中。用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaIntList myList = <span class="keyword">new</span> JavaIntList();</span><br><span class="line">System.out.println(myList.size);</span><br></pre></td></tr></table></figure>

<p>JavaIntList的作者很满意，于是开源了java-int-list库的1.0版。文件名是java-int-list_1.0.jar。发布后，吸引了许多用户来使用java-int-list_1.0.jar。<br>有一天，作者决定要节省内存，不要缓存size变量了，把代码改成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 java-int-list_2.0.jar</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Node head;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">      n = n.next;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发布了2.0版：java-int-list_2.0.jar。发布后，原有java-int-list_1.0.jar的用户纷纷升级版本到2.0。这些用户一升级，就发现自己的程序全部坏掉了，说是找不到什么size变量。于是这些用户就把作者暴打一顿，再也不敢用java-int-list库了。</p>
<p>这个故事告诉我们，如果不想被暴打致死，你就必须保持向后兼容性。太阳公司在设计Java语言时，也懂得这个道理。所以Java标准库中，绝对不会出现public int size这样的代码，而一定会一开始就写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br></pre></td></tr></table></figure>

<p>让用户一开始就使用getSize，以便有朝一日修改getSize实现时，不破坏向后兼容性。这种public int getSize() { return size; }的惯用手法，就是Java Bean。</p>
<p>现在是2014年，C#、Scala等比Java新的面向对象语言自身就提供了语言特性来实现这些常用需求，所以根本不需要Java Bean这样繁琐的约定。</p>
<p>比如，假如有个Scala版的ScalaIntList：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 scala-int-list_1.0.jar</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">next: <span class="type">Node</span>, value: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">class</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> head: <span class="type">ScalaIntList</span>.<span class="type">Node</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> size: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户这样用：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myList = <span class="keyword">new</span> <span class="type">ScalaIntList</span></span><br><span class="line">println(myList.size)</span><br></pre></td></tr></table></figure>

<p>有一天你心血来潮改成这样：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 scala-int-list_2.0.jar</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">next: <span class="type">Node</span>, value: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">class</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> head: <span class="type">ScalaIntList</span>.<span class="type">Node</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> n = head</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">      n = n.next</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户还是照样能用，根本不破坏向后兼容性。所以Scala程序只要不考虑和Java交互，一般就不需要类似Java Bean这样的约定。</p>
<p>顺便说一句，向后兼容性分为源代码级和二进制级，Scala的var或val改为final def的话，无论源代码级的向后兼容性，还是二进制级的向后兼容性，都不遭受破坏。但C#的字段改为属性的话，虽然不破坏源代码级的向后兼容性，但是会破坏二进制级的向后兼容性。这是C#的设计缺陷，导致微软的编码规范不得不禁止使用公有字段。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>查找与排序</title>
    <url>/2020/03/02/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="查找与排序的关系"><a href="#查找与排序的关系" class="headerlink" title="查找与排序的关系"></a>查找与排序的关系</h2><p>排序的过程</p>
<ol>
<li>选择元素/位置</li>
<li>根据元素<strong>查找</strong>位置/根据位置<strong>查找</strong>元素</li>
<li>排序</li>
</ol>
<p><strong>所以查找是排序的前提，不同的查找方式导致了不同的排序方式</strong></p>
<a id="more"></a>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>根据元素查找位置</p>
<ul>
<li><h6 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a><strong>顺序查找</strong></h6></li>
<li><h6 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a><strong>折半查找</strong></h6></li>
<li><h6 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a><strong>分块查找</strong></h6></li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="根据元素查找位置"><a href="#根据元素查找位置" class="headerlink" title="根据元素查找位置"></a>根据元素查找位置</h4><ul>
<li><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><ul>
<li><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a><strong>直接插入排序</strong></h6><p>顺序查找</p>
</li>
<li><h6 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a><strong>折半插入排序</strong></h6><p>折半查找</p>
</li>
<li><h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h6><p>分块查找</p>
</li>
</ul>
</li>
</ul>
<h4 id="根据位置查找元素"><a href="#根据位置查找元素" class="headerlink" title="根据位置查找元素"></a>根据位置查找元素</h4><ul>
<li><h5 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h5><ul>
<li><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h6><p>选择无序表表尾的位置</p>
</li>
<li><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h6><p>分治思想，一趟排序递归选择多个位置，递归排序</p>
</li>
</ul>
</li>
<li><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><ul>
<li><h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a><strong>简单选择排序</strong></h6><p>选择线性表中无序表表尾位置</p>
</li>
<li><h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h6><p>选择树形结构的根或其子树的根结点</p>
</li>
</ul>
<p>堆排序之所以容易出错，是因为它是上述唯一的<strong>已排序的有序部分会在排序过程中再次变为无序</strong>的排序算法，这也是堆排序的数据结构是树这种递归结构却不能使用分治递归排序的原因。</p>
</li>
</ul>
<h4 id="两种特殊的排序算法"><a href="#两种特殊的排序算法" class="headerlink" title="两种特殊的排序算法"></a>两种特殊的排序算法</h4><ul>
<li><h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h6><p>子表之间是无序的（分治思想中，子表之间是有序的）。</p>
</li>
<li><h6 id="基排序"><a href="#基排序" class="headerlink" title="基排序"></a><strong>基排序</strong></h6><p>已排序的有序部分会在排序过程中再次变为无序，与堆排序不同，不用再次进行排序。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>abc排列组合</title>
    <url>/2018/05/21/n-abc/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><p>输出所有由a,b,c组成的长度为n的字符串，并输出个数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>2</p>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>aa ab ac ba bb bc ca cb cc 9</p>
</blockquote>
<a id="more"></a>

<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">productor</span><span class="params">(<span class="keyword">char</span>* p,<span class="keyword">char</span>* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;=t+n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p=<span class="string">'a'</span>;</span><br><span class="line">        productor(p,t);</span><br><span class="line">        *p=<span class="string">'b'</span>;</span><br><span class="line">        productor(p,t);</span><br><span class="line">        *p=<span class="string">'c'</span>;</span><br><span class="line">        productor(p,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    m = <span class="built_in">pow</span>(<span class="number">3</span>,n);</span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*n);</span><br><span class="line">    <span class="keyword">char</span>* t = p;</span><br><span class="line">    productor(p,t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeedCode</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>landern启动失败</title>
    <url>/2018/05/03/landern/</url>
    <content><![CDATA[<p>Linux – Lantern 无法启动</p>
<p>安装了Lantern之后，不能启动起来，一闪而过，命令行里启动，包如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/.lantern/bin/lantern: error <span class="keyword">while</span> loading shared libraries: libappindicator3.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>尝试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-cache search libappindicator3  </span></span><br><span class="line">  </span><br><span class="line">gir1.2-appindicator3-0.1 - Typelib files <span class="keyword">for</span> libappindicator3-1  </span><br><span class="line">&lt;span style=<span class="string">"margin: 0px; padding: 0px;"</span>&gt;libappindicator3-1&lt;/span&gt; - allow applications to <span class="built_in">export</span> a menu into the panel -- GTK3 version  </span><br><span class="line">libappindicator3-dev - allow applications to <span class="built_in">export</span> a menu into the panel -- GTK3 development</span><br></pre></td></tr></table></figure>

<p>安装  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install libappindicator3-1</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>如何把内容上传区块链</title>
    <url>/2018/04/28/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>公有链是一个完全松散自治的P2P网络，加之区块链本身的设计要求了如果要修改数据，必须要51%的算力支持，因此要删除和篡改是一件几乎不可能的事情。这里是手把手教你怎么把信息保持在以太坊区块链上，永远无法删除。</p>
<a id="more"></a>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>你需要一个以太坊钱包来发起以太坊交易。为了方便起见，这里用metamask。<br><code>Chrome浏览器</code>+<code>metamask插件</code><br><code>Firefox浏览器</code>+<code>metamask插件</code><br>通过搜索，假设你已经安装好了metamask并且已经注册了账户，并且拥有能够支付Gas的以太坊</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>点击metamask图标并输入密码解锁你的metamask钱包：<br><img src="/images/pictures/1/1.jpg" alt="success"><br><img src="/images/pictures/1/2.jpg" alt="success"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>复制你的地址，因为接下来我们需要自己给自己转数值为0的以太币：<br>点击metamask图标并输入密码解锁你的metamask钱包：<br><img src="/images/pictures/1/3.jpg" alt="success"></p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>点击SEND，表示发起一笔交易：<br><img src="/images/pictures/1/4.jpg" alt="success"></p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>在这个网址下<code>https://www.browserling.com/tools/utf8-to-hex</code>输入你想上链的信息，比如这里我输入<code>dapdap.io</code>，点击下面的<code>Convert to Hex</code>，得到<code>dapdap.io</code>这个字符串的16进制<br><img src="/images/pictures/1/5.jpg" alt="success"><br><img src="/images/pictures/1/6.jpg" alt="success"></p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>将那串数据：\x64\x61\x70\x64\x61\x70\x2e\x69\x6f 整理好，即删除所有的 \x ，并在数据前面加上 0x 最后得到一串16进制数：0x6461706461702e696f，复制好，在metamask上发起交易：<br><img src="/images/pictures/1/7.jpg" alt="success"><br>如图，第一栏是地址，这里设置为自己，自己点击输入框它有提示，包括你这个钱包里面的所有地址，选择自己就行。第二栏是转账的以太币数量，设置为0，第三栏为额外数据，这里把我们之前得到的16进制数粘贴进去，主要数据前后不要留空格。点击next</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>设置好Gas Limit和Gas Price，这里因为有额外的数据稍微上调了这两项的默认值。<br><img src="/images/pictures/1/8.jpg" alt="success"></p>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>然后点击SUBMIT，然后点击那三点省略号，可以在etherscan上查看交易数据：<br><img src="/images/pictures/1/9.jpg" alt="success"></p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>跳转到<br><code>https://etherscan.io/tx/0xbefe0212663287faa3a1547e5ac11766e6abf0b56abd50c61984b06df7996f55</code>即可查看交易数据。这些交易数据是保存在以太坊区块链上的，除非以太坊小时，否则永远存在。<br><img src="/images/pictures/1/10.jpg" alt="success"></p>
<h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>然后点击下面的<code>Convert To Ascii</code>按钮，就可以显示我们需要的信息。<br><img src="/images/pictures/1/11.jpg" alt="success"></p>
]]></content>
  </entry>
  <entry>
    <title>make:g++:命令没找到</title>
    <url>/2018/04/20/make-g-%E5%91%BD%E4%BB%A4%E6%B2%A1%E6%89%BE%E5%88%B0/</url>
    <content><![CDATA[<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>make: g++：命令未找到<br>make: *** [outlook.o] 错误 127</p>
<h3 id="Answear"><a href="#Answear" class="headerlink" title="Answear"></a>Answear</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install g++</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BUG</category>
      </categories>
  </entry>
  <entry>
    <title>Install p7zip</title>
    <url>/2018/04/20/install-p7zip/</url>
    <content><![CDATA[<p>P7zip is another name for 7z in Linux.</p>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install p7zip-rar</span><br></pre></td></tr></table></figure>

<h3 id="Unzip"><a href="#Unzip" class="headerlink" title="Unzip"></a>Unzip</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo 7z x manager.7z -r -o/home/Baby/Desktop</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>p7zip</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客图片问题</title>
    <url>/2018/04/15/picture/</url>
    <content><![CDATA[<p>如何在hexo博文中插入图片</p>
<a id="more"></a>

<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>首先确认_config.yml 中有 <code>post_asset_folder:true</code>。<br>Hexo 提供了一种更方便管理 Asset 的设定：<code>post_asset_folder</code><br>当您设置<code>post_asset_folder</code>为true参数后，在建立文件时，Hexo<br>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>在hexo的目录下执行<code>npm install hexo-asset-image --save</code>（需要等待一段时间）。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>完成安装后用<code>hexo</code>新建文章的时候会发现<code>_posts</code>目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本地图片测试</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.jpg</span><br><span class="line">└── rules.jpg</span><br><span class="line">本地图片测试.md</span><br></pre></td></tr></table></figure>

<p>这样的目录结构（目录名和文章名一致），只要使用<code>![logo](本地图片测试/logo.jpg)</code>就可以插入图片。其中[]里面不写文字则没有图片标题。<br>生成的结构为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public/2016/3/9/本地图片测试</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── index.html</span><br><span class="line">├── logo.jpg</span><br><span class="line">└── rules.jpg</span><br></pre></td></tr></table></figure>

<p>同时，生成的<code>html</code>是</p>
<p><code>&lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;</code></p>
<p>而不是愚蠢的</p>
<p><code>&lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;</code></p>
<p>注意:<br>通过常规的<code>markdown</code>语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在<code>Hexo2</code>时代，社区创建了很多插件来解决这个问题。但是，随着<code>Hexo3</code>的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>

<p>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg图片放在了你的资源文件夹中，如果通过使用相对路径的常规<code>markdown</code>语法<code>[](/example.jpg)</code>，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）</p>
<p>正确的引用图片方式是使用下列的标签插件而不是<code>markdown</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>


<h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><p>作者：TSimeon<br>链接：<a href="https://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="noopener">https://www.jianshu.com/p/c2ba9533088a</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Avatar Bug in Theme Next</title>
    <url>/2018/04/06/Avatar-Bug-in-Theme-Next/</url>
    <content><![CDATA[<h3 id="Why-can’t-the-avatar-be-a-rectangle"><a href="#Why-can’t-the-avatar-be-a-rectangle" class="headerlink" title="Why can’t the avatar be a rectangle?"></a>Why can’t the avatar be a rectangle?</h3><p>When I add a head portrait to my blog (edit the theme configuration file, modify the field “Avatar”),but it doesn’s work.Then I google the bug.<br>Unfortunately,it seems that few people have the same problem like me.<br>So,modifying the source code is another way to make my blog has an avatar.<br>Why can’t the avatar be a rectangle?</p>
<a id="more"></a>

<h2 id="The-path"><a href="#The-path" class="headerlink" title="The path"></a>The path</h2><p><code>/themes/next/layout/_macro/sidebar.swig</code></p>
<p><code>/source/css/_common/components/sidebar/sidebar.styl</code></p>
<h2 id="Colors-for-use-across-theme"><a href="#Colors-for-use-across-theme" class="headerlink" title="Colors for use across theme."></a>Colors for use across theme.</h2><p><code>/themes/next/source/css/_variables/base.styl</code></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
