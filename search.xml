<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/14/My-First-Blog/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="其他技术博客的链接"><a href="#其他技术博客的链接" class="headerlink" title="其他技术博客的链接"></a>其他技术博客的链接</h2><h3 id="『字节跳动』『android』"><a href="#『字节跳动』『android』" class="headerlink" title="『字节跳动』『android』"></a>『字节跳动』『android』</h3><p><a href="http://gityuan.com/" target="_blank" rel="noopener">http://gityuan.com/</a></p>
<h3 id="『西北工业大学』『硕士』"><a href="#『西北工业大学』『硕士』" class="headerlink" title="『西北工业大学』『硕士』"></a>『西北工业大学』『硕士』</h3><p><a href="https://qiming.info/" target="_blank" rel="noopener">https://qiming.info/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android组件化架构：路由转跳</title>
    <url>/2020/08/18/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%BD%AC%E8%B7%B3/</url>
    <content><![CDATA[<p>《Android组件化架构》</p>
<p>本文将对《Android组件化架构》中组件间转跳章节做知识点提炼，重点解析路由转跳和原理。</p>
<p>将不局限于书中ARouter等常见路由，待搜集其他资料后再做补充完善。</p>
<a id="more"></a>

<h2 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h2><p><strong>路由</strong>（计算机网络中）：路由器从一个接口上收到数据包，根据数据路由包的目的地址进行定向并转发到另一个接口的过程。</p>
<p><strong>路由器</strong>（计算机网络中）：路由器用于连接多个逻辑的分开的网络。</p>
<p>知识迁移到Android</p>
<p><strong>路由</strong>：从一个module向另一个module定向转发数据。</p>
<p><strong>Router</strong>：连接各个module中页面转跳的中转站。可以拦截不安全的转跳或者设定一些特定的拦截服务。</p>
<h2 id="原生转跳和路由转跳的差异"><a href="#原生转跳和路由转跳的差异" class="headerlink" title="原生转跳和路由转跳的差异"></a>原生转跳和路由转跳的差异</h2><p>参考文献</p>
<p>《Android组件化架构》————————————————————–中国公信出版社-苍王-2018</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>「转」单例模式DCL</title>
    <url>/2020/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FDCL/</url>
    <content><![CDATA[<p>原文连接：<a href="https://www.cnblogs.com/xz816111/p/8470048.html" target="_blank" rel="noopener">Java中的双重检查锁（double checked locking）</a></p>
<p>作者：<a href="https://home.cnblogs.com/u/xz816111/" target="_blank" rel="noopener">Decouple</a></p>
<a id="more"></a>

<p><strong>双检锁/双重校验锁（DCL，即 double-checked locking）</strong></p>
<p><strong>JDK 版本：</strong>JDK1.5 起</p>
<p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>较复杂</p>
<p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>在实现单例模式时，如果未考虑多线程的情况，就容易写出下面的错误代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程的情况下，这样写可能会导致<code>uniqueSingleton</code>有多个实例。比如下面这种情况，考虑有两个线程同时调用<code>getInstance()</code>：</p>
<table>
<thead>
<tr>
<th align="left">Time</th>
<th align="left">Thread A</th>
<th align="left">Thread B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">检查到<code>uniqueSingleton</code>为空</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"></td>
<td align="left">检查到<code>uniqueSingleton</code>为空</td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left">初始化对象<code>A</code></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">返回对象<code>A</code></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left">初始化对象<code>B</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">返回对象<code>B</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>可以看到，<code>uniqueSingleton</code>被实例化了两次并且被不同对象持有。完全违背了单例的初衷。</p>
<h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>出现这种情况，第一反应就是加锁，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然解决了问题，但是因为用到了<code>synchronized</code>，会导致很大的性能开销，并且加锁其实只需要在第一次初始化的时候用到，之后的调用都没必要再进行加锁。</p>
<h1 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h1><p>双重检查锁（double checked locking）是对上述问题的一种优化。先判断对象是否已经被初始化，再决定要不要加锁。</p>
<h2 id="错误的双重检查锁"><a href="#错误的双重检查锁" class="headerlink" title="错误的双重检查锁"></a>错误的双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();   <span class="comment">// error</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样写，运行顺序就成了：</p>
<ol>
<li>检查变量是否被初始化(不去获得锁)，如果已被初始化则立即返回。</li>
<li>获取锁。</li>
<li>再次检查变量是否已经被初始化，如果还没被初始化就初始化一个对象。</li>
</ol>
<p>执行双重检查是因为，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。</p>
<p>这样，除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题。</p>
<h3 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h3><p>上述写法看似解决了问题，但是有个很大的隐患。实例化对象的那行代码（标记为error的那行），实际上可以分解成以下三个步骤：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向刚分配的内存空间</li>
</ol>
<p>但是有些编译器为了性能的原因，可能会将第二步和第三步进行<strong>重排序</strong>，顺序就成了：</p>
<ol>
<li>分配内存空间</li>
<li>将对象指向刚分配的内存空间</li>
<li>初始化对象</li>
</ol>
<p>现在考虑重排序后，两个线程发生了以下调用：</p>
<table>
<thead>
<tr>
<th align="left">Time</th>
<th align="left">Thread A</th>
<th align="left">Thread B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">检查到<code>uniqueSingleton</code>为空</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">获取锁</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">再次检查到<code>uniqueSingleton</code>为空</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left">为<code>uniqueSingleton</code>分配内存空间</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left">将<code>uniqueSingleton</code>指向内存空间</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"></td>
<td align="left">检查到<code>uniqueSingleton</code>不为空</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left"></td>
<td align="left">访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">初始化<code>uniqueSingleton</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在这种情况下，T7时刻线程B对<code>uniqueSingleton</code>的访问，访问的是一个<strong>初始化未完成</strong>的对象。</p>
<h2 id="正确的双重检查锁"><a href="#正确的双重检查锁" class="headerlink" title="正确的双重检查锁"></a>正确的双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决上述问题，需要在<code>uniqueSingleton</code>前加入关键字<code>volatile</code>。使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p>
<p>至此，双重检查锁就可以完美工作了。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/双重检查锁定模式" target="_blank" rel="noopener">双重检查锁定模式</a></li>
<li><a href="http://www.importnew.com/12196.html" target="_blank" rel="noopener">如何在Java中使用双重检查锁实现单例</a></li>
<li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#anch136785" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>「转」APP启动方式:冷启动和热启动</title>
    <url>/2020/08/13/APP%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E5%86%B7%E5%90%AF%E5%8A%A8%E5%92%8C%E7%83%AD%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>作者：王伟desire<br>链接：<a href="https://www.jianshu.com/p/8ba3d576f16a" target="_blank" rel="noopener">https://www.jianshu.com/p/8ba3d576f16a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<a id="more"></a>

<ol>
<li><h3 id="一、APP启动方式"><a href="#一、APP启动方式" class="headerlink" title="一、APP启动方式"></a>一、APP启动方式</h3><p>通常来说，APP中启动方式分为两种：冷启动和热启动。</p>
<h6 id="1-冷启动："><a href="#1-冷启动：" class="headerlink" title="1.冷启动："></a>1.冷启动：</h6><p>当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。</p>
<h5 id="2-热启动："><a href="#2-热启动：" class="headerlink" title="2.热启动："></a>2.热启动：</h5><p>当启动应用时，后台已有该应用的进程（例：按back键/home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。</p>
<p>请注意：上面说的启动是点击app的启动图标来启动的，而另外一种方式是进入最近使用的列表界面来启动应用，这种不应该叫启动，应该叫恢复。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>「转」Android各存储方式对比</title>
    <url>/2020/08/12/Android%E5%90%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>作者：篱开罗<br>链接：<a href="https://www.jianshu.com/p/d9dde3f59be5" target="_blank" rel="noopener">https://www.jianshu.com/p/d9dde3f59be5</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<a id="more"></a>

<h2 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h2><p>SharedPreferences使用键值对的形式保存原始类型的数据</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取以Activity类名命名的SharedPreferences</span></span><br><span class="line">mActivityPreferences = getPreferences(MODE_PRIVATE);</span><br><span class="line"><span class="comment">// 获取自己命名的SharedPreferences</span></span><br><span class="line">mSharedPreferences = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE);        </span><br><span class="line"></span><br><span class="line">SharedPreferences.Editor editor = mSharedPreferences.edit();</span><br><span class="line">editor.putString(<span class="string">"hello"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 同步方式,会立即阻塞，将数据持久化</span></span><br><span class="line"><span class="comment">// editor.commit();</span></span><br><span class="line"><span class="comment">// 异步方式，会先存到内存，再异步的将数据持久化</span></span><br><span class="line">editor.apply();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取数据，第一个参数为键，第二个参数为默认值</span></span><br><span class="line">String data = mSharedPreferences.getString(<span class="string">"hello"</span>,<span class="string">"data miss"</span>);</span><br><span class="line">mDisplayTv.setText(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据变化监听器</span></span><br><span class="line">mSharedPreferences.registerOnSharedPreferenceChangeListener(</span><br><span class="line">                <span class="keyword">new</span> SharedPreferences.OnSharedPreferenceChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSharedPreferenceChanged</span><span class="params">(SharedPreferences sharedPreferences, String key)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                        sharedPreferences.getString(key, <span class="string">"miss"</span>), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SharedPreferences和内嵌的Editor其实都只是接口定义而已，并没有实现任何方法。它只是用来制定了一个存储键值对的协议，具体的实现方式和存储形式可以是任意的。在Android系统中，它默认以XML格式的文件来存储这些数据，实现的类则是SharedPreferencesImpl</p>
<p>xml文件形式,保存在/data/data/(packagename)/shared_prefs/，需有root权限才能查看</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>数据的获取较快，而数据写入由于io原因使用commit()会花费一些时间，可用apply()进行异步存储。适合存储量小、简单的数据。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>使用文件进行数据持久化，分为使用内部存储和外部存储，这边的内部存储和外部存储比较容易产生歧义。打开ddms可以看到data、storage和mnt三个文件夹</p>
<p>其中data及其子文件夹就是我们说的内部存储，storage、mnt即为外部存储</p>
<h3 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h3><p>内部存储不是内存,内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。当一个应用卸载之后，内部存储中的这些文件也被删除。对于内部存储空间，我们要尽量避免使用。Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getFilesDir()获取你app的内部存储空间，相当于你的应用在内部存储上的根目录（例：/data/user/0/package-name/files）。Context的对象还提供deleteFile(String name)、fileList()、getDir()等方法方便我们操作</span></span><br><span class="line">File file = <span class="keyword">new</span> File(getFilesDir(), filename);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream fos = openFileOutput(<span class="string">"hello"</span>, Context.MODE_PRIVATE);</span><br><span class="line">    fos.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">    fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileInputStream fis = openFileInput(<span class="string">"hello"</span>);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">    String line = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sb.append(line);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存文件"><a href="#缓存文件" class="headerlink" title="缓存文件"></a>缓存文件</h4><p>如果您想要缓存一些数据，而不是永久存储这些数据，应该使用 getCacheDir() 来打开一个 File，它表示您的应用应该将临时缓存文件保存到的内部目录。</p>
<p>当设备的内部存储空间不足时，Android 可能会删除这些缓存文件以回收空间。 但您不应该依赖系统来为您清理这些文件， 而应该始终自行维护缓存文件，使其占用的空间保持在合理的限制范围内（例如 1 MB）。 当用户卸载您的应用时，这些文件也会被移除。</p>
<h3 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h3><p>外部存储才是我们平时操作最多的，外部存储一般就是我们上面看到的storage文件夹，当然也有可能是mnt文件夹，这个不同厂家有可能不一样</p>
<p>一般来说，在storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，还有一类是私有目录，其中的公有目录有九大类，比如DCIM、DOWNLOAD等这种系统为我们创建的文件夹，私有目录就是android这个文件夹，这个文件夹打开之后里边有一个data文件夹，打开这个data文件夹，里边有许多包名组成的文件夹。无论私有目录还是公有目录，只要存储在外部存储，用户与其他应用都可访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 首先需要声明权限</span></span><br><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 检查介质是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState( ;</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公有文件"><a href="#公有文件" class="headerlink" title="公有文件"></a>公有文件</h4><p>为了方便用户访问与系统媒体扫描程序扫描，应将公有文件保存到共享的公共目录，在您的外部文件目录中包含名为 .nomedia 的空文件，这将阻止媒体扫描程序读取您的媒体文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DIRECTORY_DOCUMENTS在api19后加入</span></span><br><span class="line">File file = <span class="keyword">new</span> File(Environment.getExternalStoragePublicDirectory(</span><br><span class="line">        Environment.DIRECTORY_DOCUMENTS), <span class="string">"test.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">fos.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<h4 id="私有文件"><a href="#私有文件" class="headerlink" title="私有文件"></a>私有文件</h4><p>从 Android 4.4 开始读写私有文件不用声明权限,当用户卸载应用后，私有文件夹中的内容都将被删除，系统媒体扫描程序不会读取这些目录中的文件</p>
<blockquote>
<p>有时，已分配某个内部存储器分区用作外部存储的设备可能还提供了 SD 卡槽。在使用运行 Android 4.3 和更低版本的这类设备时，getExternalFilesDir() 方法将仅提供内部分区的访问权限，而您的应用无法读取或写入 SD 卡。不过，从 Android 4.4 开始，可通过调用 getExternalFilesDirs() 来同时访问两个位置，该方法将会返回包含各个位置条目的 File 数组。 数组中的第一个条目被视为外部主存储；除非该位置已满或不可用，否则应该使用该位置。 如果您希望在支持 Android 4.3 和更低版本的同时访问两个可能的位置，请使用支持库中的静态方法 ContextCompat.getExternalFilesDirs()。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取外部存储私有目录路径</span></span><br><span class="line">File file = <span class="keyword">new</span> File(getExternalFilesDir(<span class="keyword">null</span>), <span class="string">"test.txt"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用文件进行数据持久化的优缺点"><a href="#使用文件进行数据持久化的优缺点" class="headerlink" title="使用文件进行数据持久化的优缺点"></a>使用文件进行数据持久化的优缺点</h3><p>使用文件进行持久化可保存的数据量较大，可以保存多种类型的数据，其他应用也可进行访问，文件io会造成一定性能开销</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Android 提供了对 SQLite 数据库的完全支持。应用中的任何类（不包括应用外部的类）均可按名称访问您所创建的任何数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建SQLiteHelp子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextSQLiteOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME = <span class="string">"text_db"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_CREATE =</span><br><span class="line">            <span class="string">"CREATE TABLE "</span> + TABLE_NAME + <span class="string">" ("</span> +</span><br><span class="line">                    <span class="string">"id integer primary key autoincrement, "</span> +</span><br><span class="line">                    <span class="string">"name varchar(64));"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextSQLiteOpenHelper</span><span class="params">(Context context, String name,SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(TABLE_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">TextSQLiteOpenHelper helper = <span class="keyword">new</span> TextSQLiteOpenHelper(</span><br><span class="line">                <span class="keyword">this</span>, TextSQLiteOpenHelper.TABLE_NAME, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">SQLiteDatabase database = helper.getWritableDatabas();</span><br><span class="line">ContentValues contentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">contentValues.put(<span class="string">"id"</span>, <span class="number">1</span>);</span><br><span class="line">contentValues.put(<span class="string">"name"</span>, <span class="string">"hello"</span>);</span><br><span class="line">database.insert(TextSQLiteOpenHelper.TABLE_NAME,<span class="keyword">null</span>, contentValues);</span><br><span class="line">database.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"> TextSQLiteOpenHelper helper = <span class="keyword">new</span> TextSQLiteOpenHelper(</span><br><span class="line"><span class="keyword">this</span>, TextSQLiteOpenHelper.TABLE_NAME, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">SQLiteDatabase database = helper.getReadableDatabas();</span><br><span class="line">Cursor cursor = database.query(TextSQLiteOpenHelper.TABLE_NAME, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">cursor.moveToFirst();</span><br><span class="line">String name = cursor.getString(cursor.getColumnInde(<span class="string">"name"</span>));</span><br><span class="line">mDisplayTv.setText(name);</span><br><span class="line">cursor.close();</span><br><span class="line">database.close();</span><br></pre></td></tr></table></figure>

<h3 id="使用数据库进行持久化优缺点"><a href="#使用数据库进行持久化优缺点" class="headerlink" title="使用数据库进行持久化优缺点"></a>使用数据库进行持久化优缺点</h3><p>适合存储结构化数据，但是不适合存储大量数据，且数据库的存取属于本地io，如果查询的数据量较大则需要异步执行</p>
<h2 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h2><p>通过服务端提供的接口发送数据，将数据存储在服务器，这种方式与文件io类似，不过更加复杂，会受到网络状态与服务器状态影响，当手机使用移动数据流量上网的时候还必须限制大数据量的通信</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://developer.android.com/guide/topics/data/data-storage.html#pref" target="_blank" rel="noopener">数据存储</a></li>
<li><a href="http://blog.iderzheng.com/understand-sharedpreferences-in-android-api/" target="_blank" rel="noopener">了解Android API中的SharedPreferences</a></li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0923/1557.html" target="_blank" rel="noopener">android中的文件操作详解以及内部存储和外部存储</a></li>
<li><a href="http://blog.csdn.net/u012702547/article/details/50269639" target="_blank" rel="noopener">彻底理解android中的内部存储与外部存储</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android基础知识梳理</title>
    <url>/2020/04/19/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>以下内容均有参考Android官法开发文档</p>
<p>Activity生命周期参考<a href="https://www.cnblogs.com/lwbqqyumidi/p/3769113.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwbqqyumidi/p/3769113.html</a></p>
<p>Activity启动模式（lauchMode）参考<a href="https://blog.csdn.net/liuhe688/java/article/details/6754323" target="_blank" rel="noopener">https://blog.csdn.net/liuhe688/java/article/details/6754323</a></p>
<a id="more"></a>

<h2 id="Android组件生命周期"><a href="#Android组件生命周期" class="headerlink" title="Android组件生命周期"></a>Android组件生命周期</h2><h3 id="正确实施Activity生命周期方法"><a href="#正确实施Activity生命周期方法" class="headerlink" title="正确实施Activity生命周期方法"></a>正确实施Activity生命周期方法</h3><ul>
<li>如果用户在使用您的应用程序时接到电话或切换到另一个应用程序，则不会崩溃。</li>
<li>当用户不积极使用它时，不会消耗宝贵的系统资源。</li>
<li>如果用户离开您的应用程序并在以后返回它，则不会丢失用户的进度。</li>
<li>当屏幕在横向和纵向之间旋转时，不会崩溃或丢失用户的进度。</li>
</ul>
<h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><p>Activity是由Activity栈进管理，当来到一个新的Activity后，此Activity将被加入到Activity栈顶，之前的Activity位于此Activity底部。Acitivity一般意义上有四种状态：</p>
<p>1.当Activity位于栈顶时，此时正好处于屏幕最前方，此时处于<strong>运行状态</strong>；</p>
<p>2.当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕），此时处于<strong>暂停状态</strong>；</p>
<p>3.当Activity被其他Activity完全遮挡，此时此Activity对用户不可见，此时处于<strong>停止状态</strong>；</p>
<p>4.当Activity由于人为或系统原因（如低内存等）被销毁，此时处于<strong>销毁状态；</strong></p>
<p>在每个不同的状态阶段，Adnroid系统对Activity内相应的方法进行了回调。因此，我们在程序中写Activity时，一般都是继承Activity类并重写相应的回调方法。</p>
<p>Activity类中定义了7种回调方法，覆盖了活动生命周期的每一个环节：</p>
<ul>
<li><code>onCreate()</code>：完成活动的初始化操作，比如加载布局，绑定事件。</li>
<li><code>onStart()</code>：在活动由不可见变为可见的时候调用。</li>
<li><code>onResume()</code>：在活动准备好和用户进行交互时调用。该活动一定处于返回栈栈顶，且处于运行状态。</li>
<li><code>onPause()</code>：系统准备去启动或者恢复另一个活动的时候调用。该方法的执行速度一定要快，否则会影响到新的栈顶活动的使用。</li>
<li><code>onStop()</code>：在活动完全不可见时调用，与前者的区别时启动的新活动是一个对话框式的活动，那<code>onPause()</code>方法会得到执行，而该方法不会。</li>
<li><code>onDestory()</code>：在活动被销毁之前调用，之后活动变为销毁状态。</li>
<li><code>onRestart()</code>：由停止状态变为运行时状态之前调用，活动被重新启动。</li>
</ul>
<p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。</p>
<ul>
<li><strong>entire lifetime（完整生存期）</strong>：一个最简单的完整的按照如下顺序回调的Activity生命周期：<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code> -&gt; <code>onPause()</code> -&gt; <code>onStop()</code> -&gt; <code>onDestroy()</code>。<strong>活动在<code>onCreate()</code>和<code>onDestrory()</code>之间经历的就是完整生存期</strong></li>
<li><strong>visible lifetime（可见生存期）</strong>当执行<code>onStart()</code>回调方法时，Activity开始被用户所见（也就是说，<code>onCreate()</code>时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到<code>onStop()</code>之前，此阶段Activity都是被用户可见。<strong>活动在<code>onStart()</code>和<code>onStop</code>之间经历的就是可见生存期。活动对于用户总是可见的，即便有可能无法和用户进行交互。</strong></li>
<li><strong>foreground lifetime（前台生存期）</strong>当执行到<code>onResume()</code>回调方法时，Activity可以响应用户交互，一直到<code>onPause()</code>方法之前。<strong>活动在<code>onResume()</code>和<code>onPause()</code>之间经历的就是前台生存期。活动总是处于运行状态，此时活动可以和用户进行交互</strong></li>
</ul>
<p>在实际应用场景中，假设A Activity位于栈顶，此时用户操作，点击A中按钮来到B时，假设B全部遮挡住了A，从A Activity跳转到B Activity。</p>
<p>依次执行A:<code>onPause()</code> -&gt; B:<code>onCreate()</code> -&gt; B:<code>onStart()</code> -&gt; B:<code>onResume()</code> -&gt; A:<code>onStop()</code>。</p>
<p>此时如果点击Back键</p>
<p>将依次执行B:<code>onPause()</code> -&gt; A:<code>onRestart()</code> -&gt; A:<code>onStart()</code> -&gt; A:<code>onResume()</code> -&gt; B:<code>onStop()</code> -&gt; B:<code>onDestroy()</code>。</p>
<p>至此，Activity栈中只有A。</p>
<h3 id="Back键和Home键对Activity生命周期的影响实验"><a href="#Back键和Home键对Activity生命周期的影响实验" class="headerlink" title="Back键和Home键对Activity生命周期的影响实验"></a>Back键和Home键对Activity生命周期的影响实验</h3><p>实验结果：</p>
<p>Back键：系统返回到桌面，并依次执行A:<code>onPause()</code> -&gt; A:<code>onStop()</code> -&gt; A:<code>onDestroy()</code>。</p>
<p>Home键（非长按）：系统返回到桌面，并依次执行A:<code>onPause()</code> -&gt; A:<code>onStop()</code>。</p>
<p><strong>由此可见，Back键和Home键主要区别在于是否会执行onDestroy。</strong></p>
<p>长按Home键：不同手机可能弹出不同内容，Activity生命周期未发生变化（由小米2s实测）。</p>
<p>由于Android本身的特性，使得现在不少应用都没有直接退出应用程序的功能，按照一般的逻辑，当Activity栈中有且只有一个Activity时，当按下Back键此Activity会执行<code>onDestroy()</code>，那么下次点击此应用程图标将从重新启动，因此，当前不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？</p>
<p>通过重写按下Back键的回调函数，转成Home键的效果即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent home = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">    home.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    startActivity(home);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。</p>
<p>或者，为达到此类效果，Activity实际上提供了直接的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> activity.moveTaskToBack(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>moveTaskToBack()</strong>此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。</p>
<h3 id="Activity启动模式（lauchMode）"><a href="#Activity启动模式（lauchMode）" class="headerlink" title="Activity启动模式（lauchMode）"></a>Activity启动模式（lauchMode）</h3><p>launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。</p>
<p>Activity一共有以下四种launchMode：</p>
<p>1.standard</p>
<p>2.singleTop</p>
<p>3.singleTask</p>
<p>4.singleInstance</p>
<p>我们可以在AndroidManifest.xml配置<activity>的android:launchMode属性为以上四种之一即可。</p>
<p>下面我们结合实例一一介绍这四种lanchMode：</p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a><strong>standard</strong></h4><p>standard模式是默认的启动模式，不用为<activity>配置android:launchMode属性即可，当然也可以指定值为standard。</p>
<p>我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。</p>
<p>FirstActivity代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scott.launchmode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="keyword">this</span>.toString());</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, FirstActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。</p>
<p>然后我们连续点击几次按钮，将会出现下面的现象：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-standard%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。</p>
<p>standard模式的原理如下图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-standard%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a><strong>singleTop</strong></h4><p>我们在上面的基础上为<activity>指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。</p>
<p>singleTop模式的原理如下图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<p>正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。</p>
<p>我们再新建一个Activity命名为SecondActivity，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scott.launchmode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.second);</span><br><span class="line">		TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="keyword">this</span>.toString());</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent(SecondActivity.<span class="keyword">this</span>, FirstActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		    	startActivity(intent);				</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将之前的FirstActivity跳转代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。</p>
<p>演示结果如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C2.png" alt="success"></p>
<p>我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。</p>
<p>原理图如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTop%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%862.png" alt="success"></p>
<p>我们看到，当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。</p>
<p><strong>这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。</strong></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a><strong>singleTask</strong></h4><p>在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。</p>
<p>演示的结果如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTask%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。</p>
<p>singleTask模式的原理图如下图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleTask%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<p>在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统<strong>发现有存在的FirstActivity实例</strong>，于是<strong>不再生成新的实例</strong>，而是<strong>将FirstActivity之上的Activity实例统统出栈</strong>，将FirstActivity变为栈顶对象，显示到幕前。</p>
<p>也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。</p>
<p><strong>这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</strong></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a><strong>singleInstance</strong></h4><p>这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。</p>
<p>修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextView taskIdView = (TextView) findViewById(R.id.taskIdView);</span><br><span class="line">taskIdView.setText(<span class="string">"current task id: "</span> + <span class="keyword">this</span>.getTaskId());</span><br></pre></td></tr></table></figure>

<p>然后我们再演示一下这个流程：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%9E%E9%AA%8C.png" alt="success"></p>
<p>我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="success"></p>
<p>我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。</p>
<p>如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：</p>
<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%862.png" alt="success"></p>
<p>singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".ShareActivity"</span> android:launchMode=<span class="string">"singleInstance"</span>&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">              &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">              &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">          	&lt;action android:name=<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span> /&gt;</span><br><span class="line">              &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">      &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们在其他应用中这样启动该Activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Activity%E6%A0%87%E5%87%86%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-singleInstance%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%863.png" alt="success"></p>
<h2 id="Server组件"><a href="#Server组件" class="headerlink" title="Server组件"></a>Server组件</h2><p><code>Service</code>是一个应用程序组件，它能够在后台执行一些耗时较长的操作，并且不提供用户界面。</p>
<p>服务能被其它应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。</p>
<p>此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 服务可以处理：</p>
<ul>
<li><p>网络传输</p>
</li>
<li><p>音乐播放</p>
</li>
<li><p>执行文件I/O</p>
</li>
<li><p>与content provider进行交互</p>
<p>所有这些都是后台进行的。</p>
</li>
</ul>
<h4 id="服务有以下两种基本类型："><a href="#服务有以下两种基本类型：" class="headerlink" title="服务有以下两种基本类型："></a>服务有以下两种基本类型：</h4><ul>
<li><p>started </p>
<p>如果一个应用程序组件（比如一个activity）通过调用<code>startService()</code>来启动服务，则该服务就是被“started”了。一旦被启动，服务就能在后台一直运行下去，即使启动它的组件已经被销毁了。 通常，started的服务执行单一的操作并且不会向调用者返回结果。比如，它可以通过网络下载或上传文件。当操作完成后，服务应该自行终止。</p>
</li>
<li><p>bound </p>
<p>如果一个应用程序组件通过调用<code>bindService()</code>绑定到服务上，则该服务就是被“bound”了。bound服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至可以利用进程间通信（IPC）跨进程执行这些操作。绑定服务的生存期和被绑定的应用程序组件一致。 多个组件可以同时与一个服务绑定，不过所有的组件解除绑定后，服务也就会被销毁。</p>
</li>
</ul>
<p>虽然本文对这两种类型的服务是分别进行简要描述的，但是你的服务仍可以同时用两种方式工作——可以是started（一直运行下去），同时也能被绑定。 只会存在一点麻烦，是否两个回调方法都要实现：实现<code>onStartCommand()</code>以允许组件启动服务、实现<code>onBind()</code>以允许绑定。</p>
<p>无论你的应用程序是started、bound、还是两者都支持，任何应用程序组件都可以使用此服务（即使是从另一个独立的应用程序中）， 同样，任何组件都可以用这种方式使用一个activity——通过一个<code>Intent</code>启动。不过，也可以在manifest文件中把服务声明为私有private的，以便阻止其它应用程序的访问。 这将<a href="http://developer.android.com/guide/topics/fundamentals/services.html#Declaring" target="_blank" rel="noopener">在manifest中声明服务</a>文中详细论述。</p>
<p><strong>警告：</strong>如果不明确指明服务运行于新创建的进程/线程，服务将运行于宿主进程的主线程中。 这意味着，如果你的服务要执行一些很耗CPU的工作或者阻塞的操作（比如播放MP3或网络操作），你应该在服务中创建一个新的线程来执行这些工作。 利用单独的线程，将减少你的activity发生应用程序停止响应（ANR）错误的风险。</p>
<h3 id="Server概述"><a href="#Server概述" class="headerlink" title="Server概述"></a>Server概述</h3><hr>
<h4 id="使用服务还是使用线程？"><a href="#使用服务还是使用线程？" class="headerlink" title="使用服务还是使用线程？"></a>使用服务还是使用线程？</h4><p>服务仅仅是一个组件，即使用户不再与你的应用程序发生交互，它仍然能在后台运行。因此，应该只在需要时才创建一个服务。</p>
<p>如果你需要在主线程之外执行一些工作，但仅当用户与你的应用程序交互时才会用到，那你应该创建一个新的线程而不是创建服务。 比如，如果你需要播放一些音乐，但只是当你的activity在运行时才需要播放，你可以在<code>onCreate()</code>中创建一个线程，在<code>onStart()</code>中开始运行，然后在<code>onStop()</code>中终止运行。还可以考虑使用<code>AsyncTask</code>或<code>HandlerThread</code>来取代传统的<code>Thread</code>类。关于线程的详细信息，请参阅<a href="http://developer.android.com/guide/topics/fundamentals/processes-and-threads.html#Threads" target="_blank" rel="noopener">进程和线程</a>。</p>
<p>请记住，如果你使用了服务，它默认就运行于应用程序的主线程中。因此，如果服务执行密集计算或者阻塞操作，你仍然应该在服务中创建一个新的线程来完成。</p>
<p>为了创建一个服务，你必须新建一个<code>Service</code>的子类（或一个已有Service的子类）。在你的实现代码中，请按需重写一些回调方法，用于对服务生命周期中的关键节点进行处理，以及向组件提供绑定机制。 </p>
<h4 id="最重要的需要重写的回调方法："><a href="#最重要的需要重写的回调方法：" class="headerlink" title="最重要的需要重写的回调方法："></a>最重要的需要重写的回调方法：</h4><ul>
<li><p><code>onStartCommand()</code>当其它组件，比如一个activity，通过调用<code>startService()</code>请求started方式的服务时，系统将会调用本方法。 一旦本方法执行，服务就被启动，并在后台一直运行下去。 如果你的代码实现了本方法，你就有责任在完成工作后通过调用<code>stopSelf()</code>或<code>stopService()</code>终止服务。 （如果你只想提供bind方式，那就不需要实现本方法。）</p>
</li>
<li><p><code>onBind()</code></p>
</li>
</ul>
<p>当其它组件需要通过<code>bindService()</code>绑定服务时（比如执行RPC），系统会调用本方法。 在本方法的实现代码中，你必须返回IBinder来提供一个接口，客户端用它来和服务进行通信。 你必须确保实现本方法，不过假如你不需要提供绑定，那就返回null即可。</p>
<ul>
<li><code>onCreate()</code></li>
</ul>
<p>当服务第一次被创建时，系统会调用本方法，用于执行一次性的配置工作（之前已调用过<code>onStartCommand()</code>或<code>onBind()</code> 了。如果服务已经运行，则本方法就不会被调用。</p>
<ul>
<li><code>onDestroy()</code></li>
</ul>
<p>当服务用不上了并要被销毁时，系统会调用本方法。 你的服务应该实现本方法来进行资源的清理工作，诸如线程、已注册的侦听器listener和接收器receiver等等。 这将是服务收到的最后一个调用。</p>
<p>如果组件通过调用startService()<code>（这会导致</code>onStartCommand()<code>的调用）启动了服务，那么服务将一直保持运行，直至自行用</code>stopSelf()<code>终止或由其它组件调用stopService()</code>来终止它。</p>
<p>如果组件调用<code>bindService()</code>来创建服务（那<code>onStartCommand()</code>就不会被调用），则服务的生存期就与被绑定的组件一致。一旦所有客户端都对服务解除了绑定，系统就会销毁该服务。</p>
<p>仅当内存少得可怜、且必须覆盖拥有用户焦点的activity的系统资源时，Android系统才会强行终止一个服务。 如果服务被拥有用户焦点的activity绑定着，则它一般不会被杀死。 如果服务声明为<a href="https://www.android-doc.com/guide/components/services.html#.E5.9C.A8.E5.89.8D.E5.8F.B0.E8.BF.90.E8.A1.8C.E6.9C.8D.E5.8A.A1" target="_blank" rel="noopener">#在前台运行服务</a>（下文讨论），则它几乎永远不会被杀死。 否则，如果服务已被启动并且已运行了很长时间，那么系统将会随时间推移而降低它在后台任务列表中的级别， 此类服务将很有可能会被杀死——如果服务已经启动，那你必须好好设计代码，使其能完美地应付被系统重启的情况。 如果系统杀死了你的服务，只要资源再度够用，系统就会再次启动服务（当然这还取决于<code>onStartCommand()</code>的返回值，下文将会述及）。关于系统可能会在何时销毁服务的详细信息，请参阅<a href="http://developer.android.com/guide/topics/fundamentals/processes-and-threads.html" target="_blank" rel="noopener">进程和线程</a>。</p>
<p>在下节中，你将看到如何创建每种类型的服务，以及如何在应用程序组件中使用它们。</p>
<h3 id="在manifest中声明服务"><a href="#在manifest中声明服务" class="headerlink" title="在manifest中声明服务"></a>在manifest中声明服务</h3><p>与activity（及其它组件）类似，你必须在应用程序的manifest文件中对所有的服务进行声明。</p>
<p>要声明你的服务，把<service>元素作为子元素加入到<application>元素中去即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;application ... &gt;</span><br><span class="line">      &lt;service android:name&#x3D;&quot;.ExampleService&quot; &#x2F;&gt;</span><br><span class="line">      ...</span><br><span class="line">  &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>

<p>在<service>元素中可以包含很多其它属性，比如定义启动服务所需权限、服务运行的进程之类的属性。android:name是唯一必需的属性——它定义了服务的类名。应用程序一经发布，就不得再修改这个类名。因为这么做可能会破坏某些显式引用该服务的intent功能（参阅博客文章<a href="http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html" target="_blank" rel="noopener">Things That Cannot Change</a>）。</p>
<p>关于在manifest中声明服务的详情，请参阅<service>元素参考文档。</p>
<p>与activity一样，服务可以定义intent过滤器，使得其它组件能用隐式intent来调用服务。 通过声明intent过滤器，任何安装在用户设备上的应用程序组件都有能力来启动你的服务，只要你的服务所声明的intent过滤器与其它应用程序传递给<code>startService()</code>的intent相匹配即可。</p>
<p>如果你想让服务只能内部使用（其它应用程序无法调用），那么就不必（也不应该）提供任何intent过滤器。 如果不存在任何intent过滤器，那你就必须用精确指定服务类名的intent来启动服务。 关于<a href="https://www.android-doc.com/guide/components/services.html#.E5.90.AF.E5.8A.A8.E4.B8.80.E4.B8.AA.E6.9C.8D.E5.8A.A1" target="_blank" rel="noopener">#启动一个服务</a>的详细内容，将在下文讨论。</p>
<p>此外，如果包含了android:exported属性并且设置为”false”， 就可以确保该服务是你应用程序的私有服务。即使服务提供了intent过滤器，本属性依然生效。</p>
<p>关于为服务创建intent过滤器的详细信息，请参阅<a href="http://developer.android.com/guide/topics/intents/intents-filters.html" target="_blank" rel="noopener">Intent和Intent过滤器</a>文档。</p>
<h4 id="创建一个started服务"><a href="#创建一个started服务" class="headerlink" title="创建一个started服务"></a>创建一个started服务</h4><p>started服务是指其它组件通过调用<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>来启动的服务，这会引发对该服务[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))方法的调用。</p>
<p>一旦服务被启动started，它就拥有了自己的生命周期，这是独立于启动它的组件的。并且它能够在后台一直运行下去，即使启动它的组件已被销毁 也是如此。 因此，服务应该能够在完成工作后自行终止，通过调用<a href="http://developer.android.com/reference/android/app/Service.html#stopSelf()" target="_blank" rel="noopener">stopSelf()</a>即可，或者由其它组件通过调用<a href="http://developer.android.com/reference/android/content/Context.html#stopService(android.content.Intent)" target="_blank" rel="noopener">stopService()</a>也可以。</p>
<p>诸如activity之类的应用程序组件，可以通过调用<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>启动服务,并传入一个给出了服务和服务所需数据的<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>对象。服务将在[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))方法中接收到该<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>对象。</p>
<p>举个例子，假定某activity需要把一些数据保存到在线数据库中。此activity可以启动一个守护服务并通过传入<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>一个intent把需要保存的数据发送给该服务。该服务在[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))内接收intent，连接Internet，再进行数据库事务处理。当事务完成后，服务自行终止，并被系统销毁。</p>
<p><strong>警告：</strong>默认情况下，运行服务的进程与应用程序的相同，并且运行在应用程序的主线程中。 因此，如果你的服务要执行计算密集或阻塞的操作，而同时用户又需要与同一个应用程序中的activity进行交互，那么服务将会降低activity的性能。 为了避免对应用程序性能的影响，你应该在服务中启动一个新的线程。</p>
<p>传统做法，你可以扩展两个类来创建started服务：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="noopener">Service</a></li>
</ul>
<p>这是所有服务的基类。如果你要扩展该类，则很重要的一点是：请在其中创建一个新的线程来完成所有的服务工作。 因为服务默认是使用应用程序的主线程的，这会降低应用程序中activity的运行性能。</p>
<ul>
<li><a href="http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService</a></li>
</ul>
<p>这是<a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="noopener">Service</a>类的子类，它使用了工作（worker）线程来处理所有的启动请求，每次请求都会启动一个线程。 如果服务不需要同时处理多个请求的话，这是最佳的选择。 所有你要做的工作就是实现<a href="http://developer.android.com/reference/android/app/IntentService.html#onHandleIntent(android.content.Intent)" target="_blank" rel="noopener">onHandleIntent()</a>即可，它会接收每个启动请求的intent，然后就可在后台完成工作。</p>
<p>下一节描述了如何用这两个类来实现服务。</p>
<h4 id="扩展IntentService类"><a href="#扩展IntentService类" class="headerlink" title="扩展IntentService类"></a>扩展IntentService类</h4><p>因为<strong>大多数started服务都不需要同时处理多个请求</strong>（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。</p>
<p>IntentService将执行以下步骤：</p>
<p>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到<code>onStartCommand()</code>的intent。</p>
<p>创建一个工作队列，每次向你的<code>onHandleIntent()</code>传入一个intent，这样你就永远不必担心多线程问题了。</p>
<p>在处理完所有的启动请求后，终止服务，因此你就永远不需调用<code>stopSelf()</code>了。</p>
<p>提供缺省的<code>onBind()</code>实现代码，它返回null。</p>
<p>提供缺省的<code>onStartCommand()</code>实现代码，它把intent送入工作队列，稍后会再传给你的<code>onHandleIntent()</code>实现代码。</p>
<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现<code>onHandleIntent()</code>的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）</p>
<p>以下是个IntentService的实现例程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 构造方法是必需的，必须用工作线程名称作为参数</span></span><br><span class="line"><span class="comment">   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 </span></span><br><span class="line"><span class="comment">   * 本方法返回后，IntentService将适时终止这个服务。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 通常我们会在这里执行一些工作，比如下载文件。</span></span><br><span class="line">      <span class="comment">// 作为例子，我们只是睡5秒钟。</span></span><br><span class="line">      <span class="keyword">long</span> endTime = System.currentTimeMillis() + <span class="number">5</span>*<span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  wait(endTime - System.currentTimeMillis());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有你需要做的就是：一个构造方法和一个<code>onHandleIntent()</code>方法的实现。</p>
<p>如果你还决定重写其它的回调方法，比如<code>onCreate()</code>、<code>onStartCommand()</code>、<code>onDestroy()</code>， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>
<p>比如说，<code>onStartCommand()</code>必须返回缺省实现代码的结果（缺省代码实现了如何获取传给<code>onHandleIntent()</code>的intent）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">"service starting"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>onHandleIntent()</code>以外，唯一不需要调用父类实现代码的方法是<code>onBind()</code>（不过如果你的服务允许绑定，你还是需要实现它）。</p>
<p>在下一节中，你将看到如何扩展Service基类来实现同一服务，代码量会多一些，但可能适合处理多个同时发起的请求。</p>
<h4 id="扩展Service类"><a href="#扩展Service类" class="headerlink" title="扩展Service类"></a>扩展Service类</h4><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>
<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloService extends Service &#123;</span><br><span class="line">  private Looper mServiceLooper;</span><br><span class="line">  private ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 处理从线程接收的消息</span><br><span class="line">  private final class ServiceHandler extends Handler &#123;</span><br><span class="line">      public ServiceHandler(Looper looper) &#123;</span><br><span class="line">          super(looper);</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void handleMessage(Message msg) &#123;</span><br><span class="line">          &#x2F;&#x2F; 通常我们在这里执行一些工作，比如下载文件。</span><br><span class="line">          &#x2F;&#x2F; 作为例子，我们只是睡个5秒钟。</span><br><span class="line">          long endTime &#x3D; System.currentTimeMillis() + 5*1000;</span><br><span class="line">          while (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">              synchronized (this) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      wait(endTime - System.currentTimeMillis());</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动运行服务的线程。</span><br><span class="line">    &#x2F;&#x2F; 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span><br><span class="line">    &#x2F;&#x2F; 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span><br><span class="line">    HandlerThread thread &#x3D; new HandlerThread(&quot;ServiceStartArguments&quot;,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    thread.start();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获得HandlerThread的Looper队列并用于Handler</span><br><span class="line">    mServiceLooper &#x3D; thread.getLooper();</span><br><span class="line">    mServiceHandler &#x3D; new ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 对于每一个启动请求，都发送一个消息来启动一个处理</span><br><span class="line">      &#x2F;&#x2F; 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span><br><span class="line">      Message msg &#x3D; mServiceHandler.obtainMessage();</span><br><span class="line">      msg.arg1 &#x3D; startId;</span><br><span class="line">      mServiceHandler.sendMessage(msg);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果我们被杀死了，那从这里返回之后被重启</span><br><span class="line">      return START_STICKY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">      &#x2F;&#x2F; 我们不支持绑定，所以返回null</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，它要干的事情比用IntentService时多了很多。</p>
<p>不过，因为是自行处理每个<code>onStartCommand()</code>调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>
<p>请注意<code>onStartCommand()</code>方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。<code>onStartCommand()</code>的返回值必须是以下常量之一：</p>
<h5 id="onStartCommand-返回值"><a href="#onStartCommand-返回值" class="headerlink" title="onStartCommand()返回值"></a>onStartCommand()返回值</h5><ul>
<li><p>START_NOT_STICKY </p>
<p>如果系统在<code>onStartCommand()</code>返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。</p>
</li>
<li><p>START_STICKY </p>
<p>如果系统在<code>onStartCommand()</code>返回后杀死了服务，则将重建服务并调用<code>onStartCommand()</code>，但不会再次送入上一个intent， 而是用null intent来调用<code>onStartCommand()</code>。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。</p>
</li>
<li><p>START_REDELIVER_INTENT </p>
<p>如果系统在<code>onStartCommand()</code>返回后杀死了服务，则将重建服务并用上一个已送过的intent调用    <code>onStartCommand()</code>。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。</p>
</li>
</ul>
<p>关于这些返回值的详情，请参阅每个常量的参考文档链接。</p>
<h4 id="启动一个服务"><a href="#启动一个服务" class="headerlink" title="启动一个服务"></a>启动一个服务</h4><p>从activity或其它应用程序组件中可以启动一个服务，调用<code>startService()</code>并传入一个<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>（指定所需启动的服务）即可。Android系统将调用服务的<code>onStartCommand()</code>方法，并传入该<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>（你永远都不应该直接去调用<code>onStartCommand()</code>。）</p>
<p>例如，一个activity可以用一个显式的intent通过<code>startService()</code>启动上一节的示例服务（HelloSevice）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(this, HelloService.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>

<p><a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>方法会立即返回，Android系统会去调用服务的[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int)) 方法。如果服务还未运行，系统会首先调用<a href="http://developer.android.com/reference/android/app/Service.html#onCreate()" target="_blank" rel="noopener">onCreate()</a>，然后再去调用[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int)) 。</p>
<p>如果服务不同时支持绑定，那么通过<a href="http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">startService()</a>传入的intent将是应用程序组件与服务进行交互的唯一途径。 当然，如果你期望服务能返回结果，那启动服务的客户端可以创建一个<a href="http://developer.android.com/reference/android/app/PendingIntent.html" target="_blank" rel="noopener">PendingIntent</a>来获得一个广播broadcast（利用[getBroadcast()](<a href="http://developer.android.com/reference/android/app/PendingIntent.html#getBroadcast" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/PendingIntent.html#getBroadcast</a>(android.content.Context, int, android.content.Intent, int))），并把它放入启动服务的<a href="http://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a>并传到服务中去。然后服务就会用这个broadcast来传递结果。</p>
<p>多个启动服务的请求将会引发服务[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))方法的多次调用。不过，只有一个终止服务的请求（用<a href="http://developer.android.com/reference/android/app/Service.html#stopSelf()" target="_blank" rel="noopener">stopSelf()</a>或<a href="http://developer.android.com/reference/android/content/Context.html#stopService(android.content.Intent)" target="_blank" rel="noopener">stopService()</a>）会被接受并执行。</p>
<h4 id="终止一个服务"><a href="#终止一个服务" class="headerlink" title="终止一个服务"></a>终止一个服务</h4><p><strong>一个started服务必须自行管理生命周期</strong>。也就是说，<strong>系统不会终止或销毁这类服务，除非必须恢复系统内存并且服务返回后一直维持运行</strong>。 因此，服务必须通过<strong>调用</strong><code>stopSelf()</code><strong>自行终止</strong>，或者<strong>其它组件可通过**</strong>调用<code>stopService()</code>来终止它。</p>
<p>用<code>stopSelf()</code>或<code>stopService()</code>的<strong>终止请求一旦发出，系统就会尽快销毁服务</strong>。</p>
<p>不过，<strong>如果你的服务要同时处理多个</strong><code>onStartCommand()</code><strong>请求</strong>，<strong>那在处理启动请求的过程中，你就不应该去终止服务</strong>，因为你可能接收到了一个新的启动请求（在第一个请求处理完毕后终止服务将停止第二个请求的处理。 为了避免这个问题，你可以用<code>stopSelf(int)</code>来确保终止服务的请求总是根据最近一次的启动请求来完成。 也就是说，当你调用<code>stopSelf(int)</code>时，你把启动请求ID（发送给<code>onStartCommand()</code>, int, int))的startId）传给了对应的终止请求。这样，如果服务在你可以调用<code>stopSelf(int)</code>时接收到了新的启动请求，则ID将会不一样，服务将不会被终止。</p>
<p><strong>警告：</strong>当服务完成工作后，你的应用程序应该及时终止它，这点非常重要。这样可以<strong>避免系统资源的浪费，并能节省电池的电力</strong>。 必要时，其它组件可以通过调用<code>stopService()</code>来终止服务。即使你的服务允许绑定，你也必须保证它在收到对<code>onStartCommand()</code>的调用时能够自行终止。</p>
<p>关于服务生命周期的详细信息，请参阅下文的<a href="https://www.android-doc.com/guide/components/services.html#.E5.AF.B9.E6.9C.8D.E5.8A.A1.E7.9A.84.E7.94.9F.E5.91.BD.E5.91.A8.E6.9C.9F.E8.BF.9B.E8.A1.8C.E7.AE.A1.E7.90.86" target="_blank" rel="noopener">#对服务的生命周期进行管理</a>章节。</p>
<h3 id="创建一个bound服务"><a href="#创建一个bound服务" class="headerlink" title="创建一个bound服务"></a>创建一个bound服务</h3><hr>
<p>bound服务是指允许被应用程序组件绑定的服务，通过调用<code>bindService()</code>, android.content.ServiceConnection, int))可以完成绑定，用于创建一个长期存在的连接（并且一般不再允许组件通过调用<code>startService()</code>来start服务。</p>
<p>当应用程序中的activity或其它组件需要与服务进行交互，或者应用程序的某些功能需要暴露给其它应用程序时，你应该创建一个bound服务，并通过进程间通信（IPC）来完成。</p>
<p>要创建一个bound服务，你必须实现<a href="http://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent)" target="_blank" rel="noopener">onBind()</a>回调方法，并返回一个<a href="http://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a>对象，此对象定义了与服务进行通信的接口。 然后，其它应用程序组件可以调用[bindService()](<a href="http://developer.android.com/reference/android/content/Context.html#bindService" target="_blank" rel="noopener">http://developer.android.com/reference/android/content/Context.html#bindService</a>(android.content.Intent, android.content.ServiceConnection, int))来获得接口并调用服务中的方法。 服务只在为绑定的应用程序组件工作时才会存活，因此，只要没有组件绑定到服务，系统就会自动销毁服务（你不需要像started服务中那样通过[onStartCommand()](<a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#onStartCommand</a>(android.content.Intent, int, int))来终止一个bound服务）。</p>
<p>要创建一个bound服务，首先必须定义好接口，用于指明客户端如何与服务进行通信。 这个客户端与服务之间的接口必须是一个<a href="http://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a>对象的实现，并且你的服务必须在<a href="http://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent)" target="_blank" rel="noopener">onBind()</a>回调方法中返回这个对象。一旦客户端接收到这个<a href="http://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a>，它就可以通过这个接口来与服务进行交互。</p>
<p>同一个服务可以被多个客户端绑定。当客户端完成交互时，会调用<a href="http://developer.android.com/reference/android/content/Context.html#unbindService(android.content.ServiceConnection)" target="_blank" rel="noopener">unbindService()</a>来解除绑定。一旦不存在客户端与服务绑定时，系统就会销毁该服务。</p>
<p>实现bound服务的方式可以有很多种，实现的过程也比started类型的服务更为复杂，因此bound服务将在单独的<a href="https://www.android-doc.com/Bound服务" target="_blank" rel="noopener">bound服务</a>文档中讨论。</p>
<h3 id="向用户发送通知"><a href="#向用户发送通知" class="headerlink" title="向用户发送通知"></a>向用户发送通知</h3><hr>
<p>一旦开始运行，服务就能够利用<a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html" target="_blank" rel="noopener">toast通知</a>或<a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">状态栏通知</a>把事件通知给用户。</p>
<p>toast通知是一个显示在当前窗口之上的消息框，显示一会儿之后它会自行消失。 而状态栏通知则是在状态栏上显示一个附带消息的图标，用户可以选中它来执行一个action（比如启动一个activity）。</p>
<p>通常，当某些后台工作已经完成时（比如文件下载完毕），状态栏通知是最好的通知手段，用户这时可以在其上执行一些操作。</p>
<p>详情请参阅<a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html" target="_blank" rel="noopener">toast通知</a>或<a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">状态栏通知</a>开发指南。</p>
<h3 id="在前台运行服务"><a href="#在前台运行服务" class="headerlink" title="在前台运行服务"></a>在前台运行服务</h3><hr>
<p>前台服务是指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，并会置于“正在进行的”（“Ongoing”）组之下。这意味着只有在服务被终止或从前台移除之后，此通知才能被解除。</p>
<p>例如，用服务来播放音乐的播放器就应该运行在前台，因为用户会清楚地知晓它的运行情况。 状态栏通知可能会标明当前播放的歌曲，并允许用户启动一个activity来与播放器进行交互。</p>
<p>要把你的服务请求为前台运行，可以调用[startForeground()](<a href="http://developer.android.com/reference/android/app/Service.html#startForeground" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#startForeground</a>(int, android.app.Notification))方法。此方法有两个参数：唯一标识通知的整数值、状态栏通知<a href="http://developer.android.com/reference/android/app/Notification.html" target="_blank" rel="noopener">Notification</a>对象。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Notification notification &#x3D; new Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent &#x3D; new Intent(this, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent &#x3D; PendingIntent.getActivity(this, 0, notificationIntent, 0);</span><br><span class="line">notification.setLatestEventInfo(this, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line">startForeground(ONGOING_NOTIFICATION, notification);</span><br></pre></td></tr></table></figure>

<p>要从前台移除服务，请调用<a href="http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean)" target="_blank" rel="noopener">stopForeground()</a>方法，这个方法接受个布尔参数，表示是否同时移除状态栏通知。此方法不会终止服务。不过，如果服务在前台运行时被你终止了，那么通知也会同时被移除。</p>
<p><strong>注意：</strong>[startForeground()](<a href="http://developer.android.com/reference/android/app/Service.html#startForeground" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#startForeground</a>(int, android.app.Notification))和<a href="http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean)" target="_blank" rel="noopener">stopForeground()</a>方法是自Android 2.0 (API Level 5)开始引入的。 为了让服务能在更早版本的平台上实现前台运行，你必须使用以前的setForeground()方法——关于如何提供向后兼容性的详情，请参阅[startForeground()](<a href="http://developer.android.com/reference/android/app/Service.html#startForeground" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/Service.html#startForeground</a>(int, android.app.Notification))。</p>
<p>有关通知的详细信息，请参阅<a href="https://www.android-doc.com/index.php?title=创建状态栏通知&action=edit&redlink=1" target="_blank" rel="noopener">创建状态栏通知</a>。</p>
<h3 id="对服务的生命周期进行管理"><a href="#对服务的生命周期进行管理" class="headerlink" title="对服务的生命周期进行管理"></a>对服务的生命周期进行管理</h3><hr>
<p>服务的生命周期与activity的非常类似。不过，更重要的是你需密切关注服务的创建和销毁环节，因为后台运行的服务是不会引起用户注意的。</p>
<h4 id="服务的生命周期从创建到销毁的两种路径："><a href="#服务的生命周期从创建到销毁的两种路径：" class="headerlink" title="服务的生命周期从创建到销毁的两种路径："></a>服务的生命周期从创建到销毁的两种路径：</h4><ul>
<li><p>一个started服务</p>
</li>
<li><p>一个bound服务</p>
</li>
</ul>
<p>这两条路径并不是完全隔离的。也就是说，你可以绑定到一个已经用<code>startService()</code>启动的服务上。例如，一个后台音乐服务可以通过调用<code>startService()</code>来启动，传入一个指明所需播放音乐的 Intent。 之后，用户也许需要用播放器进行一些控制，或者需要查看当前歌曲的信息，这时一个activity可以通过调用<code>bindService()</code>与此服务绑定。在类似这种情况下，<code>stopService()</code>或<code>stopSelf()</code>不会真的终止服务，除非所有的客户端都解除了绑定。</p>
<h4 id="实现生命周期回调方法"><a href="#实现生命周期回调方法" class="headerlink" title="实现生命周期回调方法"></a>实现生命周期回调方法</h4><p><img src="/images/pictures/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/Server%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="Server生命周期"></p>
<p>图 2.服务的生命周期。 左边的图展示了用<code>startService()</code>创建的服务的生命周期，右边的图展示了用<code>bindService()</code>创建的服务的生命周期。</p>
<p>与activity类似，服务也存在生命周期回调方法，你可以实现这些方法来监控服务的状态变化，并在适当的时机执行一些操作。 以下代码提纲展示了服务的每个生命周期回调方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExampleService extends Service &#123;</span><br><span class="line">    int mStartMode;       &#x2F;&#x2F; 标识服务被杀死后的处理方式</span><br><span class="line">    IBinder mBinder;      &#x2F;&#x2F; 用于客户端绑定的接口</span><br><span class="line">    boolean mAllowRebind; &#x2F;&#x2F; 标识是否使用onRebind</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务正被创建</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务正在启动，由startService()调用引发</span><br><span class="line">        return mStartMode;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 客户端用bindService()绑定服务</span><br><span class="line">        return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onUnbind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 所有的客户端都用unbindService()解除了绑定</span><br><span class="line">        return mAllowRebind;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onRebind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 某客户端正用bindService()绑定到服务,</span><br><span class="line">        &#x2F;&#x2F; 而onUnbind()已经被调用过了</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务用不上了，将被销毁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>与activity的生命周期回调方法不同，你不是一定要调用父类的回调方法。</p>
<p>通过实现这些方法，你能够监控服务中两个嵌套的生命周期循环</p>
<h5 id="服务的完整与活跃生命周期"><a href="#服务的完整与活跃生命周期" class="headerlink" title="服务的完整与活跃生命周期"></a>服务的完整与活跃生命周期</h5><ul>
<li><p>服务的<strong>完整生存期</strong>开始于<code>onCreate()</code>调用时，结束于<code>onDestroy()</code>返回时。与activity类似，服务在<code>onCreate()</code>中完成初始设置工作，并在<code>onDestroy()</code>中释放所有未释放的资源。例如，一个音乐播放服务可以在<code>onCreate()</code>中创建音乐播放线程，而在<code>onDestroy()</code>中终止该线程。 不管是用<code>startService()</code>创建的，还是用<code>bindService()</code>创建的，所有的服务都会调用<code>onCreate()</code>和<code>onDestroy()</code>方法。</p>
</li>
<li><p>服务的<strong>活跃生存期</strong>开始于<code>onStartCommand()</code>或<code>onBind()</code>的调用。这两个方法分别会传入传给<code>startService()</code>或<code>bindService()</code>的 Intent。 如果服务是started的，则活跃生存期与完整生存期同时结束（即使<code>onStartCommand()</code>返回后，服务仍然处于活跃期。）如果服务是bound的，则活跃生存期在 onUnbind() 返回后结束。</p>
</li>
</ul>
<p><strong>注意：</strong>虽然started的服务是用<code>stopSelf()</code>或<code>stopService()</code>调用来终止的，但是服务却没有相应的回调方法（不存在onStop()回调方法）。因此，除非服务与客户端绑定了，不然系统就会在服务终止时销毁它——<code>onDestroy()</code>是唯一会收到的回调方法。</p>
<p>图 2 标明了服务中典型的回调方法。尽管此图把<code>startService()</code>创建的服务和<code>bindService()</code>创建的分开描述了，但请记住，无论启动的方式如何，所有的服务实际上都允许被绑定。 因此，用<code>onStartCommand()</code>启动的服务（客户端调用<code>startService()</code>仍然可以接收<code>onBind()</code>调用（当客户端调用了<code>bindService()</code>时）。</p>
<p>有关创建支持绑定的服务，详情请参阅<a href="https://www.android-doc.com/Bound服务" target="_blank" rel="noopener">bound服务</a>文档，在其中的<a href="https://www.android-doc.com/Bound服务#.E7.AE.A1.E7.90.86bound.E6.9C.8D.E5.8A.A1.E7.9A.84.E7.94.9F.E5.91.BD.E5.91.A8.E6.9C.9F" target="_blank" rel="noopener">bound服务#管理bound服务的生命周期</a>章节中包含了有关<code>onRebind()</code>回调方法的详细信息。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>三色旗算法</title>
    <url>/2020/04/15/%E4%B8%89%E8%89%B2%E6%97%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>三色旗算法</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package a;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Main&#123;     </span><br><span class="line">    public static  void main(String[] args)  &#123;  </span><br><span class="line">        System.out.println(&quot;请输入旗子的颜色字符串&quot;);</span><br><span class="line">        Scanner cin &#x3D; new Scanner(System.in);       </span><br><span class="line">        while(cin.hasNext())&#123;</span><br><span class="line">          String n&#x3D;cin.next();</span><br><span class="line">            char[] a&#x3D;n.toCharArray();</span><br><span class="line">          int b&#x3D;0,w&#x3D;0,r&#x3D;a.length-1;</span><br><span class="line">          int count&#x3D;0;</span><br><span class="line">          while(w&lt;&#x3D;r) &#123;</span><br><span class="line">              if(a[w]&#x3D;&#x3D;&#39;白&#39;)</span><br><span class="line">              &#123;</span><br><span class="line">                  w++;</span><br><span class="line">              &#125;else if(a[w]&#x3D;&#x3D;&#39;篮&#39;)&#123;</span><br><span class="line">                  char m&#x3D;a[w];</span><br><span class="line">                  a[w]&#x3D;a[b];</span><br><span class="line">                  a[b]&#x3D;m;</span><br><span class="line">                  w++;</span><br><span class="line">                  b++;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;else if(a[w]&#x3D;&#x3D;&#39;红&#39;)&#123;</span><br><span class="line">                  char m&#x3D;a[w];</span><br><span class="line">                  a[w]&#x3D;a[r];</span><br><span class="line">                  a[r]&#x3D;m;</span><br><span class="line">                  r--;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          for(int i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">              System.out.print(a[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.print(&quot;共交换了&quot;+count+&quot;次&quot;);                 </span><br><span class="line"> &#125;</span><br><span class="line">        cin.close();      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>TCP和UDP详解</title>
    <url>/2020/04/08/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>从计算机网络体系结构角度解析TCP和UDP</p>
<a id="more"></a>

<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="success"></p>
<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="success"></p>
<h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层为运行在不同主机上的<strong>进程</strong>之间提供逻辑通信（网络层提供了主机之间的通信，即使网络层之间的通信时不可靠的，（分组丢失、混乱、重复），传输层同样也能为应用程序提供可靠的服务）。</p>
<p>传输层与应用层存在于主机的协议栈中，而不是路由器的通信子网中。（其实只要理解了传输层在是不同主机上的进程之间进行通信，就都好理解了。）</p>
<h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><ol>
<li><p>传输层提供应用<strong>进程</strong>之间的逻辑通信（即端到端的通信）。（逻辑通信：传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间没有一条水平方向的物理连接）。</p>
</li>
<li><p>传输层的复用和分用。</p>
<p>复用：发送方不同的应用进程都可以使用同一个传输层协议传送数据。</p>
<p>分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</p>
</li>
<li><p>传输层对收到的报文进行差错检测（首部和数据部分）。（网络层只检查IP数据报的部分）。</p>
</li>
<li><p>提供两种不同的传输协议。网络层无法同时存在这两种形式（要么提供无连接服务，要么提供面向连接的服务）。</p>
</li>
</ol>
<h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3><p>​        端口的作用：让应用层的各种应用进程将其数据通过端口号向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><ol>
<li>服务端使用的端口号<ul>
<li>熟知端口号0～1023</li>
<li>登记端口号1024～49151</li>
</ul>
</li>
<li>客户端使用的端口号49152～65535</li>
</ol>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>​        套接字=（主机IP地址，端口号）</p>
<p>​        唯一的标识了网络中的一个主机和其上的一个应用（进程）。</p>
<h3 id="无连接服务与面向连接的服务"><a href="#无连接服务与面向连接的服务" class="headerlink" title="无连接服务与面向连接的服务"></a>无连接服务与面向连接的服务</h3><p>​        面向连接的服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和监管。当通信结束，则应该释放这个连接。</p>
<p>​        无连接服务，两个实体之间的通信不需要先建立好连接，需要通信的时候，直接将信息发送到网络中，让该信息的传递早在网上尽力而为地往目的地传送。</p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3><h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><p>​        UDP只在IP的数据报服务之上增加了两个最基本的服务：复用和差错检查。常用于一次性传输比较少量数据的网络应用，如DNS、SNMP等。</p>
<p>​        UDP提供尽最大努力的交付，既不保证可靠交付，维护传输数据可靠性的工作需要用户在应用层完成。</p>
<p>​        UDP是面向报文的，直接将应用层交下来的报文交付给IP层。</p>
<ol>
<li>UDP无需建立连接（不会引入建立连接的时延）.</li>
<li>无连接状态(不维护连接状态)。</li>
<li>分组首部开销小（TCP20字节首部开销，UDP8字节）。</li>
<li>应用层能更好的控制要发送的数据和发送时间（没有拥塞控制）。</li>
</ol>
<p>UDP首部格式</p>
<p>​        8个字节，4个字段，每个字段2个字节</p>
<ul>
<li>源端口</li>
<li>目的端口</li>
<li>长度</li>
<li>校验和</li>
</ul>
<h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><p>​        计算校验和时，要在UDP数据之前增加12个字节的伪首部。既检查UDP数据报，又检查IP数据报的源IP地址和目的IP地址进行了校验。</p>
<p>校验方法：二进制反码运算求和再取反。</p>
<ol>
<li>校验时，若UDP数据报部分的长度不是偶数个数字，则需要填入一个全0字节。和所有伪首部一样，均不发送。</li>
<li>如果UDP校验和校验出的UDP数据报是错误的，可以丢弃，也可以交付给上层，但是需要附上错误报告。</li>
<li>通过伪首部，不仅可以检查端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。</li>
</ol>
<p>UDP检错能力不强，但处理速度快。</p>
<h2 id="TCP协议原理"><a href="#TCP协议原理" class="headerlink" title="TCP协议原理"></a>TCP协议原理</h2><p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/1.png" alt="success"></p>
<ul>
<li>TCP是一种精致的，可靠的字节流协议。</li>
<li>在TCP编程中，三路握手一般由客户端（Client）调用Connent函数发起。</li>
<li>TCP三次握手后数据收发通道即打开（即建立了连接）。</li>
</ul>
<h3 id="ack机制"><a href="#ack机制" class="headerlink" title="ack机制"></a>ack机制</h3><p>​        由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。<br>​        这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ack（回执）。如果发送方没接收到正确的ack，就会重新发送数据直到接收到ack为止。<br> 比如：发送方发送的数据序号是seq，那么接收方会发送ack=seq + 1，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。</p>
<h3 id="Tcp三次握手"><a href="#Tcp三次握手" class="headerlink" title="Tcp三次握手"></a>Tcp三次握手</h3><ul>
<li>SYN = 1，同步序列编号（即握手信号），SYN占用一个码位字段。</li>
<li>ACK = 1，确认字符，ACK占用一个码位字段。</li>
<li>seq:起始序号，即报文段首字节序号，给报文段首字节序号设置一个逻辑地址。</li>
<li>ack确认字段，值为下一次发送的报文段首字节序号，TCP将从ack数值指向的字节的逻辑位置开始传输。</li>
</ul>
<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/Tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="success"></p>
<ol>
<li><p>第一次握手</p>
<p>​        Client端的TCP向Server端的TCP发送一个连接请求报文段（不含应用层数据），将首部中的SYN标志位置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手</p>
<p>​        Server的TCP收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个起始序号seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手</p>
<p>​        Client收到确认报文段后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>​        在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<p>​        使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>​        所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>
<ul>
<li>FIN = 1，发送方字节流结束，FIN代表一个码位字段。</li>
<li>ACK = 1，确认字符，ACK占用一个码位字段。</li>
<li>seq，（结束）随机序列号 ，给报文段尾字节序号设置一个逻辑地址。</li>
<li>ack ，值为最后一次发送的报文段尾字节序号，TCP将从ack数值指向的字节的逻辑位置开结束传输。 </li>
</ul>
<p><img src="/images/pictures/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/Tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="success"></p>
<ol>
<li><p>第一次挥手</p>
<p>Client的TCP向Server的TCP发送一个连接释放报文段，首部中的FIN标志位被置为 1 ，seq = J，等于前面已经传送过的数据的最后一个字节的序号加 1 。Client进入FIN_WAIT_1状态，Client的TCP停止发送数据，（但仍然可以接收对方发送的数据，对方也可以发送数据）。</p>
</li>
<li><p>第二次挥手</p>
<p>Server的TCP收到连接释放报文段后，即发送确定报文给Client的TCP，报文的ACK标志位被置为 1 ，确认序号为收到序号加 1（seq = J + 1），Server进入CLOSE_WAIT状态，客户机到服务器方向的连接释放了，TCP连接处于半关闭状态。此时服务器仍可以向客户机发送数据。</p>
</li>
<li><p>第三次挥手</p>
<p>若服务器没有要向客户机发送的数据，Server的TCP发送一个FIN = 1 的连接释放报文，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手</p>
<p>客户机收到连接释放报文段后，必须发出确认。在确认报文段，ACK标志位被置为 1 ，Client进入TIME_WAIT状态，确认序号为收到序号加 1（seq = K + 1），Server进入CLOSED状态，完成四次挥手。</p>
</li>
</ol>
<h3 id="TCP连接建立和释放总结"><a href="#TCP连接建立和释放总结" class="headerlink" title="TCP连接建立和释放总结"></a>TCP连接建立和释放总结</h3><ul>
<li><p>连接建立</p>
<ol>
<li>SYN = 1，seq = x。</li>
<li>SYN = 1， ACK = 1，seq = y ，ack = x + 1。</li>
<li>ACK = 1，seq = x + 1， ack = y + 1。</li>
</ol>
</li>
<li><p>释放连接</p>
<ol>
<li>FIN = 1，seq = u。</li>
<li>ACK = 1，seq = v，ack = u + 1。</li>
<li>FIN = 1，ACK = 1，seq = w，ack = u +1。</li>
<li>ACK = 1，seq = u + 1，ack = w + 1。</li>
</ol>
<p>简化助记</p>
<p>TCP是全双工的，即可以想象成是一条TCP连接上有两条数据通路。</p>
<p>三次握手——C端请求连接，S端答应的同时请求连接，C端答应连接</p>
<p>四次挥手——C端主动关闭连接并通知S端，S端回复确认，TCP连接半关闭。S端主动关闭连接并通知C端，C端回复确认，TCP连接关闭。</p>
<p>（区别在于建立连接时是双向的必须得到另一端的同意，关闭连接的一端是单向的，只需要通知对方。）</p>
<p><strong>ACK，SYN，FIN = 1</strong></p>
<p>若为请求连接报文段，SYN字段置为 1 。</p>
<p>若为连接释放报文段，FIN字段置为 1 。</p>
<p>若为需要发回确认，ACK字段置为 1 。</p>
<p>seq 报文随机序号，设置一个逻辑地址。</p>
<p>ack确认号，为上一条seq加 1 ，将从ack数值指向的位置开始/结束接收数据（传输需要偏移量帮助）。</p>
</li>
</ul>
<h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><p>TCP把数据看成一个无结构但是有序的字节流，序号建立在字节流之上，而不是建立再报文段之上。</p>
<p>TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</p>
<h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储那些已经发送但未收到确认的报文段，以便在需要的时候重传。</p>
<h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><ol>
<li>超时</li>
<li>冗余</li>
</ol>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3>]]></content>
  </entry>
  <entry>
    <title>彻底理解Android应用无响应机制</title>
    <url>/2020/03/31/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%E5%BA%94%E7%94%A8%E6%97%A0%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>转载自<a href="http://gityuan.com/2019/04/06/android-anr/" target="_blank" rel="noopener">http://gityuan.com/2019/04/06/android-anr/</a></p>
<a id="more"></a>

<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>不论从事安卓应用开发，还是安卓系统研发，应该都遇到应用无响应（ANR，Application Not Responding）问题，当应用程序一段时间无法及时响应，则会弹出ANR对话框，让用户选择继续等待，还是强制关闭。</p>
<p>绝大多数人对ANR的了解仅停留在主线程耗时或CPU繁忙会导致ANR。面试过无数的候选人，几乎没有人能真正从系统级去梳理清晰ANR的来龙去脉，比如有哪些路径会引发ANR? 有没有可能主线程不耗时也出现ANR？如何更好的调试ANR?</p>
<p>如果没有深入研究过Android Framework的源代码，是难以形成对ANR有一个全面、正确的理解。研究系统源码以及工作实践后提炼而来，以图文并茂的方式跟大家讲解，相信定能帮忙大家加深对ANR的理解。</p>
<h3 id="ANR触发机制"><a href="#ANR触发机制" class="headerlink" title="ANR触发机制"></a>ANR触发机制</h3><p>对于知识学习的过程，要知其然知其所以然，才能做到庖丁解牛般游刃有余。要深入理解ANR，就需要从根上去找寻答案，那就是ANR是如何触发的？</p>
<p>ANR是一套监控Android应用响应是否及时的机制，可以把发生ANR比作是引爆炸弹，那么整个流程包含三部分组成：</p>
<ol>
<li>埋定时炸弹：中控系统(system_server进程)启动倒计时，在规定时间内如果目标(应用进程)没有干完所有的活，则中控系统会定向炸毁(杀进程)目标。</li>
<li>拆炸弹：在规定的时间内干完工地的所有活，并及时向中控系统报告完成，请求解除定时炸弹，则幸免于难。</li>
<li>引爆炸弹：中控系统立即封装现场，抓取快照，搜集目标执行慢的罪证(traces)，便于后续的案件侦破(调试分析)，最后是炸毁目标。</li>
</ol>
<p>常见的ANR有service、broadcast、provider以及input，更多细节详见理解Android ANR的触发原理，<a href="http://gityuan.com/2016/07/02/android-anr，接下来本文以图文形式分别讲解。" target="_blank" rel="noopener">http://gityuan.com/2016/07/02/android-anr，接下来本文以图文形式分别讲解。</a></p>
<h4 id="service超时机制"><a href="#service超时机制" class="headerlink" title="service超时机制"></a>service超时机制</h4><p>下面来看看埋炸弹与拆炸弹在整个服务启动(startService)过程所处的环节。</p>
<p><img src="http://gityuan.com/images/android-anr/service_anr.jpg" alt="service_anr"></p>
<p>图解1：</p>
<ol>
<li>客户端(App进程)向中控系统(system_server进程)发起启动服务的请求</li>
<li>中控系统派出一名空闲的通信员(binder_1线程)接收该请求，紧接着向组件管家(ActivityManager线程)发送消息，埋下定时炸弹</li>
<li>通讯员1号(binder_1)通知工地(service所在进程)的通信员准备开始干活</li>
<li>通讯员3号(binder_3)收到任务后转交给包工头(main主线程)，加入包工头的任务队列(MessageQueue)</li>
<li>包工头经过一番努力干完活(完成service启动的生命周期)，然后等待SharedPreferences(简称SP)的持久化；</li>
<li>包工头在SP执行完成后，立刻向中控系统汇报工作已完成</li>
<li>中控系统的通讯员2号(binder_2)收到包工头的完工汇报后，立刻拆除炸弹。如果在炸弹倒计时结束前拆除炸弹则相安无事，否则会引发爆炸(触发ANR)</li>
</ol>
<p>更多细节详见startService启动过程分析，<a href="http://gityuan.com/2016/03/06/start-service" target="_blank" rel="noopener">http://gityuan.com/2016/03/06/start-service</a></p>
<h4 id="broadcast超时机制"><a href="#broadcast超时机制" class="headerlink" title="broadcast超时机制"></a>broadcast超时机制</h4><p>broadcast跟service超时机制大抵相同，对于静态注册的广播在超时检测过程需要检测SP，如下图所示。</p>
<p><img src="http://gityuan.com/images/android-anr/broadcast_anr.jpg" alt="broadcast_anr"></p>
<p>图解2：</p>
<ol>
<li>客户端(App进程)向中控系统(system_server进程)发起发送广播的请求</li>
<li>中控系统派出一名空闲的通信员(binder_1)接收该请求转交给组件管家(ActivityManager线程)</li>
<li>组件管家执行任务(processNextBroadcast方法)的过程埋下定时炸弹</li>
<li>组件管家通知工地(receiver所在进程)的通信员准备开始干活</li>
<li>通讯员3号(binder_3)收到任务后转交给包工头(main主线程)，加入包工头的任务队列(MessageQueue)</li>
<li>包工头经过一番努力干完活(完成receiver启动的生命周期)，发现当前进程还有SP正在执行写入文件的操作，便将向中控系统汇报的任务交给SP工人(queued-work-looper线程)</li>
<li>SP工人历经艰辛终于完成SP数据的持久化工作，便可以向中控系统汇报工作完成</li>
<li>中控系统的通讯员2号(binder_2)收到包工头的完工汇报后，立刻拆除炸弹。如果在倒计时结束前拆除炸弹则相安无事，否则会引发爆炸(触发ANR)</li>
</ol>
<p>（说明：SP从8.0开始采用名叫“queued-work-looper”的handler线程，在老版本采用newSingleThreadExecutor创建的单线程的线程池）</p>
<p>如果是动态广播，或者静态广播没有正在执行持久化操作的SP任务，则不需要经过“queued-work-looper”线程中转，而是直接向中控系统汇报，流程更为简单，如下图所示：</p>
<p><img src="http://gityuan.com/images/android-anr/broadcast_anr_2.jpg" alt="broadcast_anr_2"></p>
<p>可见，只有XML静态注册的广播超时检测过程会考虑是否有SP尚未完成，动态广播并不受其影响。SP的apply将修改的数据项更新到内存，然后再异步同步数据到磁盘文件，因此很多地方会推荐在主线程调用采用apply方式，避免阻塞主线程，但静态广播超时检测过程需要SP全部持久化到磁盘，如果过度使用apply会增大应用ANR的概率，更多细节详见<a href="http://gityuan.com/2017/06/18/SharedPreferences" target="_blank" rel="noopener">http://gityuan.com/2017/06/18/SharedPreferences</a></p>
<p>Google这样设计的初衷是针对静态广播的场景下，保障进程被杀之前一定能完成SP的数据持久化。因为在向中控系统汇报广播接收者工作执行完成前，该进程的优先级为Foreground级别，高优先级下进程不但不会被杀，而且能分配到更多的CPU时间片，加速完成SP持久化。</p>
<p>更多细节详见Android Broadcast广播机制分析，<a href="http://gityuan.com/2016/06/04/broadcast-receiver" target="_blank" rel="noopener">http://gityuan.com/2016/06/04/broadcast-receiver</a></p>
<h4 id="provider超时机制"><a href="#provider超时机制" class="headerlink" title="provider超时机制"></a>provider超时机制</h4><p>provider的超时是在provider进程首次启动的时候才会检测，当provider进程已启动的场景，再次请求provider并不会触发provider超时。</p>
<p><img src="http://gityuan.com/images/android-anr/provider_anr.jpg" alt="provider_anr"></p>
<p>图解3：</p>
<ol>
<li>客户端(App进程)向中控系统(system_server进程)发起获取内容提供者的请求</li>
<li>中控系统派出一名空闲的通信员(binder_1)接收该请求，检测到内容提供者尚未启动，则先通过zygote孵化新进程</li>
<li>新孵化的provider进程向中控系统注册自己的存在</li>
<li>中控系统的通信员2号接收到该信息后，向组件管家(ActivityManager线程)发送消息，埋下炸弹</li>
<li>通信员2号通知工地(provider进程)的通信员准备开始干活</li>
<li>通讯员4号(binder_4)收到任务后转交给包工头(main主线程)，加入包工头的任务队列(MessageQueue)</li>
<li>包工头经过一番努力干完活(完成provider的安装工作)后向中控系统汇报工作已完成</li>
<li>中控系统的通讯员3号(binder_3)收到包工头的完工汇报后，立刻拆除炸弹。如果在倒计时结束前拆除炸弹则相安无事，否则会引发爆炸(触发ANR)</li>
</ol>
<p>更多细节详见理解ContentProvider原理，<a href="http://gityuan.com/2016/07/30/content-provider" target="_blank" rel="noopener">http://gityuan.com/2016/07/30/content-provider</a></p>
<h4 id="input超时机制"><a href="#input超时机制" class="headerlink" title="input超时机制"></a>input超时机制</h4><p>input的超时检测机制跟service、broadcast、provider截然不同，为了更好的理解input过程先来介绍两个重要线程的相关工作：</p>
<ul>
<li>InputReader线程负责通过EventHub(监听目录/dev/input)读取输入事件，一旦监听到输入事件则放入到InputDispatcher的mInBoundQueue队列，并通知其处理该事件；</li>
<li>InputDispatcher线程负责将接收到的输入事件分发给目标应用窗口，分发过程使用到3个事件队列：<ul>
<li>mInBoundQueue用于记录InputReader发送过来的输入事件；</li>
<li>outBoundQueue用于记录即将分发给目标应用窗口的输入事件；</li>
<li>waitQueue用于记录已分发给目标应用，且应用尚未处理完成的输入事件；</li>
</ul>
</li>
</ul>
<p>input的超时机制并非时间到了一定就会爆炸，而是处理后续上报事件的过程才会去检测是否该爆炸，所以更像是扫雷的过程，具体如下图所示。</p>
<p><img src="http://gityuan.com/images/android-anr/input_anr.jpg" alt="input_anr"></p>
<p>图解4：</p>
<ol>
<li>InputReader线程通过EventHub监听底层上报的输入事件，一旦收到输入事件则将其放至mInBoundQueue队列，并唤醒InputDispatcher线程</li>
<li>InputDispatcher开始分发输入事件，设置埋雷的起点时间。先检测是否有正在处理的事件(mPendingEvent)，如果没有则取出mInBoundQueue队头的事件，并将其赋值给mPendingEvent，且重置ANR的timeout；否则不会从mInBoundQueue中取出事件，也不会重置timeout。然后检查窗口是否就绪(checkWindowReadyForMoreInputLocked)，满足以下任一情况，则会进入扫雷状态(检测前一个正在处理的事件是否超时)，终止本轮事件分发，否则继续执行步骤3。<ul>
<li>对于按键类型的输入事件，则outboundQueue或者waitQueue不为空，</li>
<li>对于非按键的输入事件，则waitQueue不为空，且等待队头时间超时500ms</li>
</ul>
</li>
<li>当应用窗口准备就绪，则将mPendingEvent转移到outBoundQueue队列</li>
<li>当outBoundQueue不为空，且应用管道对端连接状态正常，则将数据从outboundQueue中取出事件，放入waitQueue队列</li>
<li>InputDispatcher通过socket告知目标应用所在进程可以准备开始干活</li>
<li>App在初始化时默认已创建跟中控系统双向通信的socketpair，此时App的包工头(main线程)收到输入事件后，会层层转发到目标窗口来处理</li>
<li>包工头完成工作后，会通过socket向中控系统汇报工作完成，则中控系统会将该事件从waitQueue队列中移除。</li>
</ol>
<p>input超时机制为什么是扫雷，而非定时爆炸呢？是由于对于input来说即便某次事件执行时间超过timeout时长，只要用户后续在没有再生成输入事件，则不会触发ANR。 这里的扫雷是指当前输入系统中正在处理着某个耗时事件的前提下，后续的每一次input事件都会检测前一个正在处理的事件是否超时（进入扫雷状态），检测当前的时间距离上次输入事件分发时间点是否超过timeout时长。如果前一个输入事件，则会重置ANR的timeout，从而不会爆炸。</p>
<p>更多细节详见Input系统-ANR原理分析，<a href="http://gityuan.com/2017/01/01/input-anr" target="_blank" rel="noopener">http://gityuan.com/2017/01/01/input-anr</a></p>
<h3 id="ANR超时阈值"><a href="#ANR超时阈值" class="headerlink" title="ANR超时阈值"></a>ANR超时阈值</h3><p>不同组件的超时阈值各有不同，关于service、broadcast、contentprovider以及input的超时阈值如下表：</p>
<p><img src="http://gityuan.com/images/android-anr/anr_timeout.jpg" alt="anr_timeout"></p>
<h4 id="前台与后台服务的区别"><a href="#前台与后台服务的区别" class="headerlink" title="前台与后台服务的区别"></a>前台与后台服务的区别</h4><p>系统对前台服务启动的超时为20s，而后台服务超时为200s，那么系统是如何区别前台还是后台服务呢？来看看ActiveServices的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在startService过程根据发起方进程callerApp所属的进程调度组来决定被启动的服务是属于前台还是后台。当发起方进程不等于ProcessList.SCHED_GROUP_BACKGROUND(后台进程组)则认为是前台服务，否则为后台服务，并标记在ServiceRecord的成员变量createdFromFg。</p>
<p>什么进程属于SCHED_GROUP_BACKGROUND调度组呢？进程调度组大体可分为TOP、前台、后台，进程优先级（Adj）和进程调度组（SCHED_GROUP）算法较为复杂，其对应关系可粗略理解为Adj等于0的进程属于Top进程组，Adj等于100或者200的进程属于前台进程组，Adj大于200的进程属于后台进程组。关于Adj的含义见下表，简单来说就是Adj&gt;200的进程对用户来说基本是无感知，主要是做一些后台工作，故后台服务拥有更长的超时阈值，同时后台服务属于后台进程调度组，相比前台服务属于前台进程调度组，分配更少的CPU时间片。</p>
<p><img src="http://gityuan.com/images/android-anr/adj.png" alt="adj"></p>
<p>关于细节详见解读Android进程优先级ADJ算法，<a href="http://gityuan.com/2018/05/19/android-process-adj" target="_blank" rel="noopener">http://gityuan.com/2018/05/19/android-process-adj</a></p>
<p><code>前台服务准确来说，是指由处于前台进程调度组的进程发起的服务</code>。这跟常说的fg-service服务有所不同，fg-service是指挂有前台通知的服务。</p>
<h4 id="前台与后台广播超时"><a href="#前台与后台广播超时" class="headerlink" title="前台与后台广播超时"></a>前台与后台广播超时</h4><p>前台广播超时为10s，后台广播超时为60s，那么如何区分前台和后台广播呢？来看看AMS的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>根据发送广播sendBroadcast(Intent intent)中的intent的flags是否包含FLAG_RECEIVER_FOREGROUND来决定把该广播是放入前台广播队列或者后台广播队列，前台广播队列的超时为10s，后台广播队列的超时为60s，默认情况下广播是放入后台广播队列，除非指明加上FLAG_RECEIVER_FOREGROUND标识。</p>
<p>后台广播比前台广播拥有更长的超时阈值，同时在广播分发过程遇到后台service的启动(mDelayBehindServices)会延迟分发广播，等待service的完成，因为等待service而导致的广播ANR会被忽略掉；后台广播属于后台进程调度组，而前台广播属于前台进程调度组。简而言之，后台广播更不容易发生ANR，同时执行的速度也会更慢。</p>
<p>另外，只有串行处理的广播才有超时机制，因为接收者是串行处理的，前一个receiver处理慢，会影响后一个receiver；并行广播通过一个循环一次性向所有的receiver分发广播事件，所以不存在彼此影响的问题，则没有广播超时。</p>
<p><code>前台广播准确来说，是指位于前台广播队列的广播</code>。</p>
<h4 id="前台与后台ANR"><a href="#前台与后台ANR" class="headerlink" title="前台与后台ANR"></a>前台与后台ANR</h4><p>除了前台服务，前台广播，还有前台ANR可能会让你云里雾里的，来看看其中核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">appNotResponding</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        isSilentANR = !showBackground &amp;&amp; !isInterestingForBackgroundTraces(app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    File tracesFile = ActivityManagerService.dumpStackTraces(</span><br><span class="line">            <span class="keyword">true</span>, firstPids,</span><br><span class="line">            (isSilentANR) ? <span class="keyword">null</span> : processCpuTracker,</span><br><span class="line">            (isSilentANR) ? <span class="keyword">null</span> : lastPids,</span><br><span class="line">            nativePids);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSilentANR) &#123;</span><br><span class="line">            app.kill(<span class="string">"bg anr"</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出ANR选择的对话框</span></span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">        msg.obj = <span class="keyword">new</span> AppNotRespondingDialog.Data(app, activity, aboveSystem);</span><br><span class="line">        mService.mUiHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>决定是前台或者后台ANR取决于该应用发生ANR时对用户是否可感知，比如拥有当前前台可见的activity的进程，或者拥有前台通知的fg-service的进程，这些是用户可感知的场景，发生ANR对用户体验影响比较大，故需要弹框让用户决定是否退出还是等待，如果直接杀掉这类应用会给用户造成莫名其妙的闪退。</p>
<p>后台ANR相比前台ANR，只抓取发生无响应进程的trace，也不会收集CPU信息，并且会在后台直接杀掉该无响应的进程，不会弹框提示用户。</p>
<p><code>前台ANR准确来说，是指对用户可感知的进程发生的ANR</code>。</p>
<h3 id="ANR爆炸现场"><a href="#ANR爆炸现场" class="headerlink" title="ANR爆炸现场"></a>ANR爆炸现场</h3><p>对于service、broadcast、provider、input发生ANR后，中控系统会马上去抓取现场的信息，用于调试分析。收集的信息包括如下：</p>
<ul>
<li>将am_anr信息输出到EventLog，也就是说ANR触发的时间点最接近的就是EventLog中输出的am_anr信息</li>
<li>收集以下重要进程的各个线程调用栈trace信息，保存在data/anr/traces.txt文件<ul>
<li>当前发生ANR的进程，system_server进程以及所有persistent进程</li>
<li>audioserver, cameraserver, mediaserver, surfaceflinger等重要的native进程</li>
<li>CPU使用率排名前5的进程</li>
</ul>
</li>
<li>将发生ANR的reason以及CPU使用情况信息输出到main log</li>
<li>将traces文件和CPU使用情况信息保存到dropbox，即data/system/dropbox目录</li>
<li>对用户可感知的进程则弹出ANR对话框告知用户，对用户不可感知的进程发生ANR则直接杀掉</li>
</ul>
<p>整个ANR信息收集过程比较耗时，其中抓取进程的trace信息，每抓取一个等待200ms，可见persistent越多，等待时间越长。关于抓取trace命令，对于Java进程可通过在adb shell环境下执行kill -3 [pid]可抓取相应pid的调用栈；对于Native进程在adb shell环境下执行debuggerd -b [pid]可抓取相应pid的调用栈。对于ANR问题发生后的蛛丝马迹(trace)在traces.txt和dropbox目录中保存记录。更多细节详见理解Android ANR的信息收集过程，<a href="http://gityuan.com/2016/12/02/app-not-response。" target="_blank" rel="noopener">http://gityuan.com/2016/12/02/app-not-response。</a></p>
<p>有了现场信息，可以调试分析，先定位发生ANR时间点，然后查看trace信息，接着分析是否有耗时的message、binder调用，锁的竞争，CPU资源的抢占，以及结合具体场景的上下文来分析，调试手段就需要针对前面说到的message、binder、锁等资源从系统角度细化更多debug信息，这里不再展开，后续再以ANR案例来讲解。</p>
<p>作为应用开发者应让主线程尽量只做UI相关的操作，避免耗时操作，比如过度复杂的UI绘制，网络操作，文件IO操作；避免主线程跟工作线程发生锁的竞争，减少系统耗时binder的调用，谨慎使用sharePreference，注意主线程执行provider query操作。简而言之，尽可能减少主线程的负载，让其空闲待命，以期可随时响应用户的操作。</p>
<h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><p>最后，来回答文章开头的提问，有哪些路径会引发ANR? 答应是从埋下定时炸弹到拆炸弹之间的任何一个或多个路径执行慢都会导致ANR（以service为例），可以是service的生命周期的回调方法(比如onStartCommand)执行慢，可以是主线程的消息队列存在其他耗时消息让service回调方法迟迟得不到执行，可以是SP操作执行慢，可以是system_server进程的binder线程繁忙而导致没有及时收到拆炸弹的指令。另外ActivityManager线程也可能阻塞，出现的现象就是前台服务执行时间有可能超过10s，但并不会出现ANR。</p>
<p>发生ANR时从trace来看主线程却处于空闲状态或者停留在非耗时代码的原因有哪些？可以是抓取trace过于耗时而错过现场，可以是主线程消息队列堆积大量消息而最后抓取快照一刻只是瞬时状态，可以是广播的“queued-work-looper”一直在处理SP操作。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>详解KMP算法</title>
    <url>/2020/03/25/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>因为发现网上缺少kmp算法的详细解析，大多解析又是从数学角度解释kmp算法的原理，让人云里雾里看不明白，故有了这篇文章，主要对kmp算法难点求next[]数组的算法进行详细解析。</p>
<a id="more"></a>

<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/1.jpeg" alt="success"></p>
<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/2.jpeg" alt="success"></p>
<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/3.jpeg" alt="success"></p>
<p><img src="/images/pictures/%E8%AF%A6%E8%A7%A3KMP%E7%AE%97%E6%B3%95/4.jpeg" alt="success"></p>
]]></content>
  </entry>
  <entry>
    <title>算法分析步骤</title>
    <url>/2020/03/23/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<ol>
<li>首先说明采用哪些数据结构，分别做什么操作</li>
<li>对采用的数据结构中的变量、指针和参数加以说明</li>
<li>对程序整体的初始状态、运行状态、结束状态依次加以说明</li>
</ol>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
  </entry>
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <url>/2020/03/23/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的<strong>有序</strong>数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<a id="more"></a>

<p>示例 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0<br>示例 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / <span class="number">2</span></span><br><span class="line">        j = half_len - i</span><br><span class="line">        <span class="keyword">if</span> i &lt; m <span class="keyword">and</span> B[j<span class="number">-1</span>] &gt; A[i]:</span><br><span class="line">            <span class="comment"># i is too small, must increase it</span></span><br><span class="line">            imin = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] &gt; B[j]:</span><br><span class="line">            <span class="comment"># i is too big, must decrease it</span></span><br><span class="line">            imax = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># i is perfect</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: max_of_left = B[j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: max_of_left = A[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>: max_of_left = max(A[i<span class="number">-1</span>], B[j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> max_of_left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == m: min_of_right = B[j]</span><br><span class="line">            <span class="keyword">elif</span> j == n: min_of_right = A[i]</span><br><span class="line">            <span class="keyword">else</span>: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>​        O(log(min(m,n)))</p>
<p>​        首先，查找的区间是 [0, m]。而该区间的长度在每次循环之后都会减少为原来的一半。所以，我们只需要执行 log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m))。由于 m≤nm≤n，所以时间复杂度是 O(log(min(m,n)))。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>​        O(1)</p>
<p>​        我们只需要恒定的内存来存储 99 个局部变量， 所以空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>LeedCode</category>
      </categories>
  </entry>
  <entry>
    <title>形象描述实现临界区互斥的基本方法</title>
    <url>/2020/03/23/%E5%BD%A2%E8%B1%A1%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>用四个例子形象说明实现临界区互斥的基本方法</p>
<a id="more"></a>

<h2 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h2><p>是轮流请客吃饭，有可能出现有吝啬鬼进程一直拖延请客——违背空闲让进。</p>
<h2 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h2><p>对手之间抢资源，进程先检查资源有无主，无主就声明资源是自己的，有可能发生进程为了争夺无主资源打群架（是我先看见的）——违背忙则等待。</p>
<h2 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h2><p>队友之间抢资源，大家先声明谁需要这个资源，然后找到之后就给谁，有可能大家互相谦让，没完没了——违背有限等待，造成饥饿。</p>
<h2 id="Peterson’s-Algorithm"><a href="#Peterson’s-Algorithm" class="headerlink" title="Peterson’s Algorithm"></a>Peterson’s Algorithm</h2><p>丐帮传位，首先声明自己要当帮主，并得到大家的认可，再抢到帮会信物打狗棒证明自己——完美算法。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 JVM</title>
    <url>/2020/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    <content><![CDATA[<p>本文是《深入理解 JVM 》一书的笔记，将对书中知识做出提炼与总结。</p>
<a id="more"></a>

<h2 id="JVM-amp-amp-GC-深入知识"><a href="#JVM-amp-amp-GC-深入知识" class="headerlink" title="JVM &amp;&amp; GC 深入知识"></a>JVM &amp;&amp; GC 深入知识</h2><ul>
<li>了解 JVM 和内存相关的知识 。</li>
<li>了解常见的垃圾收集算法，这是 GC 实现的根本目标 。</li>
<li>了解 GC 的基本概念。</li>
<li>了解各类 GC 的特性 。</li>
<li>为深入了解 G1 GC 做好知识储备 。</li>
<li>Java 虚拟机内存模型。</li>
</ul>
<p>根据受访权限的不同设置，将 Java 虚拟机内存模型几个区域分为：</p>
<ul>
<li>线程共享类：可以允许被所有的线程共享访问的一类内存区域（包括堆内存区、方法区、运行时常量池）</li>
<li>线程私有类：非线程共享类。</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>一块很小的内存空间</li>
<li>存储速度最快</li>
<li>位于处理器内部（不同于其他存储区的地方）</li>
<li>数量有限</li>
<li>寄存器由编译器根据需求进行分配</li>
<li>在 Java 应用程序内部透明</li>
<li>字节码解释器的工作依赖计数器来完成</li>
</ul>
<p>Java线程数量超过 CPU 数量时，线程之间采用时间片轮转调度算法实现并发执行，为此，每一个线程都必须有一个独立的程序计数器，它被用来记录下一条需要执行的计算机指令 ，是线程独有的一块内存空间。</p>
<p>如果当前线程正在执行一个 Java 方法，则程序计数器记录正在执行的 Java 字节码地址，如果当前线程正在执行 一个本地方法，则程序计数器为空。</p>
<p>简单概括，即在多线程环境下，为了让线程切换后能恢复到正确的执行位置，每个钱程都需要有一个独立的程序计数器，各个线程之间互不影响、独立存储,因此这块内存是线程私有的。 JVM 中的寄存器类似于物理寄存器的一种抽象模拟，它是线程私有的，所以生命周期与线程的生命周期保持一致。</p>
<p>根据 Java 虚拟机定义来看，程序寄存器区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOtMemoryError情况的区域。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>JVM 的架构是基于栈。</p>
<p>虚拟机栈是一种可以被用来快速访问的存储区域，访问速度仅次于寄存器，堆战指针若向下移动，则分配新的内存，若向上移动，则释放那些内存。位于通用 RAM 里面,通过使用它的所谓的“核指针”可以访问处理器。</p>
<p>Java 虚拟机需要预先去生成相应的内存空间，所以当我们尝试运行程序的时候，Java 虚拟机必须知道被存储在栈内的所有数据的确切大小和生命周期，以便按照上面陈述的分配存储方法通过上下移动堆栈指针来动态调整内存空间。故只有某些 Java 数据，特别是对象引用，它被存储在校里面，而应用程序内部数量庞大的 Java 对象没有被存储在虚拟机技里面。</p>
<p>JVM 中存放在战内的数据可以共享。</p>
<p>与程序计数器一样， Java 虚拟机技也是线程私有的内存空间，它和 Java 线程在同一时间创建，它保存方法的局部变量、部分结果,井参与方法的调用和返回。</p>
<p>Java 虚拟机规范允许 Java 枝的大小是动态的或者是固定不变的 。</p>
<h4 id="两种与栈空间有关的异常"><a href="#两种与栈空间有关的异常" class="headerlink" title="两种与栈空间有关的异常"></a>两种与栈空间有关的异常</h4><ul>
<li>StackoverFlowError：线程在计算过程中，请求的战深度大于最大可用的战深度。</li>
<li>OutofMemoryError ：如果 Java 栈可以动态扩展，而在扩展的过程中没有足够的内存空间。</li>
</ul>
<p>设置虚拟机栈的大小：-XSS</p>
<h4 id="虚拟机栈的内部结构"><a href="#虚拟机栈的内部结构" class="headerlink" title="虚拟机栈的内部结构"></a>虚拟机栈的内部结构</h4><p>虚拟机栈在运行时使用 一种叫做栈帧的数据结构保存上下文数据。</p>
<p>栈帧里面存放了方法的</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接方法（指向运行时常量池的引用）</li>
<li>返回地址</li>
<li>附加信息</li>
</ul>
<p>方法的调用 =&gt; 栈帧的入栈操作</p>
<p>方法的返回 =&gt; 栈帧的出栈操作 </p>
<p> 如果方法调用时，方法的参数和局部变量相对较多，那么栈帧中的局部变量表就会比较大，栈帧会不断膨胀以满足方法调用所需传递的信息增大需求。因此，单个方法调用所需的栈空间也会比较多。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><em>局部变量</em></h4><ul>
<li><p><em>定义在函数内部的变量称为局部变量(函数的形参也是局部变量)</em></p>
</li>
<li><p><em>局部变量只能在函数内部使用</em></p>
<p><em>局部变量在函数调用时才能够被创建，在函数调用结束之后会自动销毁</em></p>
</li>
</ul>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><em>全局变量</em></h5><ul>
<li><em>定义在函数外部，模块内部的变量称为全局变量</em></li>
<li><em>所有的函数都可以直接访问”全局”变量，但函数内部不能直接通过赋值语句来改变全局变量</em></li>
</ul>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a><em>局部变量表</em></h5><ul>
<li><em>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量（包含各类基本数据类型、对象引用（ reference ），以及r eturnAddress 类型。）</em></li>
<li><em>最基本的存储单元是slot（变量槽）。</em></li>
<li><em>建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</em></li>
<li><em>局部变量表所需的容量大小是在编译期固定下来的，保存在Code属性的maximum local variables数据项中。</em></li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>虚拟机实现本地方法：传递给函数的参数以某个确定的顺序入栈，也以确定的方式返回值。</p>
<p>线程会保存本地方法栈的状态并进入到另一个 Java 栈 。</p>
<p>本地方法栈的内存区允许动态扩展收缩，某些 JVM 也允许用户或者程序员指定该内存区的初始大小以及最大、最小值。</p>
<p>Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈用于管理本地方法的调用。</p>
<p>本地方法并不是用 Java 实现的，而是使用 C 实现的。本质上是依赖于实现的。Can do anything you want,even register operation.</p>
<p><em>在 SUN 的 Hotspot 虚拟机中，不区分本地方法械和虚拟机栈。因此，和虚拟机栈一样，它也会抛出 <code>STACKOVERFLOWERROR</code> 和<code>OUTOFMEMORYERROR</code> 。</em></p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>堆在 JVM 规范里是一种通用性的内存池(也存在于 RAM 中)，用于存放所有的 Java 对象。</p>
<p>堆是一个运行时数据区，类的对象从中分配空间，这些对象通过 <code>New</code> 关键字建立，不需要程序代码来显式地释放。大多数的虚拟机里，Java 中的对象和数组都存放在堆中 。</p>
<h4 id="堆相对于栈的优缺点："><a href="#堆相对于栈的优缺点：" class="headerlink" title="堆相对于栈的优缺点："></a>堆相对于栈的优缺点：</h4><ul>
<li>优点：由垃圾回收负责，可以在运行时动态地分配内存大小，生存周期不需要事先告诉编译器。Java 的垃圾收集器会自动收走那些不再使用的数据。</li>
<li>缺点：要在运行时动态分配内存，数据访问速度较慢。</li>
</ul>
<p>Java 堆区在 NM 启动的时候即被创建，它只要求逻辑上是连续的，在物理空间上可以是不连续。所有的线程共享 Java 堆，在这里可以划分钱程私有的缓冲区 ( Thread Local Allocation Buffer, TLAB ) 。</p>
<p>Java 堆是 GC ( Garbage Collection）执行垃圾回收的重点区域，GC 极有可能会在<u>大内存的使用</u>和<u>频繁进行垃圾回收</u>过程上成为系统性能瓶颈。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li><p>类的类型信息</p>
<ul>
<li>类的完整名称</li>
<li>父类的完整名称</li>
<li>类型修饰符( pubIic/protected/private )</li>
<li>类型的直接接口类表</li>
</ul>
</li>
<li><p>常量池</p>
<p>类方法、域等信息所引用的常量信息。</p>
</li>
<li><p>域信息</p>
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符</li>
</ul>
</li>
<li><p>方法信息</p>
<ul>
<li>方法名称</li>
<li>返回类型</li>
<li>方法参数</li>
<li>方法修饰符表</li>
<li>方法字节码</li>
<li>操作数栈</li>
<li>方法栈帧的局部变量区大小</li>
<li>异常表</li>
</ul>
</li>
</ul>
<p>方法区是线程间共享的（与堆空间类似）：当两个线程同时需要加载一个类型时，只有一个类会请求 ClassLoader 加载，另一个线程则会等待。方法区内保存的信息大部分来自于 Class 文件（类的元数据）。</p>
<p>GC 针对方法区的回收：</p>
<ul>
<li><p>GC 对方法区常量池的回收</p>
</li>
<li><p>方法区对类元数据的回收</p>
</li>
</ul>
<p><em>HotSpot 虚拟机对常量池的回收策略：只要常量池中的常量没有被任何地方引用，就可以被回收。</em></p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>垃圾标记阶段：区分出内存中哪些是存活对象，哪些是已经死亡的对象。</p>
<p>实现：为每个对象配置一个整形的计数器。</p>
<p>对于一个对象 A，只要有任何 一个对象引用了 A ，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1，只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。</p>
<p>存活对象：计数器中的值不为0。</p>
<p>引用计数器算法的一大优势就是不用等待内存不够用的时候，才进行垃圾的回收，完全可以在赋值操作的同时检查计数器是否为 0 ，如果是的话就可以立即回收。</p>
<p>需要单独的字段存储计数器 =&gt; 增加存储空间的开销。</p>
<p>每次赋值都需要更新计数器 =&gt; 这增加了时间开销。</p>
<h4 id="一个严重的问题：无法处理循环引用"><a href="#一个严重的问题：无法处理循环引用" class="headerlink" title="一个严重的问题：无法处理循环引用"></a>一个严重的问题：无法处理循环引用</h4><p>垃圾对象间相互引用形成死锁，从而使垃圾回收器无法识别，引起内存泄漏。导致在 Java 的垃圾回收器中没有使用这类算法 。</p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>Hotspot 和大部分 JVM 都是使用根搜索算法作为垃圾标记的算法实现。</p>
<p>使用根搜索算法后，内存中的存活对象都会被根对象集合直接或间接连接着。</p>
<p>根搜索算法是以根对象集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达，如果目标对象不可达，就意味着该对象己经死亡，便可以在 instanceOopDesc 的 Mark World 中将其标记为垃圾对象。</p>
<p>存活对象：能够被根对象集合直接或者间接连接的对象。</p>
<p>在 Hotspot 中，根对象集合中</p>
<ul>
<li>Java 栈内的对象引用</li>
<li>本地方法栈内的对象引用</li>
<li>运行时常量池中的对象引用</li>
<li>方法区中类静态属性的对象引用</li>
<li>与一个类对应的唯一数据类型的 Class 对象</li>
</ul>
<p><strong>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告 一个对象死亡，至少要经历两次标记过程。如果对象在进行根搜索后发现没有与 GCRoots 相连接的引用链，那它将会被第一次标记井且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖<code>finalize()</code>方法,或者 <code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行。如果这个对象被判定有必要执行 <code>finalize()</code>方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 <code>finalize()</code>方法中执行缓慢，或者发生了死循环(更极端的情况)，很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 <code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在<code>finalize()</code>中成功拯救自己一一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合。如果对象这时候还没有逃脱，那它就真的离死不远了 。</strong></p>
<p><em>任何一个对象的 finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize()方法不会被再次执行。</em></p>
<h3 id="三种常用GC算法的比较"><a href="#三种常用GC算法的比较" class="headerlink" title="三种常用GC算法的比较"></a>三种常用GC算法的比较</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td align="left">中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td align="left">少（会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的两倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td align="left">否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>collector ：垃圾收集器</p>
<p>mutator ：除了垃圾收集器之外的部分。</p>
<p>mutator 的职责</p>
<ul>
<li>NEW（分配内存）</li>
<li>RAD（从内存中读取内容）</li>
<li>WRITE（将内容写入内存）</li>
</ul>
<p>collector 就是回收不再使用的内存来供 mutator 进行 NEW 操作的使用。</p>
<p>mutator 根对象一般指的是分配在堆内存之外，可以直接被 mutator 直接访问到的对象，一般是指静态/全局变量以及 ThreadLocal 变量。</p>
<h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法 ( Mark-Sweep )"></a>标记-清除算法 ( Mark-Sweep )</h3><ol>
<li><p>标记阶段：collector 从 mutator 根对象开始进行遍历，对从 mutator 根对象可以访问到的对象都打上一个标识，一般是在对象的 header 中，将其记录为可达对象。</p>
</li>
<li><p>清除阶段：collector 对堆内存( heap memory )从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象，通过读取对象的 header 信息，则将其回收。</p>
<p>一种可行的实现是：</p>
<ol>
<li>在标记阶段首先通过根节点，标记所有从根节点开始的可达对象。</li>
<li>在清除阶段，清除所有未被标记的对象。</li>
</ol>
</li>
</ol>
<p>这种分步执行的思路奠定了现代垃圾收集算法的思想基础。</p>
<p><em>与引用计数算法不同，标记-清除算法不需要运行环境监测每一次内存分配和指针操作,而只要在“标记”阶段中跟踪每一个指针变量的指向，用类似思路实现的垃圾收集器也常被后人统称为跟踪收集器( Tracing Collector )。</em></p>
<h4 id="标记-清除算法缺点"><a href="#标记-清除算法缺点" class="headerlink" title="标记-清除算法缺点"></a>标记-清除算法缺点</h4><ul>
<li>产生碎片：回收后的空间是不连续的。</li>
<li>效率低下：在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</li>
</ul>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法 ( Copying )"></a>复制算法 ( Copying )</h4><p><em>为了解决标记-清除算法在垃圾收集效率方面的缺陷， M.L.Minsky 于 1963 年发表了著名的</em><br><em>论文，“ 一利使用双存储区的 Lisp 语 言垃圾收集器 CA LISP Garbage Collector Algorithm Using</em><br><em>Serial Secondary Storage )”。</em></p>
<ol>
<li>将活着的内存空间分为两块，每次只使用其中一块</li>
<li>在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中</li>
<li>清除正在使用的内存块中的所有对象</li>
<li>交换两个内存的角色</li>
<li>最后完成垃圾回收</li>
</ol>
<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻,复制算法的效率是很高的。</p>
<p>又由于对象在垃圾回收过程中统一被复制到新的内存空间中，回收后的内存空间是没有碎片的。</p>
<p>缺点：系统内存折半。</p>
<h3 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记-压缩算法 ( Mark-Compact)"></a>标记-压缩算法 ( Mark-Compact)</h3><p>标记-压缩算法是标记-清除算法和复制算法的有机结合。</p>
<ol>
<li><p>标记出内存中的垃圾对象</p>
</li>
<li><p>将所有的存活对象都移动到一个规整且连续的内存空间中（内存的一端）</p>
</li>
<li><p>然后执行 Full GC (老年代的垃圾回收 )回收无用对象所占用的内存空间 </p>
<p><em>执行压缩之后，已用和未用的内存都各自一边，彼此之间维系着一个记录下一 次分配起始点的标记指针</em></p>
</li>
<li><p>为新对象分配内存（使用指针碰撞( Bump the Pointer )技术修改指针的偏移量将新对象分配在第 一个空闲内存位置上，为新对象分配内存带来便捷）</p>
</li>
</ol>
<p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自<br>的特点。针对不同的代空间，结合使用不同的垃圾收集算法：</p>
<ul>
<li><p>年轻代通常是以速度优先</p>
<ul>
<li>存储的瞬时对象生命周期非常短暂 =&gt; 可以有针对性地使用复制算法，执行 Minor GC 时, 一 定要保持高效和快速</li>
<li>生存空间通常都比较小 =&gt; 回收年轻代时一定会非常频繁</li>
</ul>
</li>
<li><p>老年代通常使用更节省内存的回收算法</p>
<p>老年代中所存储的对象生命周期都非常长，并且老年代占据了大部分的堆空间，所以老年代的 Full GC 并不会跟年轻代的 Minor GC 一样频繁，不过一旦程序中发生一次 Full GC ，将会耗费更长的时间来完成，那么在老年代中使用标记-清除算法或者标记-压缩算法执行垃圾回收将会是不错的选择。</p>
</li>
</ul>
<p><em>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</em></p>
<p>既避免了碎片的产生，又不需要两块相同的内存空间，性价比比较高。</p>
<h3 id="增量算法-Incremental-Collecting"><a href="#增量算法-Incremental-Collecting" class="headerlink" title="增量算法 ( Incremental Collecting )"></a>增量算法 ( Incremental Collecting )</h3><h4 id="Stop-the-World状态"><a href="#Stop-the-World状态" class="headerlink" title="Stop the World状态"></a>Stop the World状态</h4><p>垃圾回收Stop the World 状态：应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。</p>
<p>如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p>
<p>为了进行实时垃圾收集，可以设计一个多进程的运行环境，比如用一个进程执行垃圾收集工作，另一个进程执行程序代码。垃圾收集工作看上去就仿佛是在后台悄悄完成的，不会打断程序代码的运行。</p>
<h4 id="多进程的运行环境面临的问题"><a href="#多进程的运行环境面临的问题" class="headerlink" title="多进程的运行环境面临的问题"></a>多进程的运行环境面临的问题</h4><p>如果垃圾收集进程包括标记和清除两个工作阶段，垃圾收集器在第一阶段中辛辛苦苦标记出的结果很可能被另 一个进程中的内存操作代码修改得面目全非，以至于第二阶段的工作没有办法开展。</p>
<p><em>M. L. Minsky 和 D. E. Knuth 对实时垃圾收集过程中的技术难点进行了早期的研究, G. L.Steele 于 1975 年发表了题为“多进程整理的垃圾收集 ( Multiprocessing Compactifying Garbage Collection ) ”的论文,描述了一种被后人称为“ Minsky-Knuth-Steele 算法”的实时垃圾收集算法。 E.W.Dijkstra、 L.Lamport 、 R.R.Fenichel 和 J.C.Yochelson 等人也相继在此领域做出了各自的贡献。 1978 年，H.G .Baker 发表了“串行计算机上的实时表处理技术 ( List Processing in Real Time on a Serial Computer ) ” 一文，系统阐述了多进程环境下用于垃圾收集的增量收集算法。</em></p>
<h4 id="增量算法的基本思想"><a href="#增量算法的基本思想" class="headerlink" title="增量算法的基本思想"></a>增量算法的基本思想</h4><p>如果一次性将所有的垃圾进行处理,需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<ul>
<li>间断性地还执行了应用程序代码 =&gt; 所以能减少系统的停顿时间</li>
<li>线程切换和上下文转换的消耗 =&gt; 垃圾回收的总体成本上升 =&gt; 系统吞吐量下降</li>
</ul>
<p>增量收集算法的基础仍是传统的标记-清除和复制算法。</p>
<p>增量收集算法通过对进程间冲突的妥善处理，允许垃圾收集进程以分阶段的方式完成标记、清理或复制工作。</p>
<h3 id="分代收集算法-GenerationalCollecting"><a href="#分代收集算法-GenerationalCollecting" class="headerlink" title="分代收集算法( GenerationalCollecting )"></a>分代收集算法( GenerationalCollecting )</h3><p>大多数内存块的生存周期都比较短，垃圾收集器应当把更多的精力放在检查和清理新分配的内存块上。</p>
<p><em>D E. Knuth, T. Knight、 G. Sussman 和 R. Stallman 等人对内存垃圾的分类处理做了最早的研究。 1983 年， H. Lieberman 和 C. Hewitt 发表了题为“基于对象寿命的一种实时垃圾收集器( A Real-Time Garbage Collector Based on the Lifetimes of Object ) ”的论文。这篇著名的论文标志着分代收集算法的正式诞生。此后，在 H. G. Baker 、 R. L. Hudson 、 J.E. B. Moss 等人的共同努力下，分代收集算法逐渐成为了垃圾收集领域里的主流技术</em>。</p>
<h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><p>将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法以提高垃圾回收的效率 。</p>
<p>以Hotspot 虚拟机为例：</p>
<ul>
<li><p>年轻代：所有的新建对象所在区域。</p>
<p>对象会很快回收，选择效率较高的复制算法。</p>
</li>
<li><p>老年代：经过几次回收后依然存活的对象所在区域。</p>
<p><em>可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老年代，将需要复制大量对象。再加上老年代的回收性价比也要低于年轻代，因此这种做法也是不可取的。</em></p>
<p>使用标记-压缩算法，提高垃圾回收效率。</p>
</li>
</ul>
<p>总的来说，分代收集算法是基于对对象生命周期分析后得出的垃圾回收算法。它把对象分为年轻代、老年代、持久代，对不同生命周期的对象使用不同的算法(上述方式中的一个)进行回收。</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><h3 id="GC概念"><a href="#GC概念" class="headerlink" title="GC概念"></a>GC概念</h3><h4 id="HotSpot中GC划分的两大块"><a href="#HotSpot中GC划分的两大块" class="headerlink" title="HotSpot中GC划分的两大块"></a>HotSpot中GC划分的两大块</h4><ul>
<li>内存的动态分配</li>
<li>垃圾回收</li>
</ul>
<p>在内存执行分配之前 GC 首先会对内存空间进行分代划分</p>
<p>当内存空间中的内存消耗达到了一定阔值的时候，GC 就会执行垃圾回收。</p>
<h4 id="回收算法四个要求"><a href="#回收算法四个要求" class="headerlink" title="回收算法四个要求"></a>回收算法四个要求</h4><ol>
<li>不能造成内存中存活的对象被错误地回收掉</li>
<li>不能造成已经死亡的对象没有被及时地回收掉</li>
<li>高效，不应该导致应用程序出现长时间的暂停</li>
<li>避免产生内存碎片</li>
</ol>
<h4 id="GC性能标准"><a href="#GC性能标准" class="headerlink" title="GC性能标准"></a>GC性能标准</h4><ul>
<li>吞吐量：程序的运行时间(程序的运行时间+内存回收的时间)。</li>
<li>垃圾收集开销：吞吐量的补数,垃圾收集器所占时间与总时间的比例。</li>
<li>暂停时间：执行垃圾收集时,程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行,收集操作发生的频率。</li>
<li>堆空间：Java 堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><p>基于分代 的概念,不同的分代空间中均活动着不同的 GC 。</p>
<p>JVM 在实际运行过程中，年轻代和老年代中各自的 GC 需要组合在一起共同执行垃圾回收任务。</p>
<p>在实际开发过程中，年轻代和老年代的 GC 的组合方式还需要结合具体的应用场景进行分析后得到。</p>
<h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h4><ul>
<li><p>串行垃圾回收器</p>
<p>在同一时间段内只允许一件事情发生。当多个 CPU 可用时，也只能有一个 CPU 用于执行垃圾回收操作，井且在执行垃圾回收时，程序中的工作线程将会被暂停，当垃圾收集工作完成后才会恢复之前被暂停的工作线程。</p>
</li>
<li><p>并行垃圾回收器</p>
<p>在收集过程中，应用程序会全部暂停 。 但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者井发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差 。</p>
</li>
</ul>
<h4 id="按照工作模式分"><a href="#按照工作模式分" class="headerlink" title="按照工作模式分"></a>按照工作模式分</h4><ul>
<li><p>井发式垃坡回收器</p>
<p>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</p>
</li>
<li><p>独占式垃圾回收器</p>
<p>独占式垃圾回收器( S top the world)一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</p>
</li>
</ul>
<h4 id="按碎片处理方式"><a href="#按碎片处理方式" class="headerlink" title="按碎片处理方式"></a>按碎片处理方式</h4><ul>
<li><p>压缩式垃圾回收器</p>
<p>压缩式垃圾回收器会在<br>回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p>
</li>
<li><p>非压缩式垃圾回收器</p>
<p>非压缩式的垃圾回收器不进行这步操作。</p>
</li>
</ul>
<h4 id="按工作的内存区间"><a href="#按工作的内存区间" class="headerlink" title="按工作的内存区间"></a>按工作的内存区间</h4><ul>
<li>年轻代垃圾回收器</li>
<li>老年代垃圾回收器</li>
</ul>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>它采用复制算法、串行回收和“Stop-the-World”机制的方式执行内存回收 。</p>
<p><em>在早期的 JDK 版本中，由于那个年代的 CPU 速度并没有这么快,所以在 CPU 受限于单个 CPU 的情况下，使用 Serial 收集器执行年轻代垃圾收集几乎是唯一 的选择。Serial 收集器默认也作为 HotSpot 中 Client 模式下的年轻代垃圾收集器。</em></p>
<p>Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。同样也采用了串行回收和“Stop the-World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<p><em>如果在 JVM 受限于单个 CPU 的环境下，使用 Serial 收集器加上 Serial Old 收集器的组合执行 Client 模式下的内存回收将会是不错的选择——基于串行回收的垃圾收集器适用于大多数对暂停时间要求不高的 Client 模式下的 JVM，由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销，虽然执行串行回收会降低程序的吞吐量，但是回收质量还是不错的。在程序中，开发人员可以通过选项 “-XX:+UseSerialGC” 手动指定使用 Serial 收集器执行内存回收任务。</em></p>
<ol>
<li>该算法的第一步是在老年代标记存活的对象。</li>
<li>从头开始检查堆内存空间，并且只留下依然幸存的对象（清除）。</li>
<li>最后一步，从头开始，顺序地填满堆内存空间，将存活的对象连续存放在一起，这样堆<br>分成两部分，一边有存放的对象，一边没有对象（整理）。</li>
<li>Serial 收集器应用于小的存储器和少量的 CPU 。</li>
</ol>
<ul>
<li><h4 id="年轻代串行收集器"><a href="#年轻代串行收集器" class="headerlink" title="年轻代串行收集器"></a>年轻代串行收集器</h4><p>在 HotSpot 虚拟机中，使用-XX: +UseSerialGC 参数可以指定使用年轻代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。</p>
</li>
<li><h4 id="老年代串行收集器"><a href="#老年代串行收集器" class="headerlink" title="老年代串行收集器"></a>老年代串行收集器</h4><p>老年代串行收集器使用的是标记-压缩算法。</p>
<p>是串行的、独占式的垃圾回收器（和年轻代收集器相同）。</p>
<p><em>由于老年代垃圾回收通常会使用比年轻代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以和多种年轻代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。</em></p>
<p>启用老年代串行回收器：</p>
<ul>
<li>-XX :+UseSerialGC：年轻代、老年代都使用串行回收器</li>
<li>-XX:+UseParNewGC：指定年轻代使用井行收集器，老年代使用串行收集器</li>
</ul>
</li>
</ul>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>如果说 Serial 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。</p>
<p>ParNew 收集器除了采用井行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别，因为 ParNew 收集器在年轻代中同样也是采用复制算法和“Stop-the-World”机制。</p>
<p>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU 、多核心等物理硬件资源优势，确实可以更快速地完成垃圾收集，提升程序的吞吐量，但是如果是在单个 CPU 的环境下，ParNew 收集器不见得比 Serial 收集器更高效。</p>
<p><em>虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换,因此可以有效避免多线程交互过程中产生的一 些额外开销 。所以从理论上来说， Serial 收集器的优势是在 JVM 受限于单 CPU 环境中，而 ParNew 收集器的优势则是体现在多 CPU 、多核心的环境中，并且在某些注重低延迟的应用场景下，ParNew 收集器和 CMS (Concurrent-Mark-Sweep )收集器的组合模式，在 Sever 模式下的内存回收效果很好。在程序中，开发人员可以通过选项“-XX:+UseParNewGC ”手动指定使用 ParNew 收集器执行内存回收任务。</em></p>
<ul>
<li><p>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。</p>
</li>
<li><p>-XX:+UseParNewGC：年轻代使用井行收集器，老年代使用串行收集器。</p>
</li>
</ul>
<h3 id="Parallel-收集器"><a href="#Parallel-收集器" class="headerlink" title="Parallel 收集器"></a>Parallel 收集器</h3><h4 id="与ParNew收集器的相同之处"><a href="#与ParNew收集器的相同之处" class="headerlink" title="与ParNew收集器的相同之处"></a>与ParNew收集器的相同之处</h4><p>Parallel 收集器同样也采用了复制算法、并行回收和“ Stop-the-World ”机制。</p>
<h4 id="和ParNew-收集器不同之处"><a href="#和ParNew-收集器不同之处" class="headerlink" title="和ParNew 收集器不同之处"></a>和ParNew 收集器不同之处</h4><p>Parallel 收集器可以控制程序的吞吐量大小，因此它也被称为吞吐量优先的垃圾收集器。</p>
<p>-XX:GCTimeRatio：设置执行内存回收的时间所占 JVM 运行总时间的比例，即控制 GC 的执行频率（公式为 l /(l+N)，默认值为 99，也就是说，将只有 1 %的时间用于执行垃圾回收）。</p>
<p>-XX:MaxGCPauseMills：设置执行内存回收时“ Stop-the-World ”机制的暂停时间阀值（如果指定了该选项，Parallel 收集器将会尽可能地在设定的时间范围内完成内存回收）。</p>
<p>需要注意的是，<strong>垃圾收集器中吞吐量和低延迟这两个目标本身是相互矛盾的，因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</strong></p>
<p>-XX:UseAdaptiveSizePolicy：设置 GC 的自动分代大小调节策略（开发人员将不再需要显式地设置年轻代中的一些细节参数，JVM 会根据自身当前的运行情况动态调整这些相关参数）</p>
<p>Parallel 收集器提供用于执行老年代垃圾收集的 Parallel Old 收集器（和Serial 收集器一样），Parallel Old 收集器采用了标记-压缩算法，但同样也是基于并行回收和“ Stop-the-World ”机制 。</p>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。-XX:+UseParallelGC：手动指定使用 Parallel 收集器执行内存回收任务。 </p>
<h4 id="年轻代并行回收-Parallel-Scavenge-收集器"><a href="#年轻代并行回收-Parallel-Scavenge-收集器" class="headerlink" title="年轻代并行回收( Parallel Scavenge )收集器"></a>年轻代并行回收( Parallel Scavenge )收集器</h4><p>年轻代井行回收收集器也是使用复制算法的收集器。从表面上看,它和并行收集器一样都<br>是多线程、独占式的收集器。但是,并行回收收集器有 一个重要的特点,它非常关注系统的吞<br>吐量。<br>年轻代并行回收收集器可以使用以下选项启用。</p>
<ul>
<li>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。</li>
<li>-XX:+UseParallelOldGC：年轻代和老年代都是用井行回收收集器。</li>
</ul>
<p>年轻代井行回收收集器可以使用以下选项启用</p>
<ul>
<li><p>-XX:+MaxGCPauseMills：设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。</p>
<p><em>收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。如果希望减少停顿时间，而把这个值设置得很小，为了达到预期的停顿时间，JVM 可能会使用一个较小的堆（一个小堆比一个大堆回收快），而这将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，减少了吞吐量 。</em></p>
</li>
<li><p>-XX:+GCTimeRatio：设置吞吐量大小。</p>
<p><em>它的值是一个 0 ~ 100 的整数。假设 GCTimeRatio的值为 n，那么系统将花费不超过 l/(l+n) 的时间用于垃圾收集。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/( 1 + 19)=5% 。默认情况下，它的取值是 99，即不超过 1% 的时间用于垃圾收集。</em></p>
</li>
</ul>
<h5 id="并行回收收集器与并行收集器不同之处"><a href="#并行回收收集器与并行收集器不同之处" class="headerlink" title="并行回收收集器与并行收集器不同之处"></a>并行回收收集器与并行收集器不同之处</h5><p>支持一种自适应的 GC调节策略。</p>
<p>-XX:+UseAdaptiveSizePolicy：打开自适应 GC 策略。</p>
<p><em>在这种模式下 , 年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量( GCTimeRatio )和停顿时间( MaxGCPauseMills )，让虚拟机自己完成调优工作。</em></p>
<h4 id="老年代并行回收收集器"><a href="#老年代并行回收收集器" class="headerlink" title="老年代并行回收收集器"></a>老年代并行回收收集器</h4><p>一种多线程并发的收集器。</p>
<p>一种关注吞吐量的收集器（和年轻代一样）。</p>
<p>使用标记.压缩算法，JDK1.6 之后开始启用。</p>
<p>XX:+UseParallelOldGC：在年轻代和老年代都使用并行回收收集器。（这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用）。</p>
<p>-XX:ParallelGCThreads：设置垃圾回收时的线程数量。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent-Mark-Sweep</p>
<p>在程序吞吐量优先的应用场最中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错 。 但是在某些对系统响应速度要求比较高的项目中，大家总是希望系统能够快速做出响应，而不愿意看到过多的延迟。</p>
<p>基于低延迟的考虑，JVM 的设计者们提供了基于井行回收的 CMS ( Concurrent-Marking-Sweep )收集器，它是一款优秀的老年代垃圾收集器，也可以被称作 Mostly-Concurrent 收集器。</p>
<p> CMS 天生为并发而生，低延迟是它的优势，不过垃圾收集算法却并没有采用标记-复制算法，而是采用标记-清除算法，并且也会因为“ Stop-the-world ”机制而出现短暂的暂停。</p>
<h4 id="CMS-的执行过程"><a href="#CMS-的执行过程" class="headerlink" title="CMS 的执行过程"></a>CMS 的执行过程</h4><ul>
<li><p>初始标记( Initial-Mark )阶段</p>
<p>程序中所有的工作线程都将会因为“ Stop-the-World ”机制而出现短暂的暂停，这个阶段的主要任务就是标记出内存中那些被根对象集合所连接的目标对象是否可达，一旦标记完成之后就会恢复之前被暂停的所有应用线程。</p>
</li>
<li><p>并发标记( Concurrent-Mark )阶段</p>
<p>这个阶段的主要任务就是将之前的不可达对象标记为垃圾对象。</p>
</li>
</ul>
<p><em>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此在并发标记阶段将无法有效确保之前被标记为垃圾的无用对象的引用关系遭到更改，为了解决这个问题，CMS 会进入到再次标记阶段。</em></p>
<ul>
<li><p>标记 ( Remark ) 阶段</p>
<p>程序会因为“ Stop-the-World ”机制而再次出现短暂的暂停，以确保这些垃圾对象都能够被成功且正确地标记 。</p>
</li>
<li><p>并发清除 ( Concurrent-Sweep ) 阶段</p>
<p>CMS 最终将会进入到并发清除阶段执行内存回收，释放掉无用对象所占用的内存空间。</p>
</li>
</ul>
<p><em>尽管 CMS 收集器采用的是并行回收，但是在其初始化标记和再次标记这两个阶段中仍然需要执行“ Stop-the-World ”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“ Stop-the-World ”，只是尽可能地缩短暂停时间。</em></p>
<p><em>Serial Old 收集器 、 Parallel Old 老年代垃圾收集器的垃圾收集算法都是采用标记-压缩来避免执行 Full GC 后产生内存碎片，而 CMS 收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间后，将无法使用指针碰撞( Bump the Pointer )技术，而只能选择空闲列表( Free List )执行内存分配。</em></p>
<p>在 HotSpot 中，当垃圾收集器执行完内存回收后，如果内存空间中产生内存碎片，那么只能选择空闲列表作为内存分配算法为新对象分配内存空间。简单来说，会有 JVM 负责维护一个列表，其中所记录的内容就是当前内存空间中可用内存块的坐标，当执行内存分配时，会从列表中定位到一个与新对象所需内存大小一致的连续内存块用于存储生成的对象实例。</p>
<h4 id="解决内存碎片的弊端"><a href="#解决内存碎片的弊端" class="headerlink" title="解决内存碎片的弊端"></a>解决内存碎片的弊端</h4><p>-XX: +UseCMS-CompactAtFullCollection：指定在执行完 Full GC 后是否对内存空间进行压缩整理，以此避免内存碎片的产生 。（不过由于内存压缩整理过程无法井发执行，所带来的问题就是停顿时间变得更长了。）</p>
<h4 id="解决停顿时间变长的弊端"><a href="#解决停顿时间变长的弊端" class="headerlink" title="解决停顿时间变长的弊端"></a>解决停顿时间变长的弊端</h4><p>-XX:CMSFullGCs-BeforeCompaction：用于设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
<p>除了会产生内存碎片外，CMS 收集器还存在一个不容忽视的问题，那就是在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。尽管 Full GC 大多数时候只会发生在老年代垃圾回收阶段，但是实际上 Full GC 的 回收范围却不单单仅限于老年代中，从严格意义上来说, Full GC 的回收范围 几乎覆盖了整个堆空间 , 因此 Full GC 将会比 Minor GC 耗费更长的时间来完成垃圾收集。在 HotSpot 中，除了 CMS 收集器之外的任何老年代垃圾收集器在执行内存回收时，都将会执行 Full GC ，只有 GI 收集器较为特殊。</p>
<h4 id="解决新产生的垃圾对象无法标记的弊端"><a href="#解决新产生的垃圾对象无法标记的弊端" class="headerlink" title="解决新产生的垃圾对象无法标记的弊端"></a>解决新产生的垃圾对象无法标记的弊端</h4><p>-XX:CMSlnitiatingOccupanyFraction：用于设置当老年代中的内存使用率达到多少百分比的时候执行内存回收( 低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92 %，内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 的执行次数）。</p>
<p>一旦 CMS 在执行过程中出现“ Promotion Failed ”或“ Concurrent Mode Failure ”时，仍然有可能会触发 Full GC 操作。</p>
<p>-XX:+UseConcMarkSweepGC：手动指定使用 CMS 收集器执行内存回收任务。</p>
<p>CMS 收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占 CPU ，所以在 CMS 执行期内会对应用程序吞吐量造成一定的影响。</p>
<h4 id="设定-CMS-的线程数量"><a href="#设定-CMS-的线程数量" class="headerlink" title="设定 CMS 的线程数量"></a>设定 CMS 的线程数量</h4><p> CMS 默认启动的线程数是(ParallelGCThreads+ 3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。</p>
<p>-:XX:ParallelCMSThreads：手工设定 CMS 的线程数量。</p>
<p>当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟<br>糕。</p>
<p>由于 CMS 收集器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当堆内存使用率达到某一阀值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</p>
<h4 id="指定回收阔值"><a href="#指定回收阔值" class="headerlink" title="指定回收阔值"></a>指定回收阔值</h4><p>-:XX:CMSinitiatingOccupancyFraction：指定回收阔值。（默认是 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。）</p>
<p>如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阔值，以避免频繁触发老年代串行收集器。</p>
<p>标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。</p>
<h4 id="内存碎片整理"><a href="#内存碎片整理" class="headerlink" title="内存碎片整理"></a>内存碎片整理</h4><p>-:XX:+UseCMSCompactAtFullCollection：使 CMS 在垃圾收集完成后，进行一次内存碎片整理（内存碎片的整理并不是并发进行的）。</p>
<h4 id="内存压缩"><a href="#内存压缩" class="headerlink" title="内存压缩"></a>内存压缩</h4><p>-:XX:CMSFullGCsBeforeCompaction：用于设定进行多少次 CMS 回收后，进行一次内存压缩。</p>
]]></content>
  </entry>
  <entry>
    <title>简单理解Javabean的意义</title>
    <url>/2020/03/02/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3Javabean%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>作者：杨博<br>链接：<a href="https://www.zhihu.com/question/19773379/answer/31625054" target="_blank" rel="noopener">https://www.zhihu.com/question/19773379/answer/31625054</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。</p>
<a id="more"></a>

<p>举个例子，假如有人要用Java实现一个单向链表类，可能会这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 java-int-list_1.0.jar</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Node head;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现为了能够快速获取链表的大小，把链表大小缓存在size变量中。用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaIntList myList = <span class="keyword">new</span> JavaIntList();</span><br><span class="line">System.out.println(myList.size);</span><br></pre></td></tr></table></figure>

<p>JavaIntList的作者很满意，于是开源了java-int-list库的1.0版。文件名是java-int-list_1.0.jar。发布后，吸引了许多用户来使用java-int-list_1.0.jar。<br>有一天，作者决定要节省内存，不要缓存size变量了，把代码改成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 java-int-list_2.0.jar</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Node head;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">      n = n.next;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发布了2.0版：java-int-list_2.0.jar。发布后，原有java-int-list_1.0.jar的用户纷纷升级版本到2.0。这些用户一升级，就发现自己的程序全部坏掉了，说是找不到什么size变量。于是这些用户就把作者暴打一顿，再也不敢用java-int-list库了。</p>
<p>这个故事告诉我们，如果不想被暴打致死，你就必须保持向后兼容性。太阳公司在设计Java语言时，也懂得这个道理。所以Java标准库中，绝对不会出现public int size这样的代码，而一定会一开始就写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br></pre></td></tr></table></figure>

<p>让用户一开始就使用getSize，以便有朝一日修改getSize实现时，不破坏向后兼容性。这种public int getSize() { return size; }的惯用手法，就是Java Bean。</p>
<p>现在是2014年，C#、Scala等比Java新的面向对象语言自身就提供了语言特性来实现这些常用需求，所以根本不需要Java Bean这样繁琐的约定。</p>
<p>比如，假如有个Scala版的ScalaIntList：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 scala-int-list_1.0.jar</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">next: <span class="type">Node</span>, value: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">class</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> head: <span class="type">ScalaIntList</span>.<span class="type">Node</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> size: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户这样用：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myList = <span class="keyword">new</span> <span class="type">ScalaIntList</span></span><br><span class="line">println(myList.size)</span><br></pre></td></tr></table></figure>

<p>有一天你心血来潮改成这样：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译成 scala-int-list_2.0.jar</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">next: <span class="type">Node</span>, value: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">class</span> <span class="title">ScalaIntList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> head: <span class="type">ScalaIntList</span>.<span class="type">Node</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> n = head</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">      n = n.next</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户还是照样能用，根本不破坏向后兼容性。所以Scala程序只要不考虑和Java交互，一般就不需要类似Java Bean这样的约定。</p>
<p>顺便说一句，向后兼容性分为源代码级和二进制级，Scala的var或val改为final def的话，无论源代码级的向后兼容性，还是二进制级的向后兼容性，都不遭受破坏。但C#的字段改为属性的话，虽然不破坏源代码级的向后兼容性，但是会破坏二进制级的向后兼容性。这是C#的设计缺陷，导致微软的编码规范不得不禁止使用公有字段。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>查找与排序</title>
    <url>/2020/03/02/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="查找与排序的关系"><a href="#查找与排序的关系" class="headerlink" title="查找与排序的关系"></a>查找与排序的关系</h2><p>排序的过程</p>
<ol>
<li>选择元素/位置</li>
<li>根据元素<strong>查找</strong>位置/根据位置<strong>查找</strong>元素</li>
<li>排序</li>
</ol>
<p><strong>所以查找是排序的前提，不同的查找方式导致了不同的排序方式</strong></p>
<a id="more"></a>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>根据元素查找位置</p>
<ul>
<li><h6 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a><strong>顺序查找</strong></h6></li>
<li><h6 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a><strong>折半查找</strong></h6></li>
<li><h6 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a><strong>分块查找</strong></h6></li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="根据元素查找位置"><a href="#根据元素查找位置" class="headerlink" title="根据元素查找位置"></a>根据元素查找位置</h4><ul>
<li><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><ul>
<li><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a><strong>直接插入排序</strong></h6><p>顺序查找</p>
</li>
<li><h6 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a><strong>折半插入排序</strong></h6><p>折半查找</p>
</li>
<li><h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h6><p>分块查找</p>
</li>
</ul>
</li>
</ul>
<h4 id="根据位置查找元素"><a href="#根据位置查找元素" class="headerlink" title="根据位置查找元素"></a>根据位置查找元素</h4><ul>
<li><h5 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h5><ul>
<li><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h6><p>选择无序表表尾的位置</p>
</li>
<li><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h6><p>分治思想，一趟排序递归选择多个位置，递归排序</p>
</li>
</ul>
</li>
<li><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><ul>
<li><h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a><strong>简单选择排序</strong></h6><p>选择线性表中无序表表尾位置</p>
</li>
<li><h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h6><p>选择树形结构的根或其子树的根结点</p>
</li>
</ul>
<p>堆排序之所以容易出错，是因为它是上述唯一的<strong>已排序的有序部分会在排序过程中再次变为无序</strong>的排序算法，这也是堆排序的数据结构是树这种递归结构却不能使用分治递归排序的原因。</p>
</li>
</ul>
<h4 id="两种特殊的排序算法"><a href="#两种特殊的排序算法" class="headerlink" title="两种特殊的排序算法"></a>两种特殊的排序算法</h4><ul>
<li><h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h6><p>子表之间是无序的（分治思想中，子表之间是有序的）。</p>
</li>
<li><h6 id="基排序"><a href="#基排序" class="headerlink" title="基排序"></a><strong>基排序</strong></h6><p>已排序的有序部分会在排序过程中再次变为无序，与堆排序不同，不用再次进行排序。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>make:g++:命令没找到</title>
    <url>/2018/04/20/make-g-%E5%91%BD%E4%BB%A4%E6%B2%A1%E6%89%BE%E5%88%B0/</url>
    <content><![CDATA[<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>make: g++：命令未找到<br>make: *** [outlook.o] 错误 127</p>
<h3 id="Answear"><a href="#Answear" class="headerlink" title="Answear"></a>Answear</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install g++</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BUG</category>
      </categories>
  </entry>
</search>
